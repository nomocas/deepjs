
/**
 * @author Gilles Coomans <gilles.coomans@gmail.com>

	Stable : 
		deep-query/rql
		deep
		utils



Structure :
	utils 						ok
		logs, pushTo, ...

	gestion asynch 				ok
		promises
		chain
		branches
		rejection
		

		cancel 					need more 
	

	modelisation objet 			ok
		up, bottom, etc

	navigation 					stable
        query


	CCS
	class composition

	colliders 


TODO : 
	deep-compose : manage classes
	deep-colider : write more
	deep-schema and CCS :
		CCS model and algorithm

	deep-request : complete refactoring
	
	deep-plugin : 
		Handler pattern
		handler base objects


		

	autobahn : 
		secured chain
		jsgi stack
		clean headers


 */
 		/*
			ADDITIONAL CHAIN METHODS

			logSuccess
			logFailure
			logNodes
			logValues
			logPaths

			deepest
			nearest
			rayon query
		*/
if(typeof define !== 'function')
{
	var define = require('amdefine')(module);
}

define(//["require", "deep/deep-request", "deep/utils", "deep/promise", "deep/deep-query"],
function(require){

	if(!console.warn)
		console.warn = console.log;
	if(!console.error)
		console.error = console.log;
	if(!console.info)
		console.info = console.log;

	var Validator = require("deep/deep-schema");
	var DeepRequest = require("deep/deep-request");
	var utils = require("deep/utils");
	var promise = require("deep/promise");
	var Querier = require("deep/deep-query");
	var deepCompose = require("deep/deep-compose");

	var DeepHandler = function(options)
	{
		options = options || {};
		this.querier = new Querier();
		this.callQueue = [];
		this._root = options._root || {};
		this._entries = options._entries || [];
		this.queries = [];
		this.deferred = deep.Deferred();
		this.rejected=false;
		this.reports = {
			result:null,
			failure:null
		}
	}

	function callFunctionFromValue(entry, functionName, options) 
	{
		options = options || {};
		if(options.args && !(options.args instanceof Array))
			options.args = [options.args];
		if(entry.value && entry.value[functionName])
		{
			entry.value._deep_entry = entry;
			var prom = entry.value[functionName].apply(entry.value, options.args || null);
			if(prom && prom.then)
				prom.then(function () {
					delete entry.value._deep_entry;
				},
				function () {
					delete entry.value._deep_entry;
				});
			else
				delete entry.value._deep_entry;
			return prom;
		}	
		return prom;
	}
	function runFunctionFromValue(entry, func, options) 
	{
		//console.log("runFunctionFromValue", entry)
		options = options || {};
		entry.value._deep_entry = entry;
		var prom = func.apply(entry.value, options.args || null);
		if(prom && prom.then)
			prom.then(function () {

				delete entry.value._deep_entry;
			},
			function () {
				delete entry.value._deep_entry;
			});
		else
			delete entry.value._deep_entry;
		return prom;
	}

	function createParal(self, s, e){
		return {
			branch:function ()
			{
				var cloned = cloneHandler(self, true);
				cloned.running = false;
				this.branches.push(cloned);
				nextQueueItem.apply(cloned, [s, null]);
				return cloned;
			},
			branches:[],
			_isBRANCHES_:true
		}
	}

	function nextQueueItem(result, failure )
	{
		// console.log("nextQueueItem ", this.running, " - ", this.callQueue, result, failure);
		if(this.running || this.rejected)
			return;
		this.running = true;

		if((typeof failure === 'undefined' || failure == null) && (typeof result === 'undefined' || result == null))
		{
			failure = this.reports.failure;
			result = this.reports.result;
		}
		else
		{
			this.reports.failure = failure;
			this.reports.result = result;
		}

		if(this.callQueue.length>0)
		{
			var next = this.callQueue.shift();
			var error = null;
			try{
				if(!failure)
				{
					if(typeof next === "object")
						next.func(result,failure);
					else
						next(result,failure);
				}
				else if(next._isTHEN_)
					next(result,failure);
				else if(!this.rejected)
					this.reject(failure);
			}
			catch(e)
			{
				var msg = "PANIC : throw : ("+this.name+") deep.nextQueueItem : ";
				console.error(msg, e);
				this.running = false;
				nextQueueItem.apply(this, [null, e]);
			}
		}
		else
		{
			this.running = false;
			if(failure && !this.rejected )
				this.reject(failure);
		}	
	}
	function addInQueue(func)
	{
		// console.log("add in queue : ", func);
		var last = this.callQueue[this.callQueue.length-1];
		if(func._isPUSH_HANDLER_TO_ && !this.initialised)
		{
			//console.log("addInQueue : _isPUSH_HANDLER_TO_ : running ? ", this.running)
			func();
		}
		else
			this.callQueue.push(func);

		if(!this.running)
			nextQueueItem.apply(this);
	}

	function cloneHandler(handler, cloneValues)
	{
		var newRes = [];
		if(cloneValues)
			handler._entries.forEach(function (old) {
				newRes.push(old);
			});
		var newHandler = handler.newHandler({
			root:handler._root,
			queries:utils.copyArray(handler.queries),
			_entries:newRes
		});
		return newHandler;
	}

	DeepHandler.prototype = {
		querier:null,
		_entries:null,
		callQueue:null,
		reports:null,
		queries:null,
		//_______________________________________________________________  CANCEL AND REJECT

		cancel:function (reason)  // not chainable
		{
			if(this.rejected)
				throw  new Error("deep chain could not be canceled : it has already been rejected! ")
			var queue = this.callQueue;
			this.callQueue = [];
			this.reports.cancel = reason;
			this.deferred.cancel(reason);
		},
		reject:function (reason)  // not chainable
		{
			console.log("deep chain reject : reason : ", reason)
			if(this.rejected)
				throw  new Error("deep chain has already been rejected! ")
			this.reports.failure = reason;
			this.rejected = true;
			this.callQueue = [];
			this.deferred.reject(reason);
		},
		//_____________________________________________________________  BRANCHES

		branches:function ( func ) 
		{
			var self = this;	
			var create =  function(s,e)
			{
				deep.when(func(createParal(self,s,e))).then(function (success) 
				{
					self.running = false;
					nextQueueItem.apply(self, [success, null]);
				}, 
				function (error) 
				{
					console.error("error : deep.branches : ", error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			};
			addInQueue.apply(this, [create]);
			return self;
		},
		//______________________________________________________ PROMISE INTERFACE

		done:function  (callBack) 
		{
			var self = this;
			var	func = function(s,e)
			{
				if(e || !callBack)
				{
					self.running = false;
					nextQueueItem.apply(self, [s, e]);
					return;
				}
				deep.when(callBack(s, createParal(self,s,e))).then(function (argument) {
					if(typeof argument === 'undefined')
						argument = s;
					self.running = false;
					nextQueueItem.apply(self, [argument, null]);
				}, function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			func._isTHEN_ = true;
			addInQueue.apply(this, [func]);
			return self;
		},
		fail:function (callBack)
		{
			var self = this;
			var func = function(s,e)
			{
				if(!e || !callBack)
				{
					self.running = false;
					nextQueueItem.apply(self, [s, e]);
					return;
				}
				deep.when(callBack(e, createParal(self,s,e))).then(function (argument) {
					if(typeof argument === 'undefined')
						argument = e;
					self.running = false;
					nextQueueItem.apply(self, [argument, null]);
				}, function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			func._isTHEN_ = true;
			addInQueue.apply(this,[func]);
			return self;
		},
		then:function (successCallBack, errorCallBack) 
		{
			var self = this;
			var func = function(s,e)
			{
				if(e)
				{
					if(!errorCallBack)
					{
						self.running = false;
						nextQueueItem.apply(self, [s, e]);
						return;
					}
					deep.when(errorCallBack(e, createParal(self,s,e))).then(function (argument) {
						if(typeof argument === 'undefined')
							argument = e;
						
						self.running = false;
						nextQueueItem.apply(self, [argument, null]);
					}, function (error) {
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
					return;
				}	
				if(!successCallBack)
				{
					self.running = false;
					nextQueueItem.apply(self, [s, e]);
					return;
				}
				deep.when(successCallBack(s, createParal(self,s,e))).then(function (argument) {
					if(typeof argument === 'undefined')
						argument = s;
					self.running = false;
					nextQueueItem.apply(self, [argument, null]);
				}, 
				function (error) 
				{
					self.running = false;
					nextQueueItem.apply(self, [null, error]);		
				});
			}
			func._isTHEN_ = true;
			addInQueue.apply(this,[func]);
			return self;
		},
		//___________________________________________________________________________ NAVIGATION
		first : function  () 
		{
			var self = this;
			var func = function(){
				self._entries = [self._entries[0]];
				self.running = false;
				nextQueueItem.apply(self, [true]);
			}
			addInQueue.apply(this,[func]);
			return cloned;
		},
		last : function  () 
		{
			var self = this;
			var func = function(){
				self._entries = [self._entries[self._entries.length-1]];
				self.running = false;
				nextQueueItem.apply(self, [true]);
			}
			addInQueue.apply(this,[func]);
			return cloned;
		},
		parents : function  (errorIfEmpty) 
		{
			var self = this;
			var func = function(){
				var res = [];
				self._entries.forEach(function (r) {
					res.push(r.ancestor);
				})
				res = deep.utils.arrayUnique(res, "path");
				self._entries = res;
				if(res.length == 0 && errorIfEmpty)
					throw new Error("deep.parents could not gives empty results")
				self.running = false;
				nextQueueItem.apply(self, [true, null]);
			}
			addInQueue.apply(this,[func]);
			return self;
		},
		root:function (root, schema) 
		{
			var self = this;
			var func = function()
			{
				var alls = [];
				if(root)
					alls = [DeepRequest.retrieve(root)];
				if(schema)
					alls.push(DeepRequest.retrieve(schema));
				if(alls.length > 0)
					deep.all(alls).then(function (results) {
						// console.log("deep.root : ", results)
						var root = results[0];
						var schema = results[1];
						if(root instanceof DeepHandler)
						{
							self.queries = utils.copyArray(root.queries);
							self._entries = [root._root];
							self._root = root._root;
							if(schema)
								root._root.schema= schema;
							if(root.name)
								self.name = "chained:"+root.name;
							else
								self.name = "chained:untitled";
							self.running = false;
							nextQueueItem.apply(self, [self._root.value, null]);
							return;
						}
						if(root && root._isDQ_NODE_)
						{
							//handler._root = root.value;
							if(schema)
								root.schema = schema;
							self._entries = [root];	
							self.queries = [root.path];
						}
						else if(root && root._deep_entry)
						{
							//handler._root = root._deep_entry._root.value;
							if(schema)
								root._deep_entry.schema = schema;
							self._entries = [root._deep_entry];	
							self.queries = [root._deep_entry.path];
							//console.log("deep on node with _deep_entry_ : ", root._deep_entry)
						}
						else
						{
							//handler._root = root;
							self._entries = self.querier.query(root, "/!", {resultType:"full", schema:schema || {}});	
							self.queries = ["/!"];
							if(root && root.uri)
								self.name = root.uri;
							else
								self.name = "untitled";
						}
						self._root = self._entries[0];
						self.running = false;
						nextQueueItem.apply(self, [self._root.value, null]);
					}, function (error) {
						console.log("deep.root chain error : ", error);
						throw new Error("deep.root chain error : "+error);
					});		
				else
				{
					//console.log("deep.root : ", root)
					self._entries = [self._root];	
					self.queries.push("/!");
					self.running = false;
					nextQueueItem.apply(self, [self._root.value, null]);
				}
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		query : function(q, errorIfEmpty)
		{
			var src = this;
			src.queries.push(q);
			if(!(q instanceof Array))
				q = [q];
			var func = function(){
				//console.log("do query : ", q)
				var res = [];
				if(console.flags && console.flags["deep.query.profile"])
					console.time("query")
				src._entries.forEach(function (r) {
					// console.log("do query : ", q , " - on : ", r)
					q.forEach(function (qu) {
						res = res.concat(src.querier.query(r, qu , {resultType:"full"}));
					});
					//console.log("do query : ", q , " - on : ", r, " - results \n", res);
				});
				if(console.flags && console.flags["deep.query.profile"])
					console.timeEnd("query");
				res = deep.utils.arrayUnique(res, "path");
				src._entries = res;
				if(res.length == 0 && errorIfEmpty)
					throw new Error("deep.query could not gives empty results")
				src.running = false;
				nextQueueItem.apply(src, [res, null]);
			}
			addInQueue.apply(src, [func]);
			return src;
		},
		//_________________________________________________________________    MODELISATION
		schemaUp : function(schema, metaSchema)
		{
			metaSchema = metaSchema || deep.metaSchema || {};
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(schema)).then(function (schema) {
					var alls = [];
					self._entries.forEach(function(result){
						if(!result.schema)
							result.schema = {};
						alls.push(utils.up(schema, result.schema, metaSchema));
					});
					deep.all(alls).then(function (loadeds) {
						self.running = false;
						nextQueueItem.apply(self, [true, null]);
					},
					function (error) {
						console.error("error : deep.schemaUp : ",error)
						throw new Error("error : deep.schemaUp : "+error);
					});
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		schemaBottom : function(schema, metaSchema)
		{
			metaSchema = metaSchema || deep.metaSchema || {};
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(schema)).then(function (schema) {
					var alls = [];
					self._entries.forEach(function(result){
						if(!result.schema)
							result.schema = {};
						alls.push(utils.bottom(schema, result.schema, metaSchema));
					});
					deep.all(alls).then(function (loadeds) {
						self.running = false;
						nextQueueItem.apply(self, [true, null]);
					},
					function (error) {
						console.error("error : deep.schemaBottom : ",error)
						throw new Error("error : deep.schemaBottom : "+error);
					});
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		up : function(retrievables)
		{
			var args = [];
			for(var i in arguments)
				args.push(arguments[i]);
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieveAll(args)).then(function (objects) 
				{
					self._entries.forEach(function(result){
						objects.forEach(function (object) {
							utils.up(object, result.value, result.schema, result.ancestor?result.ancestor.value:null, result.key);
						});
					});
					self.running = false;
					nextQueueItem.apply(self, [true, null]);
				},
				function (error) {
					console.error("error : deep.up : ",error);
					throw new Error("error : deep.up : "+error);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		bottom : function(retrievables)
		{
			var args = [];
			for(var i in arguments)
				args.push(arguments[i]);
			args.reverse();
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieveAll(args)).then(function (objects) 
				{
					self._entries.forEach(function(result){
						objects.forEach(function (object) {
							utils.bottom(object, result.value, result.schema, result.ancestor?result.ancestor.value:null, result.key);
						});
					});
					self.running = false;
					nextQueueItem.apply(self, [true, null]);
				}, 
				function (argument) {
					console.error("error : deep.bottom : ",error);
					throw new Error("error : deep.bottom : "+error);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		replace : function (what, by, options) 
		{
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(by, options)).then(function (by) 
				{
					self._entries.forEach(function (r) {
						self.querier.query(r, what, {resultType:"full"}).forEach(function(r){
							if(!r.ancestor)
								return;
							r.ancestor.value[r.key] = r.value = by;
						});
					});
					self.running = false;
					nextQueueItem.apply(self, [true, null]);
				}, function (argument) {
					console.error("error : deep.replace : ",error);
					throw new Error("error : deep.replace : "+error);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		remove : function (what) 
		{
			var self = this;
			var func = function(){
				self._entries.forEach(function (r) {
					self.querier.query(r, what, {resultType:"full"}).forEach(function(r)
					{
						if(!r.ancestor)
							return;
						if(r.ancestor.value instanceof Array)
							r.ancestor.value.splice(r.key,1);
						else
							delete r.ancestor.value[r.key];
					});
				});
				self.running = false;
				nextQueueItem.apply(self, [true, null]);
			}
			
			addInQueue.apply(this,[func]);
			return this;
		},
		extendsChilds : function(entry)
		{
			if(!entry)
				return entry;
			var toExtends = this.querier.query(entry, "//?backgrounds", {resultType:"full"});
			//console.log("_____________________ extendsChilds : ", path, " \n\n\n________________", obj);
			if(toExtends.length == 0)
				return entry;
			var deferred = deep.Deferred();
			var rec = toExtends[0];
			var handler = deep(rec);
			//console.log("extendsChilds : handler toExtends ", handler)

			handler.flatten().then(function () 
			{
				deep.when(handler.extendsChilds(entry)).then(function () {
				//	console.log("___________________ handler flattened ")
					deferred.resolve(entry);
				}, function (error) {
					deferred.reject(error);
				});
			},
			function (error) {
				deferred.reject(error);
			});
			//console.log("_________________Grrrrrrr");
			return deep.promise(deferred);
		},
		extendsBackgrounds:function (entry)
		{
			//console.log("extendsBackgrounds : entry : ", entry)
			var self = this;
			var value = entry;
			var root = this._root.value;
			if(!entry)
				return [];
			if(entry._isDQ_NODE_)
			{
				value = entry.value;
				root = null;
			}
			if(value.backgrounds)
			{
				var deferred = deep.Deferred();
				if(!value.backgrounds.push)
					value.backgrounds = [ value.backgrounds ];
				//console.log("will retrieve : ", value.backgrounds)
				deep.when(deep.request.retrieveAll(value.backgrounds, { root:root || entry, acceptQueryThis:true })).then(function extendedsLoaded(extendeds){
					var recursion = [];
					//console.log("__________________ extendsBackgrounds : retrieved : ", extendeds)
					while(extendeds.length > 0)
					{
						var exts = extendeds.shift();
						if(exts instanceof Array)
						{
							extendeds = exts.concat(extendeds);
							continue;
						} 
						//console.log("will recurse : ", exts)
						recursion.push(exts);
						recursion.push(self.extendsBackgrounds(exts));
					}
					deep.all(recursion).then(function (extendeds){
						var res = [];
						extendeds.forEach(function (extended){
							res = res.concat(extended);
						});
						delete value.backgrounds;
						//console.log("___________________ bacgrounds extended ")

						deferred.resolve(res);
					},function  (error) {
						console.error("currentLevel extension (backgrounds property) failed to retrieve pointed ressource(s) : "+JSON.stringify(extendeds));
						deferred.reject(error);
					});
				}, function(res){
					console.error("currentLevel extension (backgrounds property) failed to retrieve pointed ressource(s) : "+JSON.stringify(extendeds));
					deferred.reject(res);
				});
				return deep.promise(deferred);
			}	
			return [];
		},
		flatten : function()
		{
			var self = this;
			var count = 0;
			var doChilds = function(result)
			{
				//console.log("doChilds : ", result)
				//delete self._root.value._deep_entry;
				deep.when(self.extendsChilds(result)).then(function () {
					count--;
					if(count == 0)
					{
						//console.log("flatten DONE");
						self.running = false;
						nextQueueItem.apply(self, [deep.chain.values(self), null]);
					}
				}, function (error) {
					console.error("error : deep.flatten : ",error);
					throw new Error("error : deep.flatten : "+error);
				});
			}
			var func = function(){
				//console.log("will flatten : ", self._entries)
				var alls = [];
				self._entries.forEach(function (result) 
				{
					count++;
					//var oldEntry = result._deep_entry;
					//if(result._deep_entry)
					//	delete result._deep_entry;
					//console.log("deep.flatten : ", result);

<<<<<<< HEAD
					if(result.value.backgrounds)
					{
						deep.when(self.extendsBackgrounds(result)).then(function(stack) {
						//	console.log("flatten extendsBackgrounds done.")
							var f = {};
							stack.forEach(function(s){ f = utils.up(s, f, result.schema); delete s.backgrounds; });
							utils.bottom(f, result.value, result.schema);
=======
						if(result.value.backgrounds)
						{
							deep.when(self.extendsBackgrounds(result)).then(function(stack) {
							//	console.log("flatten extendsBackgrounds done.")
								var f = {};
								stack.forEach(function(s){ if(!s) return; f = utils.up(s, f, result.schema); delete s.backgrounds; });
								utils.bottom(f, result.value, result.schema);
								delete result.value.backgrounds;
								doChilds(result);
							},function (error) {
								console.error("error : deep.flatten : ", error);
								throw new Error("error : deep.flatten : "+error);
							});
>>>>>>> 6a28a8825c6bbadc99f79ddf647bdae467b87a1d
							delete result.value.backgrounds;
							doChilds(result);
						},function (error) {
							console.error("error : deep.flatten : ", error);
							throw new Error("error : deep.flatten : "+error);
						});
						delete result.value.backgrounds;
					}
					else
						doChilds(result);
				});
				if(self._entries.length == 0)
				{
					self.running = false;
					nextQueueItem.apply(self, [deep.chain.values(self), null]);
				}
			}
			
			addInQueue.apply(this,[func]);
			return this;
		},
		//______________________________________________________________  RUNS
		run : function (func, options) 
		{
			var self = this;
			options = options || {};
			var create = function(){
				// console.log("deep.run : entries : ", self._entries)
				var alls = [];
				self._entries.forEach(function(result){
					// console.log("deep.run : ", func, options, result.value[func])
					if(!func)
					{
						if(typeof result.value != "function")
							return;
						if(result.ancestor)
							alls.push(callFunctionFromValue(result.ancestor, result.key, options));
						else
							alls.push(result.value(options.args || null));
						return;
					}
					if(typeof func === 'function')
						alls.push(runFunctionFromValue(result, func, options));
					else if(typeof func === 'string')
						alls.push(callFunctionFromValue(result, func, options));
					else
						alls.push(result);
				});
				// console.log("deep.run waits for : ", alls);
				deep.all(alls).then(function (loadeds) 
				{
					//console.log("deep.run results : ", loadeds);
					if(options.callBack)
						options.callBack(loadeds);
					self.running = false;
					nextQueueItem.apply(self, [loadeds, null]);
				}, 
				function (error) 
				{
					console.error("error : deep.run : ", error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[create]);
			return this;
		},
		exec : function (func, options) 
		{
			var self = this;
			options = options || {};
			var create = function(){
				deep.when(func(options.args || null)).then(function (loadeds) 
				{
					if(options.callBack)
						options.callBack(loadeds);
					self.running = false;
					nextQueueItem.apply(self, [loadeds, null]);
				}, 
				function (error) 
				{
					console.error("error : deep.exec : ", error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[create]);
			return this;
		},

		//_______________________________________________________________ TESTS AND VALIDATIONS

		valuesEqual : function(obj, callBack)
		{
			var self = this;
			var func = function(){
				var res = deep.chain.values(self);
				var ok = utils.deepEqual(res, obj);
				var o = {equal:ok, needed:obj, needLength:obj.length, valuesLength:res.length, value:res}
				console.info("deep.valuesEqual : "+ JSON.stringify(o, null, ' '));
				if(callBack)
				{
					deep.when(callBack(o)).then(function (argument) {
						if(typeof argument === 'undefined')
							argument = o;
						self.running = false;
						nextQueueItem.apply(self, [argument, null]);	
					}, function (error) {
						self.running = false;
						nextQueueItem.apply(self, [o, error]);							
					});
				}
				else
				{
					self.running = false;
					nextQueueItem.apply(self, [o, !ok]);
				}
			}
			addInQueue.apply(this,[func]);
			return self;
		},
		equal : function(obj, callBack)
		{
			// console.log("deep.equal chaining");
			var self = this;
			var func = function(){
				//console.log("will do deep.equal : self : ", self._entries)
				var res = [];
				var errors = [];
				self._entries.forEach(function(r){
					//console.log("deep.equal : r : ",r);
					var ok = utils.deepEqual(r.value, obj);
					var o = {path:r.path, equal:ok, value:r.value, needed:obj}
					res.push(o);
					if(!ok)
						errors.push(o)
					console.info("deep.equal : "+o.equal+" : ", o);
				});
				var report = {
					equal:(self._entries.length > 0) && (errors.length==0),
					reports:res
				}; 
				if(callBack)
				{
					deep.when(callBack(report)).then(function (argument) {
						if(typeof argument === 'undefined')
							argument = report;
						self.running = false;
						nextQueueItem.apply(self, [argument, null]);
					}, function (error) {
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					})
				}	
				else
				{
					if(errors.length == 0)
						errors = null;
					self.running = false;
					nextQueueItem.apply(self, [report, errors]);
				}	
			}
			addInQueue.apply(this,[func]);
			return self;
		},
		assertTrue : function (testFunc, options) 
		{
			var self = this;
			options = options || {};

			var create = function(){
				var alls = [];
				var report = {
					valid:true,
					args:options.args || null,
					testFunction:testFunc,
					reports:[]
				};
				self._entries.forEach(function(result){
					var rep = { 
						result:false,
						value:result.value,
						path:result.path
					}
					report.reports.push(rep);
					var def = deep.Deferred();
					deep.when(testFunc(result.value, options.args || null)).then(function (testResult) {
						rep.result = testResult;
						if(testResult === true)
							rep.valid = true;
						else
							rep.valid = false;
						self.running = false;
						if(rep.valid)
							def.resolve(rep);
						else
							def.reject(rep);
					},function (testError) {
						console.error("error : deep.assertTrue : ", testError);
						report.valid = false;
						rep.result = testError;
						rep.valid = false;
						def.reject(rep);
					});
					alls.push(deep.promise(def));
				});
				deep.all(alls).then(function () 
				{
					console.info("deep.assertTrue : report : ", report);
					if(options.callBack)
					{
						deep.when(options.callBack(report)).then(function (argument) {
							if(typeof argument === 'undefined')
								argument = report;
							self.running = false;
							nextQueueItem.apply(self, [argument, null]);
						}, function (error) {
							self.running = false;
							nextQueueItem.apply(self, [report, error]);
						});
					}	
					else
					{
						self.running = false;
						nextQueueItem.apply(self, [report, !report.valid]);
					}
				}, function (error) {
					self.running = false;
					nextQueueItem.apply(self, [report, error]);
				});
			}
			
			addInQueue.apply(this,[create]);
			return this;
		},
		/**

		*/
		validate:function(callBack, options) 
		{
			options = options || {};
			var self = this;
			var func = function(){
				var  a = [];
				//console.log("deep.log : ", self._entries)
				self._entries.forEach(function (e) {
					a.push(Validator.validate(e.value, e.schema));
				})
				
				deep.all( a ).then( function ( reports ) {
					var freport = {
						valid:true,
						errors:[],
						reports:reports
					}
					var errors = []
					reports.forEach ( function ( report ) {
						if(report.valid)
							return;
						freport.valid = false;
						freport.errors.push(report);
					})
					if(options.callBack)
					{
						deep.when(options.callBack(freport)).then(function (argument) {
							if(typeof argument === 'undefined')
								argument = freport;
							self.running = false;
							nextQueueItem.apply(self, [argument, null]);
						}, function (error) {
							self.running = false;
							nextQueueItem.apply(self, [freport, error]);
						});
					}
					else
					{
						self.running = false;
						nextQueueItem.apply(self, [freport, !freport.valid]);
					}
				}, function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			
			addInQueue.apply(this,[func()]);
			return this;
		},

		// __________________________________________________ LOG

		log:function () 
		{
			var self = this;
			var args = [];
			for(var i in arguments)
			 	args.push(arguments[i]);
			// if(args.length == 0)
			 //	args.push("deep.log");
			function func(){
				return function(s,e)
				{
					if(args.length == 0)
					{
						args.push("deep.log : last success : ");
						args.push(s);
					}
					console.log.apply(console, args);
					self.running = false;
					nextQueueItem.apply(self,[s, null]);
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		logValues:function (title, options) 
		{
			var self = this;
			options = options || {};
			function func(){
				return function()
				{
					console.log(title||"deep.logValues : ", " ("+self._entries.length+" values)")
					self._entries.forEach(function (e) {
						var val = e;
						var entry = e.value._deep_entry;
						delete e.value._deep_entry;
						if(!options.full)
							val = e.value;
						if(options.pretty)
							val = JSON.stringify(val, null, ' ');
						console.log("\t- entry : ("+e.path+") : ", val);
						if(entry)
							e._deep_entry = entry;
					})
					self.running = false;
					nextQueueItem.apply(self,[true, null]);
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		// ________________________________________ READ ENTRIES

		each:function(callBack)
		{
			var self = this;
			function func(){
				return function()
				{
					var a = [];
					self._entries.forEach(function(r)
					{
						a.push(callBack(r.value));
					});
					deep.all(a).then(function (argument) {
						self.running = false;
						nextQueueItem.apply(self, [argument,null]);	
					}, function (error) {
						console.error("error : deep.each : ", error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return self;
		},
		nodes:function  (callBack) 
		{
			var self = this;
			function func(){
				return function()
				{
					var  a = [];
					self._entries.forEach(function (e) {
						a.push(e);
					})
					deep.when(callBack(a)).then(function (argument) {
						self.running = false;
						nextQueueItem.apply(self, [a, null]);
					}, function (error) {
						console.error("error : deep.values : ",error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		values:function  (callBack) 
		{
			var self = this;
			function func(){
				return function()
				{
					var  a = [];
					self._entries.forEach(function (e) {
						a.push(e.value);
					})
					deep.when(callBack(a)).then(function (argument) {
						self.running = false;
						nextQueueItem.apply(self, [a, null]);
					}, function (error) {
						console.error("error : deep.values : ",error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		paths:function  (callBack) 
		{
			var self = this;
			function func(){
				return function()
				{
					var  a = [];
					self._entries.forEach(function (e) {
						a.push(e.path);
					})
					deep.when(callBack(a)).then(function (argument) {
						self.running = false;
						nextQueueItem.apply(self, [a, null]);
					}, function (error) {
						console.error("error : deep.paths : ",error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		schemas:function  (callBack) 
		{
			var self = this;
			function func(){
				return function()
				{
					var  a = [];
					self._entries.forEach(function (e) {
						a.push(e.schema);
					})
					deep.when(callBack(a)).then(function (argument) {
						self.running = false;
						nextQueueItem.apply(self, [a, null]);
					}, function (error) {
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		//___________________________________________________________ WAIT

		delay:function (ms) 
		{
			var self = this;
			function func(){
				return function(s,e){
					//console.log("deep.delay : ", ms)
					setTimeout(function () {
						console.log("deep.delay.end : ", ms)
						self.running = false;
						nextQueueItem.apply(self, [s, null]);
					}, ms);
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		wait:function(prom)
		{
			var self = this;
			function func(){
				return function(s,e){
					deep.when(prom).then(function (datas) {
						self.running = false;
						nextQueueItem.apply(self, [datas,null]);
					}, function (e) {
						console.error("error : deep.wait : ", e);
						self.running = false;
						nextQueueItem.apply(self, [null,e]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		
		//____________________________________________________________________  LOAD

		deepLoad:function() 
		{
			var self = this;
			function func(){
				return function(s,e){
					var  paths = [];
					var  promises = [];
					//console.log("deepLoad : ", self)
					self._entries.forEach(function (e) {
						var strings = self.querier.query(e, ".//?or(_schema.type=string,_schema.type=function)", {resultType:"full"});
						strings.forEach(function (toLoad) {
							if(!toLoad.ancestor)
								throw new Error("you couldn't interpret root itself.")
							promises.push(deep.request.retrieve(toLoad.value, {root:self._root.value, basePath:toLoad.path, acceptQueryThis:true }));
							paths.push(toLoad);
						})
					})
					deep.all(promises).then(
					function (results) {
						var count = 0;
						results.forEach(function  (r) {
							var e = paths[count++];
							if(e.ancestor)
								e.ancestor.value[e.key] = e.value = r;
						})
						self.running = false;
						nextQueueItem.apply(self, [ results, null ]);
					},
					function (error) {
						console.error("error : deep.deepLoad : ", error);
					
						self.running = false;
						nextQueueItem.apply(self, [ null, error ]);
					
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},

		load:function (request) 
		{
			var self = this;
			function func(){
				return function(){
					var  paths = [];
					var  promises = [];
					//console.log("deep.load : ", deep.chain.stringify(self))
					//console.log("deep.load : entries : ", self.entries)
					if(request)
						promises.push(deep.request.retrieve(request, { callFunctions:true }));
					else
						self._entries.forEach(function (e) {
							if(!e.value)
								return;
							if(e.value.load)
								promises.push(callFunctionFromValue(e, "load"));
							else if(typeof e.value === 'string')
								promises.push(deep.request.retrieve(e.value, { root:self._root.value, basePath:e.path, callFunctions:true, acceptQueryThis:true }));
							else
								promises.push(e.value);
							paths.push(e);
						})
					deep.all(promises).then(
					function (results) {
						//console.log("deep.load results : ", results)
						var count = 0;
						if(request)
						{
							//console.log("deep.load results from request : ", self._entries)
							self._entries.forEach(function (entry) {
								if(!entry.ancestor)
									//throw new Error("You couldn't interpret root !");
										entry.value = results[0];
									else
										entry.value = entry.ancestor.value[entry.key] = results[0];
							})
						}
						else
							results.forEach(function  (r) {
								//console.log("deep.load results from inner : ", r)
								var item = paths[count++];
								if(!item.value.load)
								{
									if(!item.ancestor)
									//throw new Error("You couldn't interpret root !");
										item.value = r;
									else
										item.value = item.ancestor.value[item.key] = r;
								}
							})
						self.running = false;
						nextQueueItem.apply(self, [true, null]);
					},
					function (error) {
						console.error("deep.load errors : ", error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},

		//________________________________________________________________________ INTERPET STRINGS

		deepInterpret:function(context) 
		{
			var self = this;
			function func(){
				return function(){
					deep.when(deep.request.retrieve(context)).then(function (context) 
					{
						var res = [];
						self._entries.forEach(function (e) {
							var strings = self.querier.query(e, ".//?_schema.type=string", {resultType:"full"});
							strings.forEach(function (interpretable) {
								var r = deep.interpret(interpretable.value, context);
								res.push(r);
								if(!interpretable.ancestor)
									//throw new Error("You couldn't interpret root !");
									interpretable.value = r;
								else
									interpretable.ancestor.value[interpretable.key] = interpretable.value = r;
							})
						});
						self.running = false;
						nextQueueItem.apply(self, [res, null]);
					}, 
					function (error) 
					{
						console.error("error : deep.deepInterpret : ", error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		interpret:function(context) 
		{
			var self = this;
			function func(){
				return function(){
					deep.when(deep.request.retrieve(context)).then(function (context) {
						var res = [];
						self._entries.forEach(function (interpretable) 
						{
							var r = deep.interpret(interpretable.value, context);
							res.push(r);
							if(!interpretable.ancestor)
								//	throw new Error("You couldn't interpret root !");
								interpretable.value = r;
							else
								interpretable.ancestor.value[interpretable.key] = interpretable.value = r;
						});
						self.running = false;
						nextQueueItem.apply(self, [res, null]);
					}, function (error) {
						console.error("error : deep.interpret : ", error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},

		//________________________________________________________ PUSH TO

		pushHandlerTo:function(array) 
		{
			var self = this;
			function func(){
				var f = function()
				{
					// console.log("pushHandlerTo : init? ", self.initialised)
					array.push(self);
					if(self.initialised)
					{
						self.running = false;
						nextQueueItem.apply(self, [self, null]);
					}
				}
				f._isPUSH_HANDLER_TO_ = true;
				return f;
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		pushNodesTo:function(array) 
		{
			var self = this;
			function func(){
				return function(){
					var res = [];
					self._entries.forEach(function (e) {
						array.push(e);
						res.push(e);
					})
					self.running = false;
					nextQueueItem.apply(self, [res, null]);
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		pushValuesTo:function(array) 
		{
			var self = this;
			function func(){
				return function(){
					var res = [];
					self._entries.forEach(function (e) {
						array.push(e.value);
						res.push(e.value);
					})
					self.running = false;
					nextQueueItem.apply(self, [res, null]);
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		pushPathsTo:function(array) 
		{
			var self = this;
			var func =function(){
				var res = [];
				self._entries.forEach(function (e) {
					array.push(e.path);
					res.push(e.path);
				})
				self.running = false;
				nextQueueItem.apply(self, [res, null]);
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		pushSchemasTo:function(array) 
		{
			var self = this;
			var func = function(){
				var res = [];
				self._entries.forEach(function (e) {
					array.push(e.schema);
					res.push(e.schema);
				})
				self.running = false;
				nextQueueItem.apply(self, [res, null]);
			}
			addInQueue.apply(this,[func]);
			return this;
		},

		//____________________________________________________   IF familly

		rejectIf : function(totest)
		{
			var self = this;
			function func(){
				return function(){
					if(typeof totest === 'function')
						deep.when(totest()).then(function (res) {
							if(res)
								self.reject(res);
							else
							{
								self.running = false;
								nextQueueItem.apply(self, [res, null]);
							}
						})
					else if(totest)
						self.reject(totest);
					else
					{
						self.running = false;
						nextQueueItem.apply(self, [totest, null]);
					}	
				}
			}
			addInQueue.apply(this,[func()]);
			return self;
		},
		cancelIf : function(totest)
		{
			var self = this;
			function func(){
				return function(){
					if(typeof totest === 'function')
						deep.when(totest()).then(function (res) {
							if(res)
								self.cancel(res);
							else
							{
								self.running = false;
								nextQueueItem.apply(self, [res, null]);
							}
						})
					else if(totest)
						self.cancel(totest);
					else
					{
						self.running = false;
						nextQueueItem.apply(self, [totest, null]);
					}	
				}
			}
			addInQueue.apply(this,[func()]);
			return self;
		},

		//__________________________________________________________

		newHandler:function (options) {
			return new DeepHandler(options);
		}


	}

	

	deep = function(broot, schema)
	{
		var handler = new DeepHandler({path:"/!"});
		handler.running = true;
		var alls = [DeepRequest.retrieve(broot)];

		if(schema)
			alls.push(DeepRequest.retrieve(schema));

		 // console.log("deep(root) init : ", alls);

		deep.all(alls).then(function (results) {
			// console.log("deep(root) : loaded : ", results)
			handler.initialised = true;
			var root = results[0];
			var schema = results[1];
			if(root && root._isDQ_NODE_)
			{
				//console.log("deep(..) with DQNode : ", root)
				handler._root = root.root;
				handler._entries = [root];	
				handler.queries = [root.path];
			}
			else if(root && root._deep_entry)
			{
				 // console.log("deep(..) with _deep_entry")
				handler._root = root._deep_entry;
				handler._entries = [root._deep_entry];	
				handler.queries = [root._deep_entry.path];
			}
			else if(broot instanceof DeepHandler)
			{
				// console.log("deep(..) with DeepHandler");
				handler._entries = utils.copyArray(broot._entries)	
				handler._root = broot._root;
				handler.queries = utils.copyArray(broot.queries);
			}
			else
			{
				// console.log("deep(..) simple object")
				handler._entries = handler.querier.query(root, "/!", {resultType:"full", schema:schema || {}});	
				handler._root = handler._entries[0];
				handler.queries = ["/!"];
				if(root && root.uri)
					handler.name = root.uri;
				else
					handler.name = "untitled";
			}
			handler.running = false;
			nextQueueItem.apply(handler, [deep.chain.values(handler), null]);
		}, function (error) {
			console.log("deep start chain error : ", error);
			handler.running = false;
			nextQueueItem.apply(handler, [null, error]);
		});		
		return handler;
	}
	deep.Handler = DeepHandler;
	deep.metaSchema = {};
	deep.request = DeepRequest;
	deep.utils = utils;
	deep.validate = Validator.validate;
	deep.compose = deepCompose;
	deep.chain = {
		nextQueueItem:nextQueueItem,
		addInQueue:addInQueue,
		stringify:function (handler, options) 
		{
			options = options || {};
			var res = "";
			handler._entries.forEach(function (e) {
				if(options.pretty)
					res += JSON.stringify(e.value, null, ' ')+"\n";
				else
					res += JSON.stringify(e.value)+"\n";
			});
			return res;
		},
		values:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.value);
			});
			return res;
		},
		nodes:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e);
			});
			return res;
		},
		paths:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.paths);
			});
			return res;
		},
		schemas:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.schema);
			});
			return res;
		}
	}

	function createHandler(arg)
	{
		var handler = new DeepHandler({path:"/!"});
		handler._entries = handler.querier.query(arg, "/!", {resultType:"full", schema:{}});	
		handler.queries = ["/!"];
		if(arg && arg.uri)
			handler.name = arg.uri;
		else
			handler.name = "untitled";
		handler._root = handler._entries[0];
	//	console.log("handler created : root : ", handler._root)
		nextQueueItem.apply(handler, [handler._root.value, null]);
		return handler;
	}

	var DeepDeferred = function () 
	{
		// console.log("new deep deferred")
		this.successCallBacks = [];
		this.errorsCallBacks = [];
		this.promise = new DeepPromise(this);
	}

	DeepDeferred.prototype = {
		promise:null,
		rejected:false,
		resolved:false,
		canceled:false,
		synch:false,
		result:null,
		error:null,
		resolve:function (argument) 
		{
			// console.log("DeepDeferred.resolve");
			if(this.rejected || this.resolved || this.canceled)
				throw new Error("DeepDeferred (resolve) has already been resolved !");
			this.promise.result = this.result =  argument;
			this.resolved = this.promise.resolved = true;
			deep.sequence(this.successCallBacks, [argument]);
			this.promise.successCallBacks = this.successCallBacks = null;
			this.promise.errorsCallBacks = this.errorsCallBacks = null;
		},
		reject:function (argument) 
		{
			// console.log("DeepDeferred.reject");
			if(this.rejected || this.resolved || this.canceled)
				throw new Error("DeepDeferred (reject) has already been rejected !");
			this.promise.error = this.error = argument;
			this.rejected = this.promise.rejected = true;
			deep.sequence(this.errorsCallBacks, [argument]);
			this.promise.successCallBacks = this.successCallBacks = null;
			this.promise.errorsCallBacks = this.errorsCallBacks = null;
		},
		cancel:function (argument) 
		{
			// console.log("DeepDeferred.cancel");
			if(this.rejected || this.resolved || this.canceled)
				throw new Error("DeepDeferred (cancel) has already been canceled !");
			this.canceled = this.promise.canceled = true;
			this.promise.successCallBacks = this.successCallBacks = null;
			this.promise.errorsCallBacks = this.errorsCallBacks = null;
		},
		then:function (success, errors) 
		{
			// console.log("DeepPromise.then : ", this, success, errors);
			if(this.canceled)
			{
				console.warn("warning : you add a 'then' on promise that was canceled. You will never be called back.");
				return this;
			}
			if(this.resolved)
			{
				if(success)
				{
					var suc = success(this.result);
					if(suc && typeof suc.then === 'function')
						return suc;
					if(typeof suc !== 'undefined')
						this.result = suc;
				}	
				return this;
			}
			else if(this.rejected)
			{
				if(errors)
				{
					var er = errors(this.error);
					if(er && typeof er.then === 'function')
						return er;
					if(typeof er !== 'undefined')
						this.error = er;
				}
				return this;
			}
			if(success)
				this.successCallBacks.push(success);
			if(errors)
				this.errorsCallBacks.push(errors);
			return this;
		},
		done:function (success) 
		{
			if(this.canceled)
			{
				console.warn("warning : you add a 'done' on promise that was canceled. You will never be called back.");
				return this;
			}
			if(this.resolved)
			{
				if(success)
				{
					var suc = success(this.result);
					if(suc && typeof suc.then === 'function')
						return suc;
					if(typeof suc !== 'undefined')
						this.result = suc;
				}	
				return this;
			}
			if(success)
				this.successCallBacks.push(success);
			return this;
		},
		fail:function (errors) 
		{
			if(this.canceled)
			{
				console.warn("warning : you add a 'fail' on promise that was canceled. You will never be called back.");
				return this;
			}
			if(this.rejected)
			{
				if(errors)
				{
					var er = errors(this.error);
					if(er && typeof er.then === 'function')
						return er;
					if(typeof er !== 'undefined')
						this.error = er;
				}
				return this;
			}
			if(errors)
				this.errorsCallBacks.push(errors);
			return this;
		}
	}
	var DeepPromise = function (deferred) 
	{
		if(deferred)
		{
			this.successCallBacks = deferred.successCallBacks;
			this.errorsCallBacks = deferred.errorsCallBacks;
		}
		else
		{
			this.successCallBacks = [];
			this.errorsCallBacks = [];
		}

	}
	DeepPromise.prototype = {
		rejected:false,
		resolved:false,
		canceled:false,
		synch:false,
		result:null,
		error:null,
		then:function (success, errors) 
		{
			// console.log("DeepPromise.then : ", this, success, errors);
			if(this.canceled)
			{
				console.warn("warning : you add a 'then' on promise that was canceled. You will never be called back.");
				return this;
			}
			if((this.synch && !this.error) || this.resolved)
			{
				if(success)
				{
					var suc = success(this.result);
					if(suc && typeof suc.then === 'function')
						return suc;
					if(typeof suc !== 'undefined')
						this.result = suc;
				}	
				return this;
			}
			else if((this.synch && this.error) || this.rejected)
			{
				if(errors)
				{
					var er = errors(this.error);
					if(er && typeof er.then === 'function')
						return er;
					if(typeof er !== 'undefined')
						this.error = er;
				}
				return this;
				
			}
			if(success)
				this.successCallBacks.push(success);
			if(errors)
				this.errorsCallBacks.push(errors);
			return this;
		},
		done:function (success) 
		{
			if(this.canceled)
				return this;
			if((this.synch && !this.error) || this.resolved)
			{
				if(success)
				{
					var suc = success(this.result);
					if(suc && typeof suc.then === 'function')
						return suc;
					if(typeof suc !== 'undefined')
						this.result = suc;
				}	
				return this;
			}
			if(success)
				this.successCallBacks.push(success);
			return this;
		},
		fail:function (errors) 
		{
			if(this.canceled)
				return this;
			if((this.synch && this.error) || this.rejected)
			{
				if(errors)
				{
					var er = errors(this.error);
					if(er && typeof er.then === 'function')
						return er;
					if(typeof er !== 'undefined')
						this.error = er;
				}
				return this;
			}
			if(errors)
				this.errorsCallBacks.push(errors);
			return this;
		}
	}

	function createImmediatePromise(result)
	{
		//console.log("deep.createImmediatePromise : ", result)
		var prom = new DeepPromise();
		prom.result = result;
		prom.synch = true;
		return prom;
	}

	deep.promise = function(arg)
	{
		//console.log("deep.promise : ", arg)
		if(!arg)
			return createImmediatePromise(arg);
		if(arg._isBRANCHES_)		// chain.branches case
			return deep.all(arg.branches);
		if(arg instanceof DeepHandler)
		{
			//console.log("DEEP promise with deephandler", arg.running);
			if(arg.rejected)
				throw new Error("error : deep.promise : DeepHandler has already been rejected.");
			
			if(arg.running) // need to wait rejection or success
			{
				var def = deep.Deferred();
				arg.done(function (success) { // simply chain done handler in deep chain
					//console.log("deep.promise of DeepHandler : added then")
					if(success && success.then)
						deep.when(success).then(function (success) {
							def.resolve(success);
						}, function (error) {
							def.reject(error);
						})
					else
						def.resolve(success);
				})
				arg.deferred.fail(function (error) {  // register rejection on deep chain deferred.
					//console.log("deep.promise of DeepHandler : added error")
					def.reject(error);
				})
				return def.promise;
			}
			return arg; // nothing to wait : chain will act as immediate promise
		}
		if(typeof arg.promise === "function" )  // jquery deferred case
			return arg.promise();
		if(arg.promise)			// deep and promised-io deferred case
			return arg.promise;
		if(typeof arg.then === 'function')		//any promise compliant object
			return arg;
		return createImmediatePromise(arg);
	};

	deep.when = function (arg) 
	{
		// console.log("deep.when : ", arg)
		if(arg instanceof DeepHandler)
			return deep.promise(arg);
		if(arg && typeof arg.then === 'function')
			return arg;
		return deep.promise(arg);
	};

	deep.all = function(arr)
	{
		if(arr.length == 0)
			return deep.when([]);
		var def = deep.Deferred();
		var count = arr.length;
		var c = 0, d = -1;
		var res = [];
		arr.forEach(function (a){
			var i = d +1;
			deep.when(a).then(function(r){
				res[i] = r;
				c++;
				if(c == count)
					def.resolve(res);
			}, function (error){
				def.reject(error);
			})
			d++;
		})
		return deep.promise(def);
	};

	promise.when = deep.when;
	promise.promise = deep.promise;
	promise.all = deep.all;
	deep.Deferred = promise.Deferred = function (){
		return new DeepDeferred();
	}
	deep.metaSchema = {};
	deep.isNode = (typeof process !== 'undefined' && process.versions && process.versions.node);
	deep.rql = require("deep/deep-rql");
	deep.query = Querier.query;
	deep.collider = require("deep/deep-collider");

	deep.interpret = utils.interpret;

	deep.sequence = function (funcs, args) 
	{
		if(!funcs || funcs.length == 0)
			return args;
		var current = funcs.shift();
		var def = deep.Deferred();
		var context = {};
		var doIt = function (r) {
			deep.when(r).then(function (r) 
			{
				//console.log("deep.sequence : doIt.when : r : ", r)
				if(funcs.length == 0)
				{
					if(typeof r === 'undefined')
					{
						r = args;
						if(args.length == 1)
							r = args[0];
					}	
					//console.log("deep.sequence. resolve because funcs.length == 0 : ", r)
					def.resolve(r);
					return r;
				}
				if(typeof r === 'undefined')
					r = args;
				else
					r = [r];
				current = funcs.shift();
				doIt(current.apply(context, r));
			}, function (error) {
				def.reject(error);
			});
		}
		doIt(current.apply(context, args));
		return deep.promise(def);
	}

	deep.linker = {
		addToPath:function (section) {
			if(section instanceof DeepHandler)
				section = section._entries[0].value;
			console.log(" DEEP.LINKER Add TO PATH : ", section)
		    var old = $.address.path();
		    if(old[old.length-1] != "/")
		    	old += "/";
		    $.address.path(old+section);
		},
		setPath:function (path) {
			$.address.path(path);
		}		
	}

	return deep;

	//______________________________________________________________________________________________________________________________________
})
