<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>deep.js - deepjs API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="deepjs API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.9.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/DeepHandler.html">DeepHandler</a></li>
            
                <li><a href="..&#x2F;classes/SynchHandler.html">SynchHandler</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/deep.html">deep</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: deep.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

&#x2F;**
 * @author Gilles Coomans &lt;gilles.coomans@gmail.com&gt;

	Stable : 
		deep-query&#x2F;rql
		deep
		utils


Cadre : 

Layered&#x2F;Aspect&#x2F;OO
	relations, inheritance and relative path
MVC
	up-bottom
	
Asynch
Thin Server &#x2F; Rest
JSON

Structure :
	utils 						ok
		logs, pushTo, ...

	gestion asynch 				ok
		promises
		chain
		branches
		rejection
		

		cancel 					need more 
	

	modelisation objet 			ok
		up, bottom, etc

	navigation 					stable
        query


	CCS
	class composition

	colliders 


TODO : 
	deep
		.query just execute query (on each current entries) and inject the concatenation of results in the chain
		.move change current entries

	deep-compose : manage classes
	deep-collider : write more
	deep-schema and CCS :
		CCS model and algorithm

	deep-request : complete refactoring
	
	deep-plugin : 
		Handler pattern
		handler base objects

	promise pattern : 
		the first and only argument must give light weight (and secured - in a small dedicated object) API to access the chain handler itself SYNCHRONOUSLY 
		And : for asynch management : it must give access for branches creator and will act as promise when returned (only for branches therefor all other function of the handler are synchro)

		example : 
			deep(...).done(function(success, handler){
				var values = handler.values();
				...
				if(true)
					return handler.cancel();
				...
				if(true)
					return handler.query(&quot;.&#x2F;tata&quot;);
				...
				if(error)
					return handler.error(&quot;what you want&quot;)

				handler.branch().mybranch();
				handler.branch().mybranch();
				handler.branch().mybranch();

				return handler;
			})


	test cases pattern : 
		assertEqual
		assertValuesEqual
		assertTrue
		assertFalse
		validate

		maybe pattern to keep (clone) whole trunc to be execute in general test caser on demand (later)
			example :

			to store and execute multiple time the cloned chain (or any chain) for tests purposes : we need something like :

			var d = deep(...).pushTo(tests).keepQueue().mychain()

			and

			d.restart()

			==&gt; implies to modify the nextQueueItem
				and to keep first reference of the chain.


		put condition on tests and validation family : 
			good pattern : keep a global with flags that will be used as condition
				example : 
					deep(...).mychain().assertEqual({}, { condition:console.flags.bazar, callBack:Reporter.report })
				so you could debug live by playing with flags
	autobahn : 
		secured chain
		jsgi stack
		clean headers


 *&#x2F;
&#x2F;*
ADDITIONAL CHAIN METHODS

.enableLog()
.disableLog()


.condition(...)
.conditionEnd(...)

reverse

logNodes
logPaths

Queries : 
options:
	deepest
	nearest
	readius
	deepness

whole new functionality
	selector


	call back context : 
	in chain : use synch handler as context (no more second arguments)
	in promises : use simple empty object for the moment (maybe add particular API)
*&#x2F;

if(typeof define !== &#x27;function&#x27;)
{
	var define = require(&#x27;amdefine&#x27;)(module);
}

define([&quot;require&quot;, &quot;deep&#x2F;ie-hacks&quot;,&quot;deep&#x2F;utils&quot;, &quot;deep&#x2F;deep-rql&quot;,&quot;deep&#x2F;deep-request&quot;, &quot;deep&#x2F;deep-schema&quot;,  &quot;deep&#x2F;promise&quot;, &quot;deep&#x2F;deep-query&quot;, &quot;deep&#x2F;deep-compose&quot;],
function(require)
{
	&#x2F;&#x2F; console.log(&quot;Deep init&quot;);
	if(!console.warn)
		console.warn = console.log;
	if(!console.error)
		console.error = console.log;
	if(!console.info)
		console.info = console.log;

	var Validator = require(&quot;deep&#x2F;deep-schema&quot;);
	var DeepRequest = require(&quot;deep&#x2F;deep-request&quot;);
	var utils = require(&quot;deep&#x2F;utils&quot;);
	var promise = require(&quot;deep&#x2F;promise&quot;);
	var Querier = require(&quot;deep&#x2F;deep-query&quot;);
	var deepCompose = require(&quot;deep&#x2F;deep-compose&quot;);

	&#x2F;**
	 * Deep Synch Chain Handler (maybe deprecated)
	 * @class  SynchHandler
	 * @constructor
	 * @param {Object} obj    the object from where start synch chain
	 * @param {Object} schema the schema associated to it&#x27;s object
	 *&#x2F;
	var SynchHandler = function (obj, schema) 
	{
		if(obj instanceof DeepHandler)
		{
			this.chain = obj;
		}	
		else 
			this.chain = deep(obj, schema);
	}
	SynchHandler.prototype = {
		chain:null,
		branches:null,
		query:function (q, options) {
			var res = deep.chain.values(this.chain.query(q, options));
			return res;
		},
		&#x2F;*select:function (q, options) {
			this.chain.query(q, options);
			return this;
		},*&#x2F;
		cancelBranches:function (reason) {
			if(this.branches)
				this.branches.forEach(function (b) {
					b.cancel();
				})
			return this;
		},
		values:function () {
			return deep.chain.values(this.chain);
		},
		nodes:function () {
			return deep.chain.nodes(this.chain);
		},
		paths:function () {
			return deep.chain.paths(this.chain);
		},
		schemas:function () {
			return deep.chain.schemas(this.chain);
		},
		branch:function ()
		{
			if(!this.branches)
				this.branches = [];
			var cloned = cloneHandler(this.chain, true);
			cloned.running = false;
			this.branches.push(cloned);
			nextQueueItem.apply(cloned, [this.chain.result, this.chain.failure]);
			return cloned;
		},
		_isBRANCHES_:true,
		replace:function (what, by) {
			this.chain.replace(what,by);
			return thiss;
		},
		remove:function (what) {
			this.chain.remove(what);
			return this;
		},
		up:function () {
			var args = Array.prototype.slice.call(arguments);
			this.chain._entries.forEach(function (e) {
				args.forEach(function  (a) {
					deep.utils.up( a, e.value, e.schema );
				})	
			})
			return this;
		},
		bottom:function () {
			var args = Array.prototype.slice.call(arguments);
			this.chain._entries.forEach(function (e) {
				args.forEach(function  (a) {
					deep.utils.bottom( a, e.value, e.schema );
				});
			})
			return this;
		},
		log:function () {
			this.chain.log.apply(this.chain, arguments);
			return this;
		},
		logValues:function (msg) {
			this.chain.logValues(msg);
			return this;
		},
		error:function (argument) {
			var er = new Error(argument);
			er.values = deep.chain.values(this.chain);
			return er;
		}
	}



	function callFunctionFromValue(entry, functionName, args) 
	{
		if(typeof args === &#x27;undefined&#x27;)
			args = [];
		else if(!(args instanceof Array))
			args = [args];

		if(entry.value &amp;&amp; entry.value[functionName])
		{
			entry.value._deep_entry = entry;
			var prom = entry.value[functionName].apply(entry.value, args);
			if(prom &amp;&amp; prom.then)
				prom.then(function () {
					delete entry.value._deep_entry;
				},
				function () {
					delete entry.value._deep_entry;
				});
			else
				delete entry.value._deep_entry;
			return prom;
		}	
		return prom;
	}
	function runFunctionFromValue(entry, func, args) 
	{
		&#x2F;&#x2F;console.log(&quot;runFunctionFromValue&quot;, entry)
		if(typeof args === &#x27;undefined&#x27;)
			args = [];
		else if(!(args instanceof Array))
			args = [args];

		entry.value._deep_entry = entry;
		var prom = func.apply(entry.value, args);
		if(prom &amp;&amp; prom.then)
			prom.then(function () {
				delete entry.value._deep_entry;
			},
			function () {
				delete entry.value._deep_entry;
			});
		else
			delete entry.value._deep_entry;
		return prom;
	}



	function nextQueueItem(result, failure )
	{
		&#x2F;&#x2F;console.log(&quot;nextQueueItem &quot;, this.running, &quot; - &quot;, this.callQueue, result, failure);
		if(this.running || this.rejected)
			return;
		this.running = true;
		var self = this;
		if((typeof failure === &#x27;undefined&#x27; || failure == null) &amp;&amp; (typeof result === &#x27;undefined&#x27; || result == null))
		{
			failure = this.reports.failure;
			result = this.reports.result;
		}
		else
		{
			this.reports.failure = failure;
			this.reports.result = result;
		}
		if(this.reports.result instanceof Error)
		{
			this.reports.failure = result;
			this.reports.result = null;
		}

		if(this.callQueue.length&gt;0)
		{
			var next = this.callQueue.shift();
			var error = null;
			try{
				var previousContext = deep.context;
				if(previousContext !== this.context){
					if(previousContext &amp;&amp; previousContext.suspend){
						previousContext.suspend();
					}
					deep.context = this.context;
					if(this.context &amp;&amp; this.context.resume){
						this.context.resume();
					}
				}
				if(!failure)
				{
					if(typeof next === &quot;object&quot;)
						next.func(result,failure);
					else
						next(result,failure);
				}
				else if(next._isTHEN_)
					next(result,failure);
				else if(!this.rejected)
					this.reject(failure);
			}
			catch(e)
			{
				var msg = &quot;Internal chain error : &quot;;
				console.error(msg, e);
				if(self.rethrow)
					throw e;
				setTimeout(function(){
					self.running = false;
					nextQueueItem.apply(self, [null, e]);
				}, 1);
			}
			finally{
				if(previousContext !== this.context){
					if(this.context &amp;&amp; this.context.suspend){
						this.context.suspend();
					}
					if(previousContext &amp;&amp; previousContext.resume){
						previousContext.resume();
					}
					deep.context = previousContext;
				}
			}
		}
		else
		{
			this.running = false;
			if(failure &amp;&amp; !this.rejected )
			{
				if(!this.waitingRejection)
				{
					this.waitingRejection = true;
					setTimeout(function(){
						self.running = false;
						nextQueueItem.apply(self, [result, failure]);
					}, 1);
				}
				else
					this.reject(failure);
			}	
		}	
	}
	function addInQueue(func)
	{
		&#x2F;&#x2F; console.log(&quot;add in queue : &quot;, func);
		var last = this.callQueue[this.callQueue.length-1];
		if(func._isPUSH_HANDLER_TO_ &amp;&amp; !this.initialised)
		{
			&#x2F;&#x2F;console.log(&quot;addInQueue : _isPUSH_HANDLER_TO_ : running ? &quot;, this.running)
			func();
		}
		else
			this.callQueue.push(func);

		if(!this.running)
			nextQueueItem.apply(this);
	}

	function createSynchHandler(self, s, e){
		return new SynchHandler(self);
	}

	function cloneHandler(handler, cloneValues)
	{
		var newRes = [];
		if(cloneValues)
			handler._entries.forEach(function (old) {
				newRes.push(old);
			});
		var newHandler = handler.newHandler({
			root:handler._root,
			queries:utils.copyArray(handler.queries),
			_entries:newRes
		});
		newHandler.reports.result = handler.reports.result;
		newHandler.reports.failure = handler.reports.failure;
		return newHandler;
	}

	&#x2F;**
	 * Deep Chain Handler  : manage asynch and synch in one chain
	 * @class DeepHandler
	 * @constructor
	 * @param {Object} obj    [description]
	 * @param {Object} schema [description]
	 *&#x2F;
	var DeepHandler = function(options)
	{
		this.rethrow = deep.rethrow;
		this.positions = {};
		this.context = deep.context;
		options = options || {};
		this.querier = new Querier();
		this.callQueue = [];
		this._root = options._root || {};
		this._entries = options._entries || [];
		this.queries = [];
		this.deferred = deep.Deferred();
		this.rejected=false;
		this.reports = {
			result:null,
			failure:null
		}
	}
	DeepHandler.prototype = {
		querier:null,
		synch:true,
		_entries:null,
		callQueue:null,
		reports:null,
		queries:null,
		reverse:function () {
			var self = this;	
			var create =  function(s,e)
			{
				self._entries.reverse();
				self.running = false;
				nextQueueItem.apply(self, [self._entries, null]);
			};
			addInQueue.apply(this, [create]);
			return self;
		},
		catchError:function () {
			var self = this;	
			var create =  function(s,e)
			{
				self.rethrow = false;
				self.running = false;
				nextQueueItem.apply(self, [s, e]);
			};
			addInQueue.apply(this, [create]);
			return self;
		},
		&#x2F;&#x2F;_______________________________________________________________  CANCEL AND REJECT

		cancel:function (reason)  &#x2F;&#x2F; not chainable
		{
			if(this.rejected)
				throw  new Error(&quot;deep chain could not be canceled : it has already been rejected! &quot;)
			var queue = this.callQueue;
			this.callQueue = [];
			this.reports.cancel = reason;
			this.deferred.cancel(reason);
		},
		reject:function (reason)  &#x2F;&#x2F; not chainable
		{
			console.log(&quot;deep chain reject : reason : &quot;, reason)
			if(this.rejected)
				throw  new Error(&quot;deep chain has already been rejected! &quot;)
			this.reports.failure = reason;
			this.rejected = true;
			this.callQueue = [];
			this.deferred.reject(reason);
		},
		&#x2F;&#x2F;_____________________________________________________________  BRANCHES

		branches:function ( func ) 
		{
			var self = this;	
			var create =  function(s,e)
			{
				deep.when(func(createSynchHandler(self,s,e))).then(function (success) 
				{
					self.running = false;
					nextQueueItem.apply(self, [success, null]);
				}, 
				function (error) 
				{
					console.error(&quot;error : deep.branches : &quot;, error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			};
			addInQueue.apply(this, [create]);
			return self;
		},
		&#x2F;&#x2F;______________________________________________________ PROMISE INTERFACE
		when:function(prom)
		{
			var self = this;
			function func(){
				return function(s,e){
					deep.when(prom).then(function (datas) {
						if(typeof datas === &#x27;undefined&#x27;)
							datas = s;
						self.running = false;
						nextQueueItem.apply(self, [datas,null]);
					}, function (e) {
						console.error(&quot;error : deep.chain.when : &quot;, e);
						self.running = false;
						nextQueueItem.apply(self, [null,e]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		done:function  (callBack) 
		{
			var self = this;
			var	func = function(s,e)
			{
				&#x2F;&#x2F;console.log(&quot;deep.chain.done : &quot;,s,e)
				if(e || !callBack)
				{
					self.running = false;
					nextQueueItem.apply(self, [s, e]);
					return;
				}
				&#x2F;&#x2F;console.log(&quot;done : self : &quot;, self._entries);

				deep.when(callBack(s, createSynchHandler(self,s,e))).then(function (argument) {
					var error = null;
					if(typeof argument === &#x27;undefined&#x27;)
						argument = s;
					else if(argument instanceof Error)
					{
						error = argument;
						argument = null;
					}
					self.running = false;
					nextQueueItem.apply(self, [argument, error]);
				}, function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			func._isTHEN_ = true;
			addInQueue.apply(this, [func]);
			return self;
		},
		fail:function (callBack)
		{
			var self = this;
			var func = function(s,e)
			{
				&#x2F;&#x2F;console.log(&quot;deep.chain.fail : &quot;,s,e)
				if((e == null || typeof e === &#x27;undefined&#x27;) || !callBack)
				{
					self.running = false;
					nextQueueItem.apply(self, [s, e]);
					return;
				}
				deep.when(callBack(e, createSynchHandler(self,s,e))).then(function (argument) {
					if(typeof argument === &#x27;undefined&#x27;)
					{
						self.running = false;
						nextQueueItem.apply(self, [null, e]);
					}
					else if(argument instanceof Error)
					{
						self.running = false;
						nextQueueItem.apply(self, [null, argument]);
					}
					else
					{
						self.running = false;
						nextQueueItem.apply(self, [argument, null]);
					}
				}, function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			func._isTHEN_ = true;
			addInQueue.apply(this,[func]);
			return self;
		},
		then:function (successCallBack, errorCallBack) 
		{
			if(successCallBack)
				this.done(successCallBack);
			if(errorCallBack)
				this.fail(errorCallBack);
			return this;
		},
		&#x2F;&#x2F;___________________________________________________________________________ NAVIGATION
		&#x2F;*range : function  (start,end) 
		{
			var self = this;
			var func = function(){
				self.running = false;
				nextQueueItem.apply(self, [self._entries]);
			}
			addInQueue.apply(this,[func]);
			return cloned;
		},*&#x2F;
		position : function  (name) 
		{
			var self = this;
			var func = function(s,e){
				self.positions[name] = self._entries.concat([]);
				self.running = false;
				nextQueueItem.apply(self, [s,e]);
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		back : function  (name) 
		{
			var self = this;
			var func = function(s,e){
				if(!self.positions[name])
					throw new Error(&quot;chain handler error : no positions to go back with name : &quot;+name);
				self._entries = self.positions[name];
				self.running = false;
				nextQueueItem.apply(self, [self._entries,null]);
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		first : function  () 
		{
			var self = this;
			var func = function(){
				self._entries = [self._entries[0]];
				self.running = false;
				nextQueueItem.apply(self, [self._entries]);
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		last : function  () 
		{
			var self = this;
			var func = function(){
				self._entries = [self._entries[self._entries.length-1]];
				self.running = false;
				nextQueueItem.apply(self, [self._entries]);
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		parents : function  (errorIfEmpty) 
		{
			var self = this;
			var func = function(){
				var res = [];
				self._entries.forEach(function (r) {
					res.push(r.ancestor);
				})
				res = deep.utils.arrayUnique(res, &quot;path&quot;);
				self._entries = res;
				if(res.length == 0 &amp;&amp; errorIfEmpty)
					throw new Error(&quot;deep.parents could not gives empty results&quot;)
				self.running = false;
				nextQueueItem.apply(self, [self._entries, null]);
			}
			addInQueue.apply(this,[func]);
			return self;
		},
		root:function (root, schema) 
		{
			var self = this;
			var func = function()
			{
				var alls = [];
				if(root)
					alls = [DeepRequest.retrieve(root)];
				if(schema)
					alls.push(DeepRequest.retrieve(schema));
				if(alls.length &gt; 0)
					deep.all(alls).then(function (results) {
						&#x2F;&#x2F; console.log(&quot;deep.root : &quot;, results)
						var root = results[0];
						var schema = results[1];
						if(root instanceof DeepHandler)
						{
							self.queries = utils.copyArray(root.queries);
							self._entries = [root._root];
							self._root = root._root;
							if(schema)
								root._root.schema= schema;
							if(root.name)
								self.name = &quot;chained:&quot;+root.name;
							else
								self.name = &quot;chained:untitled&quot;;
							self.running = false;
							nextQueueItem.apply(self, [self._root.value, null]);
							return;
						}
						if(root &amp;&amp; root._isDQ_NODE_)
						{
							&#x2F;&#x2F;handler._root = root.value;
							if(schema)
								root.schema = schema;
							self._entries = [root];	
							self.queries = [root.path];
						}
						else if(root &amp;&amp; root._deep_entry)
						{
							&#x2F;&#x2F;handler._root = root._deep_entry._root.value;
							if(schema)
								root._deep_entry.schema = schema;
							self._entries = [root._deep_entry];	
							self.queries = [root._deep_entry.path];
							&#x2F;&#x2F;console.log(&quot;deep on node with _deep_entry_ : &quot;, root._deep_entry)
						}
						else
						{
							&#x2F;&#x2F;handler._root = root;
							self._entries = self.querier.query(root, &quot;&#x2F;!&quot;, {resultType:&quot;full&quot;, schema:schema || {}});	
							self.queries = [&quot;&#x2F;!&quot;];
							if(root &amp;&amp; root.uri)
								self.name = root.uri;
							else
								self.name = &quot;untitled&quot;;
						}
						self._root = self._entries[0];
						self.running = false;
						nextQueueItem.apply(self, [self._root.value, null]);
					}, function (error) {
						console.log(&quot;deep.root chain error : &quot;, error);
						throw new Error(&quot;deep.root chain error : &quot;+error);
					});		
				else
				{
					&#x2F;&#x2F;console.log(&quot;deep.root : &quot;, root)
					self._entries = [self._root];	
					self.queries.push(&quot;&#x2F;!&quot;);
					self.running = false;
					nextQueueItem.apply(self, [self._root.value, null]);
				}
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		query : function(q, errorIfEmpty)
		{
			var src = this;
			src.queries.push(q);
			if(!(q instanceof Array))
				q = [q];
			var func = function(){
				&#x2F;&#x2F;console.log(&quot;do query : &quot;, q)
				var res = [];
				if(console.flags &amp;&amp; console.flags[&quot;deep.query.profile&quot;])
					console.time(&quot;query&quot;)
				src._entries.forEach(function (r) {
					&#x2F;&#x2F; console.log(&quot;do query : &quot;, q , &quot; - on : &quot;, r)
					q.forEach(function (qu) {
						res = res.concat(src.querier.query(r, qu , {resultType:&quot;full&quot;}));
					});
					&#x2F;&#x2F;console.log(&quot;do query : &quot;, q , &quot; - on : &quot;, r, &quot; - results \n&quot;, res);
				});
				if(console.flags &amp;&amp; console.flags[&quot;deep.query.profile&quot;])
					console.timeEnd(&quot;query&quot;);
				res = deep.utils.arrayUnique(res, &quot;path&quot;);
				src._entries = res;
				if(res.length == 0 &amp;&amp; errorIfEmpty)
					throw new Error(&quot;deep.query could not gives empty results&quot;)
				src.running = false;
				nextQueueItem.apply(src, [res, null]);
			}
			addInQueue.apply(src, [func]);
			return src;
		},
		&#x2F;&#x2F;_________________________________________________________________    MODELISATION
		schema : function(schema)
		{
			&#x2F;&#x2F;metaSchema = metaSchema || deep.metaSchema || {};
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(schema)).then(function (schema) {
					&#x2F;&#x2F;var schema = schemas.shift();
					&#x2F;&#x2F;var metaSchema = schemas.shift();
					var alls = [];
					self._entries.forEach(function(result){
						result.schema = schema;
					});
					
					self.running = false;
					nextQueueItem.apply(self, [schema, null]);
					
				})
				.fail(function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		schemaUp : function(schema, metaSchema)
		{
			metaSchema = metaSchema || deep.metaSchema || {};
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(schema))
				.done(function (schema) {
					var alls = [];
					self._entries.forEach(function(result){
						if(!result.schema)
							result.schema = {};
						alls.push(utils.up(schema, result.schema, metaSchema));
					});
					deep.all(alls).then(function (loadeds) {
						self.running = false;
						nextQueueItem.apply(self, [self._entries, null]);
					},
					function (error) {
						console.error(&quot;error : deep.schemaUp : &quot;,error)
						throw new Error(&quot;error : deep.schemaUp : &quot;+error);
					});
				})
				.fail(function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		schemaBottom : function(schema, metaSchema)
		{
			metaSchema = metaSchema || deep.metaSchema || {};
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(schema))
				.done(function (schema) {
					var alls = [];
					self._entries.forEach(function(result){
						if(!result.schema)
							result.schema = {};
						alls.push(utils.bottom(schema, result.schema, metaSchema));
					});
					deep.all(alls).then(function (loadeds) {
						self.running = false;
						nextQueueItem.apply(self, [self._entries, null]);
					},
					function (error) {
						console.error(&quot;error : deep.schemaBottom : &quot;,error)
						throw new Error(&quot;error : deep.schemaBottom : &quot;+error);
					});
				})
				.fail(function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		up : function(retrievables)
		{
			var args = Array.prototype.slice.call(arguments);
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieveAll(args)).then(function (objects) 
				{
					self._entries.forEach(function(result){
						objects.forEach(function (object) {
							&#x2F;&#x2F;console.log(&quot;deep.up : entry : &quot;, result, &quot; - to apply : &quot;, object)
							utils.up(object, result.value, result.schema, result.ancestor?result.ancestor.value:null, result.key);
						});
					});
					self.running = false;
					nextQueueItem.apply(self, [self._entries, null]);
				},
				function (error) {
					console.error(&quot;error : deep.up : &quot;,error);
					throw new Error(&quot;error : deep.up : &quot;+error);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		bottom : function(retrievables)
		{
			var args = Array.prototype.slice.call(arguments);
			
			args.reverse();
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieveAll(args)).then(function (objects) 
				{
					self._entries.forEach(function(result){
						objects.forEach(function (object) {
							utils.bottom(object, result.value, result.schema, result.ancestor?result.ancestor.value:null, result.key);
						});
					});
					self.running = false;
					nextQueueItem.apply(self, [self._entries, null]);
				}, 
				function (argument) {
					&#x2F;&#x2F;console.error(&quot;error : deep.bottom : &quot;,error);
					throw new Error(&quot;error : deep.bottom : &quot;+error);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		replace : function (what, by, options) 
		{
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(by, options)).then(function (by) 
				{
					self._entries.forEach(function (r) {
						self.querier.query(r, what, {resultType:&quot;full&quot;}).forEach(function(r){
							if(!r.ancestor)
								return;
							r.ancestor.value[r.key] = r.value = by;
						});
					});
					self.running = false;
					nextQueueItem.apply(self, [by, null]);
				}, function (argument) {
					&#x2F;&#x2F;console.error(&quot;error : deep.replace : &quot;,error);
					throw new Error(&quot;error : deep.replace : &quot;+error);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		remove : function (what) 
		{
			var self = this;
			var func = function(){
				self._entries.forEach(function (r) {
					self.querier.query(r, what, {resultType:&quot;full&quot;}).forEach(function(r)
					{
						if(!r.ancestor)
							return;
						if(r.ancestor.value instanceof Array)
							r.ancestor.value.splice(r.key,1);
						else
							delete r.ancestor.value[r.key];
					});
				});
				self.running = false;
				nextQueueItem.apply(self, [deep.chain.values(self), null]);
			}
			
			addInQueue.apply(this,[func]);
			return this;
		},
		extendsChilds : function(entry)
		{
			if(!entry)
				return entry;
			var toExtends = this.querier.query(entry, &quot;&#x2F;&#x2F;?backgrounds&quot;, {resultType:&quot;full&quot;});
			&#x2F;&#x2F;console.log(&quot;_____________________ extendsChilds : &quot;, path, &quot; \n\n\n________________&quot;, obj);
			if(toExtends.length == 0)
				return entry;
			var deferred = deep.Deferred();
			var rec = toExtends[0];
			var handler = deep(rec);
			&#x2F;&#x2F;console.log(&quot;extendsChilds : handler toExtends &quot;, handler)

			handler.flatten().then(function () 
			{
				deep.when(handler.extendsChilds(entry)).then(function () {
				&#x2F;&#x2F;	console.log(&quot;___________________ handler flattened &quot;)
					deferred.resolve(entry);
				}, function (error) {
					deferred.reject(error);
				});
			},
			function (error) {
				deferred.reject(error);
			});
			&#x2F;&#x2F;console.log(&quot;_________________Grrrrrrr&quot;);
			return deep.promise(deferred);
		},
		extendsBackgrounds:function (entry)
		{
			&#x2F;&#x2F;console.log(&quot;extendsBackgrounds : entry : &quot;, entry)
			var self = this;
			var value = entry;
			var root = this._root.value;
			if(!entry)
				return [];
			if(entry._isDQ_NODE_)
			{
				value = entry.value;
				root = null;
			}
			if(value.backgrounds)
			{
				var deferred = deep.Deferred();
				if(!value.backgrounds.push)
					value.backgrounds = [ value.backgrounds ];
				&#x2F;&#x2F;console.log(&quot;will retrieve : &quot;, value.backgrounds)
				deep.when(deep.request.retrieveAll(value.backgrounds, { root:root || entry, acceptQueryThis:true })).then(function extendedsLoaded(extendeds){
					var recursion = [];
					&#x2F;&#x2F;console.log(&quot;__________________ extendsBackgrounds : retrieved : &quot;, extendeds)
					while(extendeds.length &gt; 0)
					{
						var exts = extendeds.shift();
						if(exts instanceof Array)
						{
							extendeds = exts.concat(extendeds);
							continue;
						} 
						&#x2F;&#x2F;console.log(&quot;will recurse : &quot;, exts)
						recursion.push(exts);
						recursion.push(self.extendsBackgrounds(exts));
					}
					deep.all(recursion).then(function (extendeds){
						var res = [];
						extendeds.forEach(function (extended){
							res = res.concat(extended);
						});
						delete value.backgrounds;
						&#x2F;&#x2F;console.log(&quot;___________________ bacgrounds extended &quot;)

						deferred.resolve(res);
					},function  (error) {
						console.error(&quot;currentLevel extension (backgrounds property) failed to retrieve pointed ressource(s) : &quot;+JSON.stringify(extendeds));
						deferred.reject(error);
					});
				}, function(res){
					console.error(&quot;currentLevel extension (backgrounds property) failed to retrieve pointed ressource(s) : &quot;+JSON.stringify(extendeds));
					deferred.reject(res);
				});
				return deep.promise(deferred);
			}	
			return [];
		},
		&#x2F;*ccs:function (ccs) {
			
				&#x2F;&#x2F;jquery :
				&#x2F;&#x2F;$(...).css()
			
			var self = this;
			var func = function (s,e) {
				self._entries.forEach(function (e) {
					if(e.schema)
					{
						var toApply = deep.query(e.schema, &quot;&#x2F;&#x2F;ccs&quot;, { resultType:&quot;full&quot;});

					}
				})
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		*&#x2F;
		flatten : function()
		{
			var self = this;
			var count = 0;
			var doChilds = function(result)
			{
				&#x2F;&#x2F;console.log(&quot;deep.flatten : doChilds : &quot;, result)
				&#x2F;&#x2F;delete self._root.value._deep_entry;
				deep.when(self.extendsChilds(result)).then(function () {
					count--;
					if(count == 0)
					{
						&#x2F;&#x2F;console.log(&quot;flatten DONE&quot;);
						self.running = false;
						nextQueueItem.apply(self, [deep.chain.values(self), null]);
					}
				}, function (error) {
					console.error(&quot;error : deep.flatten : &quot;,error);
					throw new Error(&quot;error : deep.flatten : &quot;+error);
				});
			}
			var func = function(){
				&#x2F;&#x2F;console.log(&quot;will flatten : &quot;, self._entries)
				var alls = [];
				self._entries.forEach(function (result) 
				{
					count++;
					if(result.value.backgrounds)
					{
						deep.when(self.extendsBackgrounds(result)).then(function(stack) {
						&#x2F;&#x2F;	console.log(&quot;flatten extendsBackgrounds done.&quot;)
							var f = {};
							stack.forEach(function(s){ f = utils.bottom(s, result.value, result.schema); delete s.backgrounds; });
							delete result.value.backgrounds;
							doChilds(result);
						},function (error) {
							console.error(&quot;error : deep.flatten : &quot;, error);
							throw new Error(&quot;error : deep.flatten : &quot;+error);
						});
						delete result.value.backgrounds;
					}
					else
						doChilds(result);
				});
				if(self._entries.length == 0)
				{
					self.running = false;
					nextQueueItem.apply(self, [deep.chain.values(self), null]);
				}
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		&#x2F;&#x2F;______________________________________________________________  RUNS
		&#x2F;**
		 * run : loop on entries, apply &#x27;func&#x27; with &#x27;args&#x27; on each entry (entry become &#x27;this&#x27; of func)
		 *
		 * - loop on entries : true
		 * - chainable : true
		 * - transparent : false
		 * - promised management : true
		 * - success injected : the array of results of each call on func
		 * - error injected : any error returned (or produced) from a func call
		 * @method run
		 * @param  {Function} func any function that need to be apply on each chain entry
		 * @param  {Array} args the arguments to pass to &#x27;func&#x27;
		 * @return {DeepHandler}  the current chain handler (this)
		 *&#x2F;
		run : function (func, args) 
		{
			var self = this;
			args = args || [];
			var create = function(s,e){
				&#x2F;&#x2F; console.log(&quot;deep.run : entries : &quot;, self._entries)
				var alls = [];
				self._entries.forEach(function(result){
					&#x2F;&#x2F; console.log(&quot;deep.run : &quot;, func, args, result.value[func])
					if(!func)
					{
						if(typeof result.value != &quot;function&quot;)
							return;
						if(result.ancestor)
							alls.push(callFunctionFromValue(result.ancestor, result.key, args));
						else
							alls.push(result.value(args || null));
						return;
					}
					if(typeof func === &#x27;function&#x27;)
						alls.push(runFunctionFromValue(result, func, args));
					else if(typeof func === &#x27;string&#x27;)
						alls.push(callFunctionFromValue(result, func, args));
					else
						alls.push(result);
				});
				&#x2F;&#x2F; console.log(&quot;deep.run waits for : &quot;, alls);
				deep.all(alls).then(function (loadeds) 
				{
					&#x2F;&#x2F;console.log(&quot;deep.run results : &quot;, loadeds);
					self.running = false;
					nextQueueItem.apply(self, [loadeds, null]);
				}, 
				function (error) 
				{
					console.error(&quot;error : deep.run : &quot;, error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[create]);
			return this;
		},
		&#x2F;**
		 * exec :  call &#x27;func&#x27; with &#x27;args&#x27; (the &#x27;this&#x27; of the function isn&#x27;t modified)
		 *
		 * - loop on entries : false
		 * - chainable : true
		 * - transparent : false
		 * - promised management : true
		 * - success injected : the result of the call on func
		 * - error injected : any error returned (or produced) from func call
		 *
		 * @method  exec
		 * @param  {Function} func any function that need to be apply on each chain entry
		 * @param  {Array} args the arguments to pass to &#x27;func&#x27;
		 * @return {DeepHandler}  the current chain handler (this)
		 *&#x2F;
		exec : function (func, args) 
		{
			var self = this;
			args = args || [];
			var create = function()
			{
				deep.when(func.apply({}, args)).then(function (loadeds) 
				{
					self.running = false;
					nextQueueItem.apply(self, [loadeds, null]);
				}, 
				function (error) 
				{
					console.error(&quot;error : deep.exec : &quot;, error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[create]);
			return this;
		},

		&#x2F;&#x2F;_______________________________________________________________ TESTS AND VALIDATIONS

		&#x2F;**
		 * valuesEqual : test strict equality between the array of entries values and a provided array of value
		 *
		 * - loop on entries : false
		 * - chainable : true
		 * - transparent : false
		 * - promised management : true (on callBack)
		 * - success injected : the result of the callBack or the report if callback returned nothing
		 * - error injected : the report or any error returned (or produced) from callBack
		 *
		 * @method  valuesEqual
		 * @param  {Object} obj      the object to test equality
		 * @param  {Function} callBack optional : any callBack to manage the report. Could return a promise.
		 * @return {DeepHandler}     this
		 *&#x2F;
		valuesEqual : function(obj, callBack)
		{
			var self = this;
			var func = function(){
				var res = deep.chain.values(self);
				var o = {equal:utils.deepEqual(res, obj), needed:obj, needLength:obj.length, valuesLength:res.length, value:res}
				console.info(&quot;deep.valuesEqual : &quot;+ JSON.stringify(o, null, &#x27; &#x27;));
				if(callBack)
				{
					deep.when(callBack(o)).then(function (argument) {
						if(typeof argument === &#x27;undefined&#x27;)
							argument = o;
						self.running = false;
						nextQueueItem.apply(self, [argument, null]);	
					}, function (error) {
						self.running = false;
						nextQueueItem.apply(self, [o, error]);							
					});
				}
				else
				{
					self.running = false;
					nextQueueItem.apply(self, [o, !o.equal]);
				}
			}
			addInQueue.apply(this,[func]);
			return self;
		},

		&#x2F;**
		 * equal test strict equality on each entry value against provided object
		 * @param  {*} obj      the object to test
		 * @param  {Function} 	optional. callBack a callBack to manage report
		 * @return {DeepHandler}        this
		 *&#x2F;
		equal : function(obj, callBack)
		{
			&#x2F;&#x2F; console.log(&quot;deep.equal chaining&quot;);
			var self = this;
			var func = function(){
				&#x2F;&#x2F;console.log(&quot;will do deep.equal : self : &quot;, self._entries)
				var res = [];
				var errors = [];
				self._entries.forEach(function(r){
					&#x2F;&#x2F;console.log(&quot;deep.equal : r : &quot;,r);
					var ok = utils.deepEqual(r.value, obj);
					var o = {path:r.path, equal:ok, value:r.value, needed:obj}
					res.push(o);
					if(!ok)
						errors.push(o)
					console.info(&quot;deep.equal : &quot;+o.equal+&quot; : &quot;, o);
				});
				var report = {
					equal:(self._entries.length &gt; 0) &amp;&amp; (errors.length==0),
					reports:res
				}; 
				if(callBack)
				{
					deep.when(callBack(report)).then(function (argument) {
						if(typeof argument === &#x27;undefined&#x27;)
							argument = report;
						self.running = false;
						nextQueueItem.apply(self, [argument, null]);
					}, function (error) {
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					})
				}	
				else
				{
					if(errors.length == 0)
						errors = null;
					self.running = false;
					nextQueueItem.apply(self, [report, errors]);
				}	
			}
			addInQueue.apply(this,[func]);
			return self;
		},

		&#x2F;**
		 * validate apply validation
		 * @method  validate
		 * @param  {Object} options [description]
		 * @return {DeepHandler}         [description]
		 *&#x2F;
		validate:function(options) 
		{
			options = options || {};
			var self = this;
			var func = function(){
				var  a = [];
				&#x2F;&#x2F;console.log(&quot;deep.log : &quot;, self._entries)
				self._entries.forEach(function (e) {
					a.push(Validator.validate(e.value, e.schema));
				})
				
				deep.all( a ).then( function ( reports ) {
					var freport = {
						valid:true,
						reports:reports
					}
					reports.forEach ( function ( report ) {
						if(report.valid)
							return;
						freport.valid = false;
					})
					if(options.callBack)
					{
						deep.when(options.callBack(freport)).then(function (argument) {
							if(typeof argument === &#x27;undefined&#x27;)
								argument = freport;
							self.running = false;
							nextQueueItem.apply(self, [argument, null]);
						}, function (error) {
							self.running = false;
							nextQueueItem.apply(self, [freport, error]);
						});
					}
					else
					{
						self.running = false;
						nextQueueItem.apply(self, [null, freport]);
					}
				}, function (error) {
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},

		&#x2F;&#x2F; __________________________________________________ LOG

		log:function () 
		{
			var self = this;
	
			var args = Array.prototype.slice.call(arguments);
			&#x2F;&#x2F; if(args.length == 0)
			 &#x2F;&#x2F;	args.push(&quot;deep.log&quot;);
			 &#x2F;&#x2F;console.log(&quot;deep.log : args : &quot;,JSON.stringify(arguments))
			var func = function(s,e)
			{
				if(args.length == 0)
				{
					args.push(&quot;deep.log : last success : &quot;);	
					args.push(s);
				}
				args.forEach(function (a) {
					console.log(a);
				});
				self.running = false;
				nextQueueItem.apply(self,[s, null]);
			}
			
			addInQueue.apply(this,[func]);
			return this;
		},
		logValues:function (title, options) 
		{
			var self = this;
			options = options || {};
			var func = function()
				{
					console.log(title||&quot;deep.logValues : &quot;, &quot; (&quot;+self._entries.length+&quot; values)&quot;)
					self._entries.forEach(function (e) {
						var val = e;
						var entry = e.value._deep_entry;
						delete e.value._deep_entry;
						if(!options.full)
							val = e.value;
						if(options.pretty)
							val = JSON.stringify(val, null, &#x27; &#x27;);
						console.log(&quot;\t- entry : (&quot;+e.path+&quot;) : &quot;, val);
						if(entry)
							e._deep_entry = entry;
					})
					self.running = false;
					nextQueueItem.apply(self,[true, null]);
				}
			
			addInQueue.apply(this,[func]);
			return this;
		},
		&#x2F;&#x2F; ________________________________________ READ ENTRIES

		val:function  (callBack) 
		{
			var self = this;
			var func = function()
			{
				var  a = self._entries[0]?self._entries[0].value:null;
				deep.when(callBack(a)).then(function (argument) {
					if(typeof argument === &quot;undefined&quot;)
						argument = a;
					self.running = false;
					if(argument instanceof Error)
						nextQueueItem.apply(self, [null, argument]);
					else
						nextQueueItem.apply(self, [argument, null]);
				}, function (error) {
					console.error(&quot;error : deep.values : &quot;,error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			if(callBack)
			{
				addInQueue.apply(this,[func]);
				return this;
			}	
			else
				return deep.chain.values(this).shift();
		},
		each:function  (callBack) 
		{
			var self = this;
			var func = function()
			{
				var alls = [];
				self._entries.forEach(function(e){
					alls.push(callBack(e.value));
				});
				deep.all(alls).then(function (results) {
					self.running = false;
					nextQueueItem.apply(self, [results, null]);
				}, function (error) {
					console.error(&quot;error : deep.each : &quot;,error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		values:function  (callBack) 
		{
			var self = this;
			var func = function()
			{
				var  a = deep.chain.values(self);
				deep.when(callBack(a)).then(function (argument) {
					if(typeof argument === &quot;undefined&quot;)
						argument = a;
					self.running = false;
					if(argument instanceof Error)
						nextQueueItem.apply(self, [null, argument]);
					else
						nextQueueItem.apply(self, [argument, null]);
				}, function (error) {
					console.error(&quot;error : deep.values : &quot;,error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			
			if(callBack)
			{
				addInQueue.apply(this,[func]);
				return this;
			}
			else
				return deep.chain.values(this);
		},
		nodes:function  (callBack) 
		{
			var self = this;
			var func = function()
			{
				var  a = self._entries.concat([]);
				deep.when(callBack(a)).then(function (argument) {
					if(typeof argument === &quot;undefined&quot;)
						argument = a;
					self.running = false;
					if(argument instanceof Error)
						nextQueueItem.apply(self, [null, argument]);
					else
						nextQueueItem.apply(self, [argument, null]);
				}, function (error) {
					console.error(&quot;error : deep.nodes : &quot;,error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			if(callBack)
			{
				addInQueue.apply(this,[func]);
				return this;
			}
			else
				return deep.chain.values(this);
		},
		paths:function  (callBack) 
		{
			var self = this;
			var func = function()
			{
				var  a = deep.chain.paths(self);
				deep.when(callBack(a)).then(function (argument) {
					if(typeof argument === &quot;undefined&quot;)
						argument = a;
					self.running = false;
					if(argument instanceof Error)
						nextQueueItem.apply(self, [null, argument]);
					else
						nextQueueItem.apply(self, [argument, null]);
				}, function (error) {
					console.error(&quot;error : deep.paths : &quot;,error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			
			if(callBack)
			{
				addInQueue.apply(this,[func]);
				return this;
			}
			else
				return deep.chain.paths(this);
		},
		schemas:function  (callBack) 
		{
			var self = this;
			var func = function()
			{
				var  a = deep.chain.schemas(self);
				deep.when(callBack(a)).then(function (argument) {
					if(typeof argument === &quot;undefined&quot;)
						argument = a;
					self.running = false;
					if(argument instanceof Error)
						nextQueueItem.apply(self, [null, argument]);
					else
						nextQueueItem.apply(self, [argument, null]);
				}, function (error) {
					console.error(&quot;error : deep.schemas : &quot;,error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			
			if(callBack)
			{
				addInQueue.apply(this,[func]);
				return this;
			}
			else
				return deep.chain.schemas(this);
		},
		&#x2F;&#x2F;___________________________________________________________ WAIT

		delay:function (ms) 
		{
			var self = this;
			function func(){
				return function(s,e){
					&#x2F;&#x2F;console.log(&quot;deep.delay : &quot;, ms)
					setTimeout(function () {
						console.log(&quot;deep.delay.end : &quot;, ms)
						self.running = false;
						nextQueueItem.apply(self, [s, null]);
					}, ms);
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},

		
		&#x2F;&#x2F;____________________________________________________________________  LOAD

		deepLoad:function() 
		{
			var self = this;
			function func(){
				return function(s,e){
					var  paths = [];
					var  promises = [];
					&#x2F;&#x2F;console.log(&quot;deepLoad : &quot;, self)
					self._entries.forEach(function (e) {
						var strings = self.querier.query(e, &quot;.&#x2F;&#x2F;?or(_schema.type=string,_schema.type=function)&quot;, {resultType:&quot;full&quot;});
						strings.forEach(function (toLoad) {
							if(!toLoad.ancestor)
								throw new Error(&quot;you couldn&#x27;t interpret root itself.&quot;);
							&#x2F;&#x2F;console.log(&quot;deep.deepLoad : toLoad : &quot;, toLoad);
							if(typeof toLoad.value === &#x27;function&#x27;)
								promises.push(toLoad.value())
							else
								promises.push(deep.request.retrieve(toLoad.value, {root:self._root.value, basePath:toLoad.path, acceptQueryThis:true }));
							paths.push(toLoad);
						})
					})
					deep.all(promises).then(
					function (results) {
						var count = 0;
						results.forEach(function  (r) {
							var e = paths[count++];
							if(e.ancestor)
								e.ancestor.value[e.key] = e.value = r;
						})
						self.running = false;
						nextQueueItem.apply(self, [ results, null ]);
					},
					function (error) {
						console.error(&quot;error : deep.deepLoad : &quot;, error);
						self.running = false;
						nextQueueItem.apply(self, [ null, error ]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		load:function (request) 
		{
			var self = this;
			function func(){
				return function(){
					var  paths = [];
					var  promises = [];
					&#x2F;&#x2F;console.log(&quot;deep.load : &quot;, deep.chain.stringify(self))
					&#x2F;&#x2F;console.log(&quot;deep.load : entries : &quot;, self.entries)
					if(request)
						promises.push(deep.request.retrieve(request, { callFunctions:true }));
					else
						self._entries.forEach(function (e) {
							if(!e.value)
								return;
							if(e.value.load)
								promises.push(callFunctionFromValue(e, &quot;load&quot;));
							else if(typeof e.value === &#x27;string&#x27;)
								promises.push(deep.request.retrieve(e.value, { root:self._root.value, basePath:e.path, callFunctions:true, acceptQueryThis:true }));
							else
								promises.push(e.value);
							paths.push(e);
						})
					deep.all(promises).then(
					function (results) {
						&#x2F;&#x2F;console.log(&quot;deep.load results : &quot;, results)
						var count = 0;
						if(request)
						{
							&#x2F;&#x2F;console.log(&quot;deep.load results from request : &quot;, self._entries)
							self._entries.forEach(function (entry) {
								if(!entry.ancestor)
									&#x2F;&#x2F;throw new Error(&quot;You couldn&#x27;t interpret root !&quot;);
										entry.value = results[0];
									else
										entry.value = entry.ancestor.value[entry.key] = results[0];
							})
						}
						else
							results.forEach(function  (r) {
								&#x2F;&#x2F;console.log(&quot;deep.load results from inner : &quot;, r)
								var item = paths[count++];
								if(!item.value.load)
								{
									if(!item.ancestor)
									&#x2F;&#x2F;throw new Error(&quot;You couldn&#x27;t interpret root !&quot;);
										item.value = r;
									else
										item.value = item.ancestor.value[item.key] = r;
								}
							})
						self.running = false;
						nextQueueItem.apply(self, [results, null]);
					},
					function (error) {
						console.error(&quot;deep.load errors : &quot;, error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},

		&#x2F;&#x2F;________________________________________________________________________ INTERPET STRINGS

		deepInterpret:function(context) 
		{
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(context))
				.done(function (context) 
				{
					var res = [];
					self._entries.forEach(function (e) {
						var strings = self.querier.query(e, &quot;.&#x2F;&#x2F;?_schema.type=string&quot;, {resultType:&quot;full&quot;});
						strings.forEach(function (interpretable) {
							var r = deep.interpret(interpretable.value, context);
							res.push(r);
							if(!interpretable.ancestor)
								&#x2F;&#x2F;throw new Error(&quot;You couldn&#x27;t interpret root !&quot;);
								interpretable.value = r;
							else
								interpretable.ancestor.value[interpretable.key] = interpretable.value = r;
						})
					});
					self.running = false;
					nextQueueItem.apply(self, [res, null]);
				}) 
				.fail(function (error) 
				{
					console.error(&quot;error : deep.deepInterpret : &quot;, error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			
			addInQueue.apply(this,[func]);
			return this;
		},
		interpret:function(context) 
		{
			var self = this;
			var func = function(){
				deep.when(deep.request.retrieve(context)).then(function (context) {
					var res = [];
					self._entries.forEach(function (interpretable) 
					{
						var r = deep.interpret(interpretable.value, context);
						res.push(r);
						if(!interpretable.ancestor)
							&#x2F;&#x2F;	throw new Error(&quot;You couldn&#x27;t interpret root !&quot;);
							interpretable.value = r;
						else
							interpretable.ancestor.value[interpretable.key] = interpretable.value = r;
					});
					self.running = false;
					nextQueueItem.apply(self, [res, null]);
				}, function (error) {
					console.error(&quot;error : deep.interpret : &quot;, error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			}
			
			addInQueue.apply(this,[func]);
			return this;
		},

		&#x2F;&#x2F;________________________________________________________ PUSH TO

		pushHandlerTo:function(array) 
		{
			var self = this;
			function func(){
				var f = function()
				{
					&#x2F;&#x2F; console.log(&quot;pushHandlerTo : init? &quot;, self.initialised)
					array.push(self);
					if(self.initialised)
					{
						self.running = false;
						nextQueueItem.apply(self, [self, null]);
					}
				}
				f._isPUSH_HANDLER_TO_ = true;
				return f;
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		pushNodesTo:function(array) 
		{
			var self = this;
			function func(){
				return function(){
					var res = [];
					self._entries.forEach(function (e) {
						array.push(e);
						res.push(e);
					})
					self.running = false;
					nextQueueItem.apply(self, [res, null]);
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		pushValuesTo:function(array) 
		{
			var self = this;
			function func(){
				return function(){
					var res = [];
					self._entries.forEach(function (e) {
						array.push(e.value);
						res.push(e.value);
					})
					self.running = false;
					nextQueueItem.apply(self, [res, null]);
				}
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		pushPathsTo:function(array) 
		{
			var self = this;
			var func =function(){
				var res = [];
				self._entries.forEach(function (e) {
					array.push(e.path);
					res.push(e.path);
				})
				self.running = false;
				nextQueueItem.apply(self, [res, null]);
			}
			addInQueue.apply(this,[func]);
			return this;
		},
		pushSchemasTo:function(array) 
		{
			var self = this;
			var func = function(){
				var res = [];
				self._entries.forEach(function (e) {
					array.push(e.schema);
					res.push(e.schema);
				})
				self.running = false;
				nextQueueItem.apply(self, [res, null]);
			}
			addInQueue.apply(this,[func]);
			return this;
		},

		&#x2F;&#x2F;____________________________________________________   IF familly

		rejectIf : function(totest)
		{
			var self = this;
			function func(){
				return function(){
					if(typeof totest === &#x27;function&#x27;)
						deep.when(totest()).then(function (res) {
							if(res)
								self.reject(res);
							else
							{
								self.running = false;
								nextQueueItem.apply(self, [res, null]);
							}
						})
					else if(totest)
						self.reject(totest);
					else
					{
						self.running = false;
						nextQueueItem.apply(self, [totest, null]);
					}	
				}
			}
			addInQueue.apply(this,[func()]);
			return self;
		},
		
		cancelIf : function(totest)
		{
			var self = this;
			function func(){
				return function(){
					if(typeof totest === &#x27;function&#x27;)
						deep.when(totest()).then(function (res) {
							if(res)
								self.cancel(res);
							else
							{
								self.running = false;
								nextQueueItem.apply(self, [res, null]);
							}
						})
					else if(totest)
						self.cancel(totest);
					else
					{
						self.running = false;
						nextQueueItem.apply(self, [totest, null]);
					}	
				}
			}
			addInQueue.apply(this,[func()]);
			return self;
		},

		&#x2F;&#x2F;__________________________________________________________

		newHandler:function (options) {
			return new DeepHandler(options);
		}
	}
&#x2F;**
deep : just say : Powaaaaaa ;)

@module deep
**&#x2F;
	var deep = function(broot, schema)
	{
		var handler = new DeepHandler({path:&quot;&#x2F;!&quot;});
		handler.running = true;
		var alls = [DeepRequest.retrieve(broot)];

		if(schema)
			alls.push(DeepRequest.retrieve(schema));

		  &#x2F;&#x2F; console.log(&quot;deep(root) init : &quot;, alls);

		deep.all(alls).then(function (results) {
			  &#x2F;&#x2F;console.log(&quot;deep(root) : loaded : &quot;,  results)
			handler.initialised = true;
			var root = results[0];
			var schema = results[1];
			if(typeof root === &#x27;object&#x27; &amp;&amp; root._isDQ_NODE_)
			{
				&#x2F;&#x2F; console.log(&quot;deep(..) with DQNode : &quot;, root)
				handler._root = root.root;
				handler._entries = [root];	
				handler.queries = [root.path];
			}
			else if(typeof root === &#x27;object&#x27; &amp;&amp; root._deep_entry)
			{
				 &#x2F;&#x2F; console.log(&quot;deep(..) with _deep_entry&quot;)
				handler._root = root._deep_entry;
				handler._entries = [root._deep_entry];	
				handler.queries = [root._deep_entry.path];
			}
			else if(broot instanceof DeepHandler)
			{
				 &#x2F;&#x2F; console.log(&quot;deep(..) with DeepHandler&quot;);
				handler._entries = utils.copyArray(broot._entries)	
				handler._root = broot._root;
				handler.queries = utils.copyArray(broot.queries);
			}
			else
			{
				&#x2F;&#x2F; console.log(&quot;deep(..) simple object&quot;)
				handler._root = Querier.createRootNode(root, schema);
				handler._entries = [handler._root];	
				handler.queries = [&quot;&#x2F;!&quot;];
				if(typeof root === &#x27;object&#x27; &amp;&amp; root.uri)
					handler.name = root.uri;
				else
					handler.name = &quot;untitled&quot;;
			}
			&#x2F;&#x2F; console.log(&quot;chain will run next item&quot;);
			handler.running = false;
			nextQueueItem.apply(handler, [handler._entries[0].value, null]);
		}, function (error) {
			console.log(&quot;deep start chain error : &quot;, error);
			handler.running = false;
			nextQueueItem.apply(handler, [null, error]);
		});		
		return handler;
	}
	deep.Handler = DeepHandler;
	deep.metaSchema = {};
	deep.request = DeepRequest;
	deep.utils = utils;
	deep.validate = Validator.validate;
	deep.partialValidation = Validator.partialValidation;
	deep.compose = deepCompose;
	deep.chain = {
		nextQueueItem:nextQueueItem,
		addInQueue:addInQueue,
		stringify:function (handler, options) 
		{
			options = options || {};
			var res = &quot;&quot;;
			handler._entries.forEach(function (e) {
				if(options.pretty)
					res += JSON.stringify(e.value, null, &#x27; &#x27;)+&quot;\n&quot;;
				else
					res += JSON.stringify(e.value)+&quot;\n&quot;;
			});
			return res;
		},
		values:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.value);
			});
			return res;
		},
		nodes:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e);
			});
			return res;
		},
		paths:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.paths);
			});
			return res;
		},
		schemas:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.schema);
			});
			return res;
		}
	}

	function createHandler(arg)
	{
		var handler = new DeepHandler({path:&quot;&#x2F;!&quot;});
		handler._entries = handler.querier.query(arg, &quot;&#x2F;!&quot;, {resultType:&quot;full&quot;, schema:{}});	
		handler.queries = [&quot;&#x2F;!&quot;];
		if(arg &amp;&amp; arg.uri)
			handler.name = arg.uri;
		else
			handler.name = &quot;untitled&quot;;
		handler._root = handler._entries[0];
	&#x2F;&#x2F;	console.log(&quot;handler created : root : &quot;, handler._root)
		nextQueueItem.apply(handler, [handler._root.value, null]);
		return handler;
	}

	var DeepDeferred = function () 
	{
		&#x2F;&#x2F; console.log(&quot;new deep deferred&quot;)
		this.context = deep.context;
		this.running = true;
		this.queue = [];
		this.promise = new DeepPromise(this);
	}

	DeepDeferred.prototype = {
		context:null,
		promise:null,
		rejected:false,
		resolved:false,
		canceled:false,
		result:null,
		failure:null,
		resolve:function (argument) 
		{
			&#x2F;&#x2F;console.log(&quot;DeepDeferred.resolve&quot;);
			if(this.rejected || this.resolved || this.canceled)
				throw new Error(&quot;DeepDeferred (resolve) has already been resolved !&quot;);
			this.promise.result = this.result =  argument;
			this.resolved = this.promise.resolved = true;
			this.promise.running = false;
			nextPromiseHandler.apply(this.promise, [argument, null]);
		},
		reject:function (argument) 
		{
			&#x2F;&#x2F;console.log(&quot;DeepDeferred.reject&quot;);
			if(this.rejected || this.resolved || this.canceled)
				throw new Error(&quot;DeepDeferred (reject) has already been rejected !&quot;);
			this.promise.failure = this.failure = argument;
			this.rejected = this.promise.rejected = true;
			this.promise.running = false;
			nextPromiseHandler.apply(this.promise, [null, argument]);
		},
		cancel:function (argument) 
		{
			&#x2F;&#x2F; console.log(&quot;DeepDeferred.cancel&quot;);
			if(this.rejected || this.resolved || this.canceled)
				throw new Error(&quot;DeepDeferred (cancel) has already been canceled !&quot;);
			this.canceled = this.promise.canceled = true;
			this.promise.queue = [];
		},
		then:function (sc,ec) {
			this.promise.then(s,e);
		},
		done:function (argument) {
			this.promise.done(argument);
		},
		fail:function (argument) {
			this.promise.fail(argument);
		}
	}
	var DeepPromise = function (deferred) 
	{
		this.running = true;
		if(deferred)
		{
			this.context = deferred.context;
			this.queue = deferred.queue;
		}	
		else
		{
			this.context = deep.context;
			this.queue = [];
		}
			
	}
	DeepPromise.prototype = {
		rejected:false,
		resolved:false,
		canceled:false,
		synch:false,
		result:null,
		failure:null,
		done:function (callBack) 
		{
			&#x2F;&#x2F;console.log(&quot;add done in defInterface : &quot;, this.rejected, this.resolved, this.running)
			var self = this;
			var	func = function(s,e)
			{
				&#x2F;&#x2F;console.log(&quot;deep.chain.done : &quot;,s,e)
				if(e || !callBack)
				{
					self.running = false;
					nextPromiseHandler.apply(self, [s, e]);
					return;
				}
				var r = callBack(s);
				if(r &amp;&amp; (r instanceof DeepHandler || r._isBRANCHES_))
					r = deep.promise(r);
				if(r &amp;&amp; typeof r.then === &#x27;function&#x27;)
					r.done(function (argument) {
						if(typeof argument === &#x27;undefined&#x27;)
							argument = s;
						self.running = false;
						nextPromiseHandler.apply(self, [argument, null]);
					})
					.fail(function (error) {
						self.running = false;
						nextPromiseHandler.apply(self, [null, error]);
					});
				else if(typeof r === &#x27;undefined&#x27;)
				{
					self.running = false;
					nextPromiseHandler.apply(self, [s, e]);
				}
				else if(r instanceof Error)
				{
					self.running = false;
					nextPromiseHandler.apply(self, [null, r]);
				}
				else
				{
					self.running = false;
					nextPromiseHandler.apply(self, [r, null]);
				}
			}
			this.queue.push(func);
			if((this.resolved || this.rejected) &amp;&amp; !this.running)
				nextPromiseHandler.apply(this);
			return self;
		},
		fail:function (callBack)
		{
			var self = this;
			&#x2F;&#x2F;console.log(&quot;add fail in defInterface&quot;)
			var func = function(s,e)
			{
				&#x2F;&#x2F;console.log(&quot;deep.chain.fail : &quot;,s,e)
				if((e == null || typeof e === &#x27;undefined&#x27;) || !callBack)
				{
					self.running = false;
					nextPromiseHandler.apply(self, [s, null]);
					return;
				}
				var r = callBack(e);
				if(r &amp;&amp; (r instanceof DeepHandler || r._isBRANCHES_))
					r = deep.when(r);
				if(r &amp;&amp; typeof r.then === &#x27;function&#x27;)
					r.done(function (argument) 
					{
						if(typeof argument === &#x27;undefined&#x27;)
						{
							self.running = false;
							nextPromiseHandler.apply(self, [null, e]);
						}
						else
						{
							self.running = false;
							nextPromiseHandler.apply(self, [argument, null]);
						}
						
					})
					.fail(function (error) {
						self.running = false;
						nextPromiseHandler.apply(self, [null, error]);
					});
				else if(typeof r === &#x27;undefined&#x27;)
				{
					self.running = false;
					nextPromiseHandler.apply(self, [null, e]);
				}
				else if(r instanceof Error)
				{
					self.running = false;
					nextPromiseHandler.apply(self, [null, r]);
				}
				else
				{
					self.running = false;
					nextPromiseHandler.apply(self, [r, null]);
				}
			}
			this.queue.push(func);
			if((this.resolved || this.rejected) &amp;&amp; !this.running)
				nextPromiseHandler.apply(this);
			return self;
		},
		then:function (successCallBack, errorCallBack) 
		{
			var self = this;
			if(successCallBack)
				this.done(successCallBack);
			if(errorCallBack)
				this.fail(errorCallBack);
			if((this.resolved || this.rejected)  &amp;&amp; !this.running)
				nextPromiseHandler.apply(this);
			return self;
		}
	}
	function nextPromiseHandler(result, failure )
	{
		&#x2F;&#x2F;console.log(&quot;nextPromiseHandler &quot;, this.running, &quot; - &quot;, this.queue, result, failure);
		if(this.running)
			return;
		this.running = true;
		var self = this;
		if((typeof failure === &#x27;undefined&#x27; || failure == null) &amp;&amp; (typeof result === &#x27;undefined&#x27; || result == null))
		{
			failure = this.failure;
			result = this.result;
		}
		else
		{
			this.failure = failure;
			this.result = result;
		}

		if(this.result instanceof Error)
		{
			this.failure = result;
			this.result = null;
		}
		if(this.queue.length&gt;0)
		{
			try{
				var previousContext = deep.context;
				if(previousContext !== this.context)
				{
					if(previousContext &amp;&amp; previousContext.suspend)
						previousContext.suspend();
					deep.context = this.context;
					if(this.context &amp;&amp; this.context.resume)
						this.context.resume();
				}

				&#x2F;&#x2F;console.log(&quot;newQueueThen . will try next item : &quot;,this.queue, result, failure)
				var next = this.queue.shift();
				next(result,failure);
			}
			catch(e)
			{
				var msg = &quot;Internal deep.promise error : &quot;;
				console.error(msg, e);
				if(deep.rethrow)
					throw e;
				setTimeout(function(){
					self.running = false;
					nextPromiseHandler.apply(self, [null, e]);
				}, 1);
			}
			finally{
				if(previousContext !== this.context){
					if(this.context &amp;&amp; this.context.suspend){
						this.context.suspend();
					}
					if(previousContext &amp;&amp; previousContext.resume){
						previousContext.resume();
					}
					deep.context = previousContext;
				}
			}
		}
		else
		{
			&#x2F;&#x2F;console.log(&quot;stopping run&quot;);
			this.running = false;
		}	
	}
	function createImmediatePromise(result)
	{
		&#x2F;&#x2F;console.log(&quot;deep.createImmediatePromise : &quot;, result)
		var prom = new DeepPromise();
		prom.resolved = true;
		prom.running = false;
		if(result instanceof Error)
			prom.failure = result;
		else
			prom.result = result;
		return prom;
	}

	deep.promise = function(arg)
	{
		&#x2F;&#x2F;console.log(&quot;deep.promise : &quot;, arg)
		if(typeof arg === &quot;undefined&quot; || arg == null)
			return createImmediatePromise(arg);
		if(arg._isBRANCHES_)		&#x2F;&#x2F; chain.branches case
			return deep.all(arg.branches);
		if(arg instanceof DeepHandler)
		{
			&#x2F;&#x2F;console.log(&quot;DEEP promise with deephandler&quot;, arg.running);
			if(arg.rejected)
				throw new Error(&quot;error : deep.promise : DeepHandler has already been rejected.&quot;);
			
			if(arg.running) &#x2F;&#x2F; need to wait rejection or success
			{
				var def = deep.Deferred();
				arg.done(function (success) { &#x2F;&#x2F; simply chain done handler in deep chain
					&#x2F;&#x2F;console.log(&quot;deep.promise of DeepHandler : added then&quot;)
					if(success &amp;&amp; success.then)
						deep.when(success).then(function (success) {
							if(success instanceof Error)
							{
								def.reject(success);
								return;
							}
							def.resolve(success);
						}, function (error) {
							def.reject(error);
						})
					else
						def.resolve(success);
				})
				arg.deferred.fail(function (error) {  &#x2F;&#x2F; register rejection on deep chain deferred.
					&#x2F;&#x2F;console.log(&quot;deep.promise of DeepHandler : added error&quot;)
					def.reject(error);
				})
				return def.promise;
			}
			return arg; &#x2F;&#x2F; nothing to wait : chain will act as immediate promise
		}
		if(typeof arg.promise === &quot;function&quot; )  &#x2F;&#x2F; jquery deferred case
			return arg.promise();
		if(arg.promise)			&#x2F;&#x2F; deep and promised-io deferred case
			return arg.promise;
		if(typeof arg.then === &#x27;function&#x27;)		&#x2F;&#x2F;any promise compliant object
			return arg;
		return createImmediatePromise(arg);
	};

	deep.when = function (arg) 
	{
		&#x2F;&#x2F; console.log(&quot;deep.when : &quot;, arg)
		if(arg instanceof DeepHandler)
			return deep.promise(arg);
		if(arg &amp;&amp; typeof arg.then === &#x27;function&#x27;)
			return arg;
		return deep.promise(arg);
	};

	deep.all = function(arr)
	{
		if(arr.length == 0)
			return deep.when([]);
		var def = deep.Deferred();
		var count = arr.length;
		var c = 0, d = -1;
		var res = [];
		arr.forEach(function (a){
			var i = d +1;
			deep.when(a).then(function(r){
				if(r instanceof Error)
				{
					def.reject(r);
					return;
				}

				res[i] = r;
				c++;
				if(c == count)
					def.resolve(res);
			}, function (error){
				def.reject(error);
			})
			d++;
		})
		return deep.promise(def);
	};

	promise.when = deep.when;
	promise.promise = deep.promise;
	promise.all = deep.all;
	deep.Deferred = promise.Deferred = function (){
		return new DeepDeferred();
	}
	deep.metaSchema = {};
	deep.isNode = (typeof process !== &#x27;undefined&#x27; &amp;&amp; process.versions &amp;&amp; process.versions.node);
	deep.rql = require(&quot;deep&#x2F;deep-rql&quot;);
	deep.query = Querier.query;
	deep.collider = require(&quot;deep&#x2F;deep-collider&quot;);

	deep.interpret = utils.interpret;

	deep.context = null;

	deep.chain.error = function (argument) {
		var f = function (argument) {
			&#x2F;&#x2F; body...
		}
	}

	deep.sequence = function (funcs, args) 
	{
		if(!funcs || funcs.length == 0)
			return args;
		var current = funcs.shift();
		var def = deep.Deferred();
		var context = {};
		var doIt = function (r) {
			deep.when(r).then(function (r) 
			{
				&#x2F;&#x2F;console.log(&quot;deep.sequence : doIt.when : r : &quot;, r)
				if(funcs.length == 0)
				{
					if(typeof r === &#x27;undefined&#x27;)
					{
						r = args;
						if(args.length == 1)
							r = args[0];
					}	
					&#x2F;&#x2F;console.log(&quot;deep.sequence. resolve because funcs.length == 0 : &quot;, r)
					def.resolve(r);
					return r;
				}
				if(typeof r === &#x27;undefined&#x27;)
					r = args;
				else
					r = [r];
				current = funcs.shift();
				doIt(current.apply(context, r));
			}, function (error) {
				def.reject(error);
			});
		}
		doIt(current.apply(context, args));
		return deep.promise(def);
	}


	&#x2F;&#x2F; console.log(&quot;Deep initialisaed&quot;);

	deep.rethrow = true;
	return deep;

	&#x2F;&#x2F;______________________________________________________________________________________________________________________________________
})

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
