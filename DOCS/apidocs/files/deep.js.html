<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>deep.js - deepjs Javascript Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="deepjs Javascript Framework"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.rc</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/deep.html">deep</a></li>
            
                <li><a href="../classes/deep.Chain.html">deep.Chain</a></li>
            
                <li><a href="../classes/deep.collider.html">deep.collider</a></li>
            
                <li><a href="../classes/deep.collider.array.html">deep.collider.array</a></li>
            
                <li><a href="../classes/deep.collider.assert.html">deep.collider.assert</a></li>
            
                <li><a href="../classes/deep.collider.object.html">deep.collider.object</a></li>
            
                <li><a href="../classes/deep.compose.html">deep.compose</a></li>
            
                <li><a href="../classes/deep.Composer.html">deep.Composer</a></li>
            
                <li><a href="../classes/deep.deep.html">deep.deep</a></li>
            
                <li><a href="../classes/deep.Deferred.html">deep.Deferred</a></li>
            
                <li><a href="../classes/deep.Promise.html">deep.Promise</a></li>
            
                <li><a href="../classes/deep.Query.html">deep.Query</a></li>
            
                <li><a href="../classes/deep.Role.html">deep.Role</a></li>
            
                <li><a href="../classes/deep.roles.html">deep.roles</a></li>
            
                <li><a href="../classes/deep.store.html">deep.store</a></li>
            
                <li><a href="../classes/deep.store.Array.html">deep.store.Array</a></li>
            
                <li><a href="../classes/deep.store.Object.html">deep.store.Object</a></li>
            
                <li><a href="../classes/deep.store.Store.html">deep.store.Store</a></li>
            
                <li><a href="../classes/deep.stores.html">deep.stores</a></li>
            
                <li><a href="../classes/deep.stores.aspect.html">deep.stores.aspect</a></li>
            
                <li><a href="../classes/deep.stores.instance.html">deep.stores.instance</a></li>
            
                <li><a href="../classes/deep.stores.js.html">deep.stores.js</a></li>
            
                <li><a href="../classes/deep.stores.queryThis.html">deep.stores.queryThis</a></li>
            
                <li><a href="../classes/deep.utils.html">deep.utils</a></li>
            
                <li><a href="../classes/deep.Validator.html">deep.Validator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/deep.html">deep</a></li>
            
                <li><a href="../modules/deep-collider.html">deep-collider</a></li>
            
                <li><a href="../modules/deep-compose.html">deep-compose</a></li>
            
                <li><a href="../modules/deep-query.html">deep-query</a></li>
            
                <li><a href="../modules/deep-roles.html">deep-roles</a></li>
            
                <li><a href="../modules/deep-rql.html">deep-rql</a></li>
            
                <li><a href="../modules/deep-schema.html">deep-schema</a></li>
            
                <li><a href="../modules/deep-stores.html">deep-stores</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: deep.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**
 * @author Gilles Coomans &lt;gilles.coomans@gmail.com&gt;
*/
/*
ADDITIONAL CHAIN METHODS

.enableLog()
.disableLog()

.condition(...)
.conditionEnd(...)

.sort(...)

logNodes
logPaths

Queries : 
options:
	deepest
	nearest
	readius
	deepness

TODO : 

	faire que chaque handle retourne une array s,e OU un truc Ã  attendre (chains, branches, promises, deferreds)
	
	deep.chain.manageCallBack(whatToWait, whatIfCallBackReturnIsUndefined, title)

	deep.flags for console and debug

	deep.settings

	deep.mode

	deep.debug (other mode/flags)


BUG !!! : 

	- when using delay : it set a timeout which will catch any error and for now will reinjecting in chain : that&#x27;s incoherent.
	 It&#x27;s there because when you use time out : any thrown error under it are lost in space. 

	Solution : add a rethrow function from the chain that 

	

*/

if(typeof define !== &#x27;function&#x27;)
	var define = require(&#x27;amdefine&#x27;)(module);


define([&quot;require&quot;,&quot;./utils&quot;, &#x27;./ie-hacks&#x27;,&quot;./deep-rql&quot;,&quot;./deep-request&quot;, &quot;./deep-schema&quot;,  &quot;./promise&quot;, &quot;./deep-query&quot;, &quot;./deep-compose&quot;, &quot;./deep-stores&quot;, &quot;./deep-promise&quot;],
function(require)
{
	// console.log(&quot;Deep init&quot;);
	if(!console.warn)
		console.warn = console.log;
	if(!console.error)
		console.error = console.log;
	if(!console.info)
		console.info = console.log;

	var Validator = require(&quot;./deep-schema&quot;);
	var DeepRequest = require(&quot;./deep-request&quot;);
	var utils = require(&quot;./utils&quot;);
	var Querier = require(&quot;./deep-query&quot;);
	var deepCompose = require(&quot;./deep-compose&quot;);

	//________________________________________________________ DEEP Module

	/**
	 * deep : just say : Powaaaaaa ;)
	 * @module deep
	 */

	/**
	 * Start of deep chain
	 *
	 * @example
	 * 		deep(&quot;./json/simple.json&quot;).logValues(&quot;simple.json : &quot;);
	 *
	 * 
	 * @class deep
	 * @constructor
	 * @param  {Object} obj an object (or retrievable string) or an array of objects to start chain. will wait if there is promise
	 * @param  {Object} schema (optional) a schema for entries. could be a retrievable
	 * @param  {Object} options (optional) an option object. could contain : rethrow:true|false
	 * @return {deep.Chain} a deep handler that hold object(s)
	 */
	deep = function (obj, schema, options)
	{
		if(typeof obj === &#x27;undefined&#x27;)
			obj = null;
		if(obj &amp;&amp; obj._deep_chain_ &amp;&amp; obj.oldQueue)
			return obj;
		var alls = [];
		var root = obj;
		//console.log(&quot;start chain : &quot;, obj )
		try
		{
			var handler = new deep.Chain(options);
			handler.running = true;
			if(obj instanceof Array)
				alls.push(deep.all(obj));
			else if(typeof obj === &#x27;string&#x27;)
				alls.push(deep.get(obj));
			else
				alls.push(obj);
			if(typeof schema === &#x27;string&#x27;)
				alls.push(deep.get(schema));
			else if(schema)
				alls.push(schema);
			deep.all(alls)
			.done(function (results) {
				//console.log(&quot;start chain : when result :&quot;)
				handler.initialised = true;
				obj = results.shift();
				if(schema)
					schema = results.shift();
				if(obj instanceof Array)
				{
					if(schema &amp;&amp; schema.type !== &quot;array&quot;)
						schema = { type:&quot;array&quot;, items:schema };
					handler._entries = deep.query(obj, &quot;./*&quot;, { resultType:&quot;full&quot;, schema:schema });
					return forceNextQueueItem(handler, deep.chain.values(handler), null);
				}
				else if(obj &amp;&amp; obj._isDQ_NODE_)
					handler._entries = [obj];
				else if(obj &amp;&amp; obj._deep_entry)
					handler._entries = [obj._deep_entry];
				else
					handler._entries = [Querier.createRootNode(obj, schema)];
				if(handler._entries.length &gt; 1)
					forceNextQueueItem(handler, deep.chain.values(handler), null);
				else
					forceNextQueueItem(handler, deep.chain.val(handler), null);
			})
			.fail(function (error) {
				//console.log(&quot;deep start chain error on load object : &quot;, error, &quot; - rethrow ? &quot;, handler.rethrow);
				handler.initialised = true;
				forceNextQueueItem(handler, null, error);
			});
		}
		catch(e)
		{
			handler.initialised = true;
			//console.log(&quot;deep start chain : throw when waiting entries : rethrow : &quot;,handler.rethrow);
			if(handler.rethrow)
				throw e;
			else
				forceNextQueueItem(handler, null, e);
		}
		return handler;
	};
	/**
	 * rethrow any throw during chain execution.
	 * @property rethrow  
	 * @static
	 * @type {Boolean}
	 */
	deep.rethrow = true;
	deep.metaSchema = {};
	/**
	 * final namespace for deep/utils
	 * @static
	 * @property utils
	 * @type {Object}
	 */
	deep.utils = utils;
	/**
	 * the deep schema validator
	 * @static
	 * @property Validator
	 */
	deep.Validator = Validator;
	/**
	 * perform a deep-schema validation
	 * @static
	 * @method validate
	 * @param object the object to validate
	 * @param schema the schema 
	 * @return {deep.validate.Report} the validation report
	 */
	deep.validate = Validator.validate;
	/**
	 * perform a deep-schema partial validation (only on certain field)
	 * @static
	 * @method partialValidation
	 * @param object the object to validate
	 * @param fields the array of properties paths to validate
	 * @param schema the schema 
	 * @return {deep.validate.Report} the validation report
	 */
	deep.partialValidation = Validator.partialValidation;
	/**
	 * final namespace for deep/deep-compose
	 * @static
	 * @property compose
	 * @type {Object}
	 */
	deep.compose = deepCompose;
	/**
	 * are you on nodejs or not
	 * @static
	 * @property isNode
	 * @type {Boolean}
	 */
	deep.isNode = (typeof process !== &#x27;undefined&#x27; &amp;&amp; process.versions &amp;&amp; process.versions.node);
	/**
	 * perform a (synched) deep-rql filter on array
	 * @example
	 * 
	 * 		deep.rql([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;=a&quot;); // return  [&quot;a&quot;]
	 * 		
	 * @static
	 * @method rql
	 * @param {Array} array  the array to filter
	 * @param {String} rqlFilter the rql filter to apply
	 * @return {Array} the result aray
	 */
	deep.rql = require(&quot;./deep-rql&quot;).query;
	/**
	 * perform a (synched) deep-query query
	 * @example 
	 *
	 * 		deep.query({ hello:&quot;world&quot;, test:1 }, &quot;/*?=world&quot;); // will return [&quot;world&quot;]
	 * 
	 * @method query
	 * @param {Object} object any object to query
	 * @param {String} query the query
	 * @static
	 * @return {Array} the result aray
	 */
	deep.query = Querier.query;
	/**
	 * final namespace for deep/deep-collider 
	 * @static
	 * @property collider
	 * @type {Object}
	 */
	deep.collider = require(&quot;./deep-collider&quot;);
	/**
	 * final namespace for deep/deep-query
	 * @static
	 * @property Querier
	 * @type {DeepQuery}
	 */
	deep.Querier = Querier;
	/**
	 * shortcut for utils.interpret
	 * @static
	 * @method interpret
	 * @param {String} string the string to interpret
	 * @param {Object} context the context injected for interpretation
	 * @return {String} the result
	 */
	deep.interpret = utils.interpret;
	deep.context = {};
	deep.request = DeepRequest;

	//_____________________________________________________________________ local (private) functions

	function callFunctionFromValue(entry, functionName, args)
	{
		if(typeof args === &#x27;undefined&#x27;)
			args = [];
		else if(!(args instanceof Array))
			args = [args];
		var prom;
		if(entry.value &amp;&amp; entry.value[functionName])
		{
			entry.value._deep_entry = entry;
			prom = entry.value[functionName].apply(entry.value, args);
			if(prom &amp;&amp; prom.then)
				prom.then(function () {
					delete entry.value._deep_entry;
				},
				function () {
					delete entry.value._deep_entry;
				});
			else
				delete entry.value._deep_entry;
			return prom;
		}
		return prom;
	}
	function runFunctionFromValue(entry, func, args)
	{
		//console.log(&quot;runFunctionFromValue&quot;, entry)
		if(typeof args === &#x27;undefined&#x27;)
			args = [];
		else if(!(args instanceof Array))
			args = [args];

		if(!entry.value)
			return undefined;
		entry.value._deep_entry = entry;
		var prom = func.apply(entry.value, args);
		if(prom &amp;&amp; prom.then)
			prom.then(function () {
				delete entry.value._deep_entry;
			},
			function () {
				delete entry.value._deep_entry;
			});
		else
			delete entry.value._deep_entry;
		return prom;
	}

	function nextQueueItem(result, failure )
	{
		//console.log(&quot;nextQueueItem &quot;, this.running, &quot; - &quot;, this.callQueue, result, failure);
		if(this.running)
			return;
		this.running = true;
		var self = this;
		if(result instanceof Error)
		{
			//console.log(&quot;nextChainHandler : result is error : &quot;,result);
			this.reports.failure = failure = result;
			this.reports.result = result = null;
		}
		if((typeof failure === &#x27;undefined&#x27;) &amp;&amp; (typeof result === &#x27;undefined&#x27;))
		{
			failure = this.reports.failure;
			result = this.reports.result;
		}
		else
		{
			this.reports.failure = failure;
			this.reports.result = result;
		}

		if(this.oldQueue)
		{
			this.callQueue = this.callQueue.concat(this.oldQueue);
			delete this.oldQueue;
		}

		if(this.callQueue.length&gt;0)
		{
			var next = this.callQueue.shift();
			var error = null;
			var previousContext = deep.context;
			try{
				if(previousContext !== this.context){
					if(previousContext &amp;&amp; previousContext.suspend){
						previousContext.suspend();
					}
					deep.context = this.context;
					if(this.context &amp;&amp; this.context.resume){
						this.context.resume();
					}
				}
				if(!failure || next._isTHEN_ ||  next._isTRANSPARENT_ || next._isPUSH_HANDLER_TO_)
				{
					var r = null;
					if(typeof next === &quot;object&quot;)
						r = next.func(result,failure);
					else
						r = next(result,failure);
					if(typeof r !== &#x27;undefined&#x27;)
					{
						this.running = false;
						nextQueueItem.apply(self, r)
					}
				}
				else // PASSIVE TRANSPARENCY : SKIP CURRENT handle
				{
					//console.log(&quot;chain still have error : but no more then familly handlers to manage it. check next then failly group&quot;)
					if(this._doingEnd)
					{
						this.callQueue = [];
						forceNextQueueItem(self, result, failure);
						return;
					}
					this.doingEnd = true;
					while(next &amp;&amp; !(next._isTHEN_ ||  next._isTRANSPARENT_ || next._isPUSH_HANDLER_TO_))
					{
						this.callQueue.shift();
						next = this.callQueue[0];
					}
					forceNextQueueItem(self, result, failure);
				}
			}
			catch(e)
			{
				var msg = &quot;Internal chain error : rethrow ? &quot;+ self.rethrow;
				console.error(msg, e);
				if(self.rethrow)
					throw e;
				self.running = false;
				nextQueueItem.apply(self, [null, e]);
			}
			finally{
				if(previousContext !== this.context)
				{
					if(this.context &amp;&amp; this.context.suspend){
						this.context.suspend();
					}
					if(previousContext &amp;&amp; previousContext.resume){
						previousContext.resume();
					}
					deep.context = previousContext;
				}
			}
		}
		else
		{
			this.running = false;
			if(this._listened &amp;&amp; !this.deferred.rejected &amp;&amp; !this.deferred.resolved &amp;&amp; !this.deferred.canceled)
			{
				if(failure)	
					this.reject(failure);
				else
					this.resolve(result);
			}
		}
	}
	function forceNextQueueItem(handler, s, e)
	{
		handler.running = false;
		nextQueueItem.apply(handler, [s, e]);
	}
	function addInQueue(func)
	{
		if(!this.oldQueue &amp;&amp; this._listened)
			throw new Error(&quot;you couldn&#x27;t add anymore handler to this chain : someone listening it. &quot;+JSON.stringify(deep.chain.values(this)));
		if(func._isPUSH_HANDLER_TO_ &amp;&amp; !this.initialised)
			func();
		else
			this.callQueue.push(func);
		if(!this.running)
			nextQueueItem.apply(this);
	}

	function cloneHandler(handler, cloneValues)
	{
		var newRes = [];
		if(cloneValues)
			newRes = newRes.concat(handler._entries);
		var newHandler = new deep.Chain({
			rethrow:handler.rethrow,
			_entries:newRes,
			result: handler.reports.result,
			failure: handler.reports.failure
		});
		newHandler.initialised = true;
		return newHandler;
	}

	//_________________________________________________________________________________________
	/**
	 * Deep Chain Handler  : manage asynch and synch in one chain
	 * @class Chain
	 * @namespace deep
	 * @constructor
	 * @param {Object} obj    [description]
	 * @param {Object} schema [description]
	 */
	deep.Chain = function(options)
	{
		options = options || {};
		this.rethrow = (typeof options.rethrow !== &quot;undefined&quot;)?options.rethrow:deep.rethrow;
		this._deep_chain_ = true;
		this.positions = [];
		this.context = deep.context;
		options = options || {};
		this.querier = new Querier();
		this.callQueue = [];
		this._entries = options._entries || [];
		this.queries = [];
		this.deferred = deep.Deferred();
		this.rejected=false;
		this.reports = {
			result:options.result || null,
			failure:options.failure || null
		};
	};
	//deep.Chain = deep.Chain;
	deep.Chain.prototype = {
		querier:null,
		_listened:false,
		synch:true,
		_entries:null,
		callQueue:null,
		reports:null,
		queries:null,
		/**
		 * allow to create chain branches 
		 *
		 * synch
		 * transparent : not relevant
		 * 
		 * @method  brancher
		 * @return brancher function 
		 */
		brancher:function ()
		{
			var self = this;
			var brancher = {
				branch:function () {
					if(!this.branches)
						this.branches = [];
					var cloned = cloneHandler(self, true);
					this.branches.push(cloned);
					cloned.running = false;
					//forceNextQueueItem(cloned,self.reports.result, self.reports.failure);
					return cloned;
				},
				_isBRANCHES_:true
			};
			return brancher;
		},
		/**
		 * reverse entries order
		 *
		 * inject entries values as chain success.
		 * 
		 * @chainable
		 * @method  reverse
		 * @return {deep.Chain} this
		*/
		reverse:function () {
			var self = this;
			var create =  function(s,e)
			{
				self._entries.reverse();
				self.running = false;
				nextQueueItem.apply(self, [deep.chain.values(self), null]);
			};
			addInQueue.apply(this, [create]);
			return self;
		},
		/**
		 * catch any throwned error while chain running
		 *
		 * asycnh
		 * transparent true
		 * 
		 * @method  catchError
		 * @chainable
		 * @param {boolean} catchIt if true : catch all future chain error. (true by default) 
		 * @return {deep.Chain} the chain
		*/
		catchError:function (catchIt) {
			var self = this;
			if(typeof catchIt === &#x27;undefined&#x27;)
				catchIt = true;
			var create =  function(s,e)
			{
				self.rethrow = !catchIt;
				self.running = false;
				nextQueueItem.apply(self, [s, e]);
			};
			create._isTRANSPARENT_ = true;
			addInQueue.apply(this, [create]);
			return self;
		},
		//_______________________________________________________________  CANCEL AND REJECT
		/**
		 * cancel chain. 
		 *
		 * end of chain
		 * synch
		 *
		 * @method  cancel
		 * @param  reason the reason of the chain cancelation (any string or object)
		 * @return nothing
		 */
		cancel:function (reason)  // not chainable
		{
			//console.log(&quot;_________________________________________ CHAIN CANCELATION&quot;)
			if(this.deferred.rejected || this.deferred.resolved || this.deferred.canceled)
				throw  new Error(&quot;deep chain could not be canceled : it has already been rejected! &quot;);
			var queue = this.callQueue;
			this.callQueue = [];
			this.oldQueue = null;
			this.reports.cancel = reason;
			this.deferred.cancel(reason);
		},
		/**
		 * reject chain for listeners. 
		 *
		 * end of chain
		 *
		 * @method  reject
		 * @param  {*} reason the reason of the chain rejection (any string or object - the last error of the chain)
		 * @return nothing
		 */
		reject:function (reason)  // not chainable
		{
			if(this.deferred.rejected || this.deferred.resolved || this.deferred.canceled)
				throw  new Error(&quot;deep chain REJECTION error : chain has already been ended! &quot;);
		//	console.log(&quot;deep chain reject : reason : &quot;, reason);
			this.reports.failure = reason;
			this.rejected = true;
			this.callQueue =  [];
			this.oldQueue = null;
			this.deferred.reject(reason);
		},
		/**
		 * resolve chain for listeners. 
		 *
		 * end of chain
		 *
		 * @method  resolve
		 * @param  {*} reason the last success of the chain or any string or object
		 * @return nothing
		 */
		resolve:function (reason)  // not chainable
		{
			//console.log(&quot;deep chain reslove : reason : &quot;, reason);
			if(this.deferred.rejected || this.deferred.resolved || this.deferred.canceled)
				throw  new Error(&quot;deep chain resolution error : has already been ended! : reason : &quot;, reason);
			this.reports.result = reason;
			this.resolved = true;
			this.callQueue = [];
			this.oldQueue = null;
			this.deferred.resolve(reason);
		},
		//_____________________________________________________________  BRANCHES
		/**
		 * asynch handler for chain branches creation
		 *
		 * if you return the branches function (the branch creator) : the chain will wait until all the branches are done before continuing
		 *
		 *  Inject function result in chain as success or error.
		 *
		 * 	@example
		*	chain.branches( function(branches)
		*	{
		*		branches.branch().query(...).load().log()
		*		branches.branch().query(...).post().log();
		*		//...
		*		return branches;
		*	});
		*
		*	// if you want to return a subset of branches promises : 
		*	// you could use deep.all([array_of_promises]) :
		*
		*		var branch = branches.branch().myChain()...;
		*		//...
		*		return deep.all([deep.promise(branch), ...]);
		 * 
		 * @method  branches
		 * @async
		 * @chainable
		 * @param   {Function} func the callback that will receive the brancher (see above)
		 * @return  {deep.Chain} this
		 */
		branches:function ( func )
		{
			var self = this;
			var create =  function(s,e)
			{
				self.oldQueue = self.callQueue;
				self.callQueue = [];
				var a  = func.apply(self, [self.brancher()]);
				if(a === self)
				{
					self.callQueue = self.callQueue.concat(self.oldQueue);
					delete self.oldQueue;
					return [s,e];
				}
				deep.when(a)
				.then(function (success)
				{
					self.callQueue = self.callQueue.concat(self.oldQueue);
					delete self.oldQueue;
					forceNextQueueItem(self, success, null)
				},
				function (error)
				{
					//console.error(&quot;error : deep.branches : &quot;, error);
					self.callQueue = self.callQueue.concat(self.oldQueue);
					delete self.oldQueue;
					forceNextQueueItem(self, null, error)
				});
			};
			addInQueue.apply(this, [create]);
			return self;
		},
		//______________________________________________________ PROMISE INTERFACE
		/**
		 * wait promise resolution or rejection before continuing chain
		 *
		 *	asynch
		 *	transparent false
		 * 
		 * @method  when
		 * @param  {deep.Promise} prom the promise to waiting for
		 * @chainable
		 * @return {deep.Chain}
		 */
		when:function(prom)
		{
			var self = this;
			var func = function(s,e){
				deep.when(prom).then(function (datas) {
					if(typeof datas === &#x27;undefined&#x27;)
						datas = s;
					self.running = false;
					nextQueueItem.apply(self, [datas,null]);
				}, function (e) {
					//console.error(&quot;error : deep.chain.when : &quot;, e);
					self.running = false;
					nextQueueItem.apply(self, [null,e]);
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * handle previous chain&#x27;s handle success
		 *
		 * the callback receive 3 arguments : 
		 * 		success, handler, brancher
		 *
		 * the success is the success object produced by previous chain&#x27;s handle
		 * the handler is the chain handler itself
		 * the brancher is the brancher function that create clone of the chain to produce chain branches
		 * 
		 * 
		 * @method  done
		 * @chainable
		 * @param  callback the calback function to handle success
		 * @return {deep.Chain}
		 */
		done : function(callBack)
		{
			var self = this;
			var	func = function(s,e)
			{
				//console.log(&quot;deep.chain.done : &quot;,s,e)
				if(e || !callBack || s instanceof Error)
					return [s,e];
				self.oldQueue = self.callQueue;
				self.callQueue = [];
				var a  = callBack.apply(self, [s]);
				if(a === self)
				{
					self.callQueue = self.callQueue.concat(self.oldQueue);
					delete self.oldQueue;
					return [s,e];
				}
				else
					deep.when(a).then(function (argument) {
						var error = null;
						if(typeof argument === &#x27;undefined&#x27;)
							argument = s;
						else if(argument instanceof Error)
						{
							error = argument;
							argument = null;
						}
						self.callQueue = self.callQueue.concat(self.oldQueue);
						delete self.oldQueue;
						//return [argument,error];

						forceNextQueueItem(self, argument, error);
					}, function (error) {
						self.callQueue = self.callQueue.concat(self.oldQueue);
						delete self.oldQueue;
						//return [null,error];
						forceNextQueueItem(self, null, error);
					});
			};
			func._isTHEN_ = true;
			addInQueue.apply(this, [func]);
			return self;
		},
		/**
		 * handle previous chain handle error
		 *
		 * the callback receive 3 arguments : 
		 * 		error, handler, brancher
		 *
		 * the error is the success object produced by previous chain&#x27;s handle
		 * the handler is the chain handler itself
		 * the brancher is the brancher function that create clone of the chain to produce chain branches
		 * 
		 * 
		 * @method  fail
		 * @chainable
		 * @param  callback the calback function to handle error
		 * @return {deep.Chain}
		 */
		fail:function (callBack)
		{
			var self = this;
			var func = function(s,e)
			{
				if((e === null || typeof e === &#x27;undefined&#x27;) || !callBack)
					return [s,e];
				
				self.oldQueue = self.callQueue;
				self.callQueue = [];
				var a = callBack.apply(self, [e]);
				if(a === self)
				{
					self.callQueue = self.callQueue.concat(self.oldQueue);
					delete self.oldQueue;
					return [s,e];
				}
				else
					deep.when(a).then(function (argument) {
						self.callQueue = self.callQueue.concat(self.oldQueue);
						delete self.oldQueue;
						if(typeof argument === &#x27;undefined&#x27;)
							forceNextQueueItem(self, null, e);
						else if(argument instanceof Error)
							forceNextQueueItem(self, null, argument);
						else
							forceNextQueueItem(self, argument, null);
					}, function (error) {
						self.callQueue = self.callQueue.concat(self.oldQueue);
						delete self.oldQueue;
						forceNextQueueItem(self, null, error);
					});
			};
			func._isTHEN_ = true;
			addInQueue.apply(this,[func]);
			return self;
		},
		/**
		 * handle previous chain handle success and error
		 *
		 * 	add a .done and a .fail (orderedly) in chain with callbacks.
		 * 
		 * @method  then
		 * @param  successCallBack the calback function to handle success
		 * @chainable
		 * @param  errorCallBack the calback function to handle error
		 * @return {deep.Chain} this
		 */
		then:function (successCallBack, errorCallBack)
		{
			if(successCallBack)
				this.done(successCallBack);
			if(errorCallBack)
				this.fail(errorCallBack);
			return this;
		},
		//___________________________________________________________________________ NAVIGATION
		/**
		 * perform a range on chain entries : so will remove any chain entries of of range index.
		 *
		 *	asynch
		 *
		 *
		 *  inject a rangeObject as chain success : 
		 *  	{
		 *  		start:number,
		 *  		end:number,
		 *  		total:number,
		 *  		results:Array,
		 *  		hasNext:boolean,
		 *  		hasPrevious:boolean
		 *  	}
		 * @example
	deep([0,1,2,3,4,5])
	.range(1,4)
	.valuesEqual([1,2,3,4]);

	deep([0,1,2,3,4,5])
	.range(3,5)
	.valuesEqual([3,4,5]);
		 * 
		 * @method  range
		 * @param  start the index of range start
		 * @param  end the index of range end
		 * @chainable
		 * @return {deep.Chain} this
		 */
		range : function (start, end)
		{
			var self = this;
			var func = function(s,e){
				var rangeObject = null;
				
				rangeObject = utils.createRangeObject(start, end, self._entries.length);
				self._entries = self._entries.slice(rangeObject.start, rangeObject.end+1);
				rangeObject.results = deep.chain.values(self);
				forceNextQueueItem(self, rangeObject, null);
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * save current chain position. it means that it will save
		 * 	- current entries 
		 * 	- current success and errors
		 * 	- current store (if any) in private queue before continuing.
		 * 
		 *	asynch
		 *	transparent true
		 * 
		 * @method  position
		 * @param  name the name of position (its id/label)
		 * @param  options optional object (no options for the moment)
		 * @return {deep.Chain} this
		 */
		position : function  (name, options)
		{
			var self = this;
			var func = function(s,e){
				deep.chain.position(self, name, options);
				self.running = false;
				nextQueueItem.apply(self, [s,e]);
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * go back to a previously saved position (see .position).
		 * If no name is provided : go back to last position (if any)
		 *
		 * throw an error if no position founded.
		 *
		 * inject chain values as chain success
		 * 
		 * @method  back
		 * @chainable
		 * @param  {String} name the name of the last position asked
		 * @param   {Object}	options   (optional - no options for the moment)
		 * @return {deep.Chain}
		 */
		back : function  (name, options)
		{
			var self = this;
			var func = function(s,e){
				var position = null;
				if(name)
				{
					var pos = self.positions.concat([]), ok = false;
					while(true &amp;&amp; pos.length &gt;0)
					{
						position = pos.pop();
						if(position.name == name)
						{
							ok = true;
							break;
						}
					}
					if(pos.length === 0 &amp;&amp; !ok)
						position = null;
				}
				else
					position = self.positions[self.position.length-1];
				if(!position)
					throw new Error(&quot;chain handler error : no positions to go back with name : &quot;+name);
				self._entries = position.entries;
				self._store = position.store;
				self.running = false;
				nextQueueItem.apply(self, [deep.chain.values(self),null]);
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		//_________________________________________________________________________________________

		/**
		 * keep only the first chain entries. remove all others.
		 * inject selected entry value as chain success.
		 * 
		 * @chainable
		 * @method  first
		 * @return {deep.Chain}
		 */
		first : function  ()
		{
			var self = this;
			var func = function(){
				self._entries = [self._entries[0]];
				return [self._entries, null];
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * keep only the last chain entries. remove all others
		 *
		 * inject selected entry value as chain success
		 * 
		 * @chainable
		 * @method  last
		 * @return {deep.Chain}
		 */
		last : function  ()
		{
			var self = this;
			var func = function(){
				self._entries = [self._entries[self._entries.length-1]];
				return [self._entries, null];
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * take current entries parents (if any) as new entries.
		 *
		 * inject new entries values as chain success.
		 * 
		 * asynch
		 * 
		 * @method  parents
		 * @chainable
		 * @param boolean errorIfEmpty : if true and no parents was selected : throw an error 
		 * @return {deep.Chain}
		 */
		parents : function (errorIfEmpty)
		{
			var self = this;
			var func = function(){
				var res = [];
				self._entries.forEach(function (r) {
					res.push(r.ancestor);
				});
				res = deep.utils.arrayUnique(res, &quot;path&quot;);
				self._entries = res;
				if(res.length === 0 &amp;&amp; errorIfEmpty)
					throw new Error(&quot;deep.parents could not gives empty results&quot;);
				return [deep.chain.values(self), null];
			};
			addInQueue.apply(this,[func]);
			return self;
		},
		/**
		 * take object, shcema, options and create fresh chain entries from it. Same mecanism as new chain.
		 * @method  root
		 * @chainable
		 * @param  object the object to produce entries  (could be a retrievable string - e.g. &quot;json::myobject.json&quot; - see retrievable doc)
		 * @param  schema the schema of the object  (could be a retrievable string - e.g. &quot;json::myobject.json&quot; - see retrievable doc)
		 * @return {deep.Chain} this
		 */
		root:function (object, schema, options)
		{
			var self = this;
			var func = function()
			{
				deep(object, schema)
				.nodes(function (nodes) {
					self._entries = nodes;
				})
				.done(function (success) {
					forceNextQueueItem(self, success, null);
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * Apply the query on EACH chain entries and concatened all the results to form new chain entries.
		 *
		 *
		 * inject queried results as chain success
		 * 
		 * @method  query
		 * @chainable
		 * @param  {string} q the deep-query. Could be an ARRAY of Queries : the result will be the concatenation of all queries on all entries
		 * @param  {boolean} errorIfEmpty : if true : throw an error if query return nothing
		 * @return {deep.Chain} this (chain handler)
		 */
		query : function(q, errorIfEmpty)
		{
			var src = this;
			//src.queries.push(q);
			if(!(q instanceof Array))
				q = [q];
			var func = function()
			{
				//console.log(&quot;do query : &quot;, q)
				var res = [];
				src._entries.forEach(function (r) {
					q.forEach(function (qu) {
						res = res.concat(src.querier.query(r, qu , {resultType:&quot;full&quot;}));
					});
				});
				src._entries = res;
				if(res.length === 0 &amp;&amp; errorIfEmpty)
					throw new Error(&quot;deep.query could not gives empty results&quot;);
				return [deep.chain.values(src), null];
			};
			addInQueue.apply(src, [func]);
			return src;
		},
		/**
		 * same as .query : but in place of holding queried entries : it return directly the query results.
		 * Is the synch version of the query handle.
		 *
		 * synch true
		 * transparent false
		 * 
		 * @method  select
		 * @chainable
		 * @param  {string} q the deep-query. Could be an ARRAY of Queries : the result will be the concatenation of all queries on all entries
		 * @return {deep.Chain} this
		 */
		select : function(q)
		{
			var src = this;
			if(!(q instanceof Array))
				q = [q];
			var res = [];
			src._entries.forEach(function (r) {
				q.forEach(function (qu) {
					res = res.concat(src.querier.query(r, qu));
				});
			});
			return res;
		},
		//_________________________________________________________________    MODELISATION
		/**
		 * set schema of all entries (purely assignation)
		 * inject entries shemas as chain success
		 * @method  schema
		 * @chainable
		 * @param  {string|object} schema  could be a retrievable string (e.g. &quot;json::myschema.json&quot; - see retrievable doc)
		 * @return {deep.Chain} this (chain handler)
		 */
		schema : function(schema)
		{
			//metaSchema = metaSchema || deep.metaSchema || {};
			var self = this;
			var func = function(){
				deep.when(deep.get(schema)).then(function (schema) {
					//var schema = schemas.shift();
					//var metaSchema = schemas.shift();
					var alls = [];
					self._entries.forEach(function(result){
						result.schema = schema;
					});
					forceNextQueueItem(self, schema, null);
				})
				.fail(function (error) {
					forceNextQueueItem(self, null, error);
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * apply provided schema on all entries schemas (.up application)
		 * inject entries shemas as chain success
		 * @method  schemaUp
		 * @chainable
		 * @param  {string|object} schema  could be a retrievable string (e.g. &quot;json::myschema.json&quot; - see retrievable doc)
		 * @return {deep.Chain} this (chain handler)
		 */
		schemaUp : function(schema, metaSchema)
		{
			metaSchema = metaSchema || deep.metaSchema || {};
			var self = this;
			var func = function(){
				deep.when(deep.get(schema))
				.done(function (schema) {
					var alls = [];
					self._entries.forEach(function(result){
						if(!result.schema)
							result.schema = {};
						alls.push(utils.up(schema, result.schema, metaSchema));
					});
					forceNextQueueItem(self, alls, null)
				})
				.fail(function (error) {
					forceNextQueueItem(self, null, error)
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * apply provided schema on all entries schemas (.bottom application)
		 *
		 * inject entries shemas as chain success
		 *
		 * 
		 * @method  schemaBottom
		 * @chainable
		 * @param  {string|object} schema  could be a retrievable string (e.g. &quot;json::myschema.json&quot; - see retrievable doc)
		 * @return {deep.Chain} this (chain handler)
		 */
		schemaBottom : function(schema, metaSchema)
		{
			metaSchema = metaSchema || deep.metaSchema || {};
			var self = this;
			var func = function(){
				deep.when(deep.get(schema))
				.done(function (schema) {
					var alls = [];
					self._entries.forEach(function(result){
						if(!result.schema)
							result.schema = {};
						alls.push(utils.bottom(schema, result.schema, metaSchema));
					});
					forceNextQueueItem(self, alls, null)
				})
				.fail(function (error) {
					forceNextQueueItem(self, null, error)
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * set entries properties by path.
		 *
		 * synch
		 * inject setted values as chain success
		 * 
		 * @method  setByPath
		 * @chainable
		 * @param {string} path  a slash delimitted path (e.g. &quot;/my/property&quot;)
		 * @param {object|primitive} obj the value to assign (could be a retrievable strings)
		 */
		setByPath : function(path, obj)
		{
			var self = this;
			var func = function(){
				deep.when(deep.get(obj)).then(function (obj)
				{
					var res = [];
					self._entries.forEach(function(result){
						res.push(utils.setValueByPath(result.value, path, obj, &#x27;/&#x27;));
					});
					forceNextQueueItem(self, res, null)
				},
				function (error) {
					forceNextQueueItem(self, null, error)
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * apply arguments from UP on each entries : will merge objects and array together DEEPLY. see docs and examples.
		 *
		 * synch
		 * inject entries values as chain success.
		 * 
		 * @method  up
		 * @chainable
		 * @param objects a list (coma separated - not an array) of objects to apply on each chain entries
		 * @return {deep.Chain} this
		 */
		up : function()
		{
			var args = Array.prototype.slice.call(arguments);
			var self = this;
			var func = function(){
				deep.when(deep.getAll(args)).then(function (objects)
				{
					self._entries.forEach(function(result){
						objects.forEach(function (object) {
							//console.log(&quot;deep.up : entry : &quot;, result, &quot; - to apply : &quot;, object)
							utils.up(object, result.value, result.schema, result.ancestor?result.ancestor.value:null, result.key);
						});
					});
					forceNextQueueItem(self, deep.chain.values(self), null)
				},
				function (error) {
					console.error(&quot;error : deep.up : &quot;,error);
					forceNextQueueItem(self, null, error)
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * 
		 * apply arguments from BOTTOM on each entries : will merge objects and array together DEEPLY. see docs and examples.
		 *
		 * synch
		 * inject entries values as chain success.
		 * @method  bottom
		 * @chainable
		 * @param objects a list (coma separated - not an array) of objects to apply on each chain entries
		 * @return {deep.Chain} this
		 */
		bottom : function()
		{
			var args = Array.prototype.slice.call(arguments);
			args.reverse();
			var self = this;
			var func = function(){
				deep.when(deep.getAll(args)).then(function (objects)
				{
					self._entries.forEach(function(result){
						objects.forEach(function (object) {
							utils.bottom(object, result.value, result.schema, result.ancestor?result.ancestor.value:null, result.key);
						});
					});
					forceNextQueueItem(self, deep.chain.values(self), null)
				},
				function (error) {
					console.error(&quot;error : deep.bottom : &quot;,error);
					forceNextQueueItem(self, null, error)
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 *
		 *	synch
		 * 
		 * replace queried entries properties by new value and inject replaced properties as chain success.
		 *
		 * @example
		 
	var a = {
		aString : &quot;Hello&quot;,
		anInt : 5,
		anArray : [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],
		anObject : {
			anArray : [&quot;4&quot;,&quot;5&quot;,&quot;6&quot;],
			aString : &quot;World&quot;
		}
	}
	deep(a)
	.replace(&quot;./anArray/1&quot;,&quot;replaceString&quot;)
	.equal({
		aString : &quot;Hello&quot;,
		anInt : 5,
		anArray : [&quot;1&quot;,&quot;replaceString&quot;,&quot;3&quot;],
		anObject : {
			anArray : [&quot;4&quot;,&quot;5&quot;,&quot;6&quot;],
			aString : &quot;World&quot;
		}
	});

		 * @method  replace
		 * @param  {string} what a query to select properties to replace 
		 * @param  {object} by  any value to assign (could be a retrievable string)
		 * @chainable
		 * @param  {object} options (optional) : it is the options object for the deep.get which will eventually retrieve the &#x27;by&#x27; object (see deep.get)
		 * @return {deep.Chain} this
		 */
		replace : function (what, by, options)
		{
			var self = this;
			var func = function(){
				deep.when(deep.get(by, options)).then(function (by)
				{
					var replaced = [];
					self._entries.forEach(function (r) {
						//console.log(&quot;chain replace : &quot;,what, &quot; - in :  &quot; , r.value)
						self.querier.query(r.value, what, {resultType:&quot;full&quot;}).forEach(function(r){
							//console.log(&quot;res query : &quot;, r)
							if(!r.ancestor)
								return;
							r.ancestor.value[r.key] = r.value = by;
							replaced.push(r);
						});
					});
					forceNextQueueItem(self, replaced, null)
				}, function (error) {
					//console.error(&quot;error : deep.replace : &quot;,error);
					forceNextQueueItem(self, null, error)
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * 
		 * remove queried properties from entries and inject removed properties as chain success.
		 * @example
	var a = {
		aString : &quot;Hello&quot;,
		anInt : 5,
		anArray : [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],
		anObject : {
			anArray : [&quot;4&quot;,&quot;5&quot;,&quot;6&quot;],
			aString : &quot;World&quot;
		}
	}

	deep(a)
	.remove(&quot;./anArray/1&quot;).log().valuesEqual([{
		aString : &quot;Hello&quot;,
		anInt : 5,
		anArray : [&quot;1&quot;,&quot;3&quot;],
		anObject : {
			anArray : [&quot;4&quot;,&quot;5&quot;,&quot;6&quot;],
			aString : &quot;World&quot;
		}
	}]);

	@example

	var obj = { 
		email: &#x27;test@test.com&#x27;,
		password: &#x27;test54&#x27;,
	 	id: &#x27;51013dec530e96b112000001&#x27; 
	}
	 var schema = { 
	 	properties: 
		{ 
		  	id: { type: &#x27;string&#x27;, required: false, minLength: 1 },
		    email: { type: &#x27;string&#x27;, required: true, minLength: 1 },
		    password: { type: &#x27;string&#x27;, required: true, &quot;private&quot;: true } 
		},
	 	additionalProperties: false 
	}

	deep(obj, schema)
	.remove(&quot;.//*?_schema.private=true&quot;)
	.equal({ 
		email: &#x27;test@test.com&#x27;,
	 	id: &#x27;51013dec530e96b112000001&#x27; 
	 });

		 * @chainable
		 * @method  remove
		 * @param  {string} what a query to select properties to replace 
		 * @return {deep.Chain} this
		 */
		remove : function (what)
		{
			var self = this;
			var func = function(){
				var removed = [];
				self._entries.forEach(function (r) {
					self.querier.query(r, what, {resultType:&quot;full&quot;}).forEach(function(r)
					{
						if(!r.ancestor)
							return;
						removed.push(r);
						if(r.ancestor.value instanceof Array)
							r.ancestor.value.splice(r.key,1);
						else
						{
							delete r.ancestor.value[r.key];
						}
					});
				});
				forceNextQueueItem(self, removed, null)
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * will perform the backgrounds application on any backgrounds properties at any level
		 * 
		 *	not intend to be call directly by programmer. use at your own risk. use .flatten instead.
		 *	
		 * @method  extendsChilds
		
		 * @private
		 * @param  {DeepEntry} entry from where seeking after backgrounds properties
		 * @return {deep.Promise} a promise
		 */
		extendsChilds : function(entry)
		{
			if(!entry)
				return entry;
			var toExtends = this.querier.query(entry, &quot;.//*?backgrounds&quot;, {resultType:&quot;full&quot;});
			if(toExtends.length === 0)
				return entry;
			var deferred = deep.Deferred();
			var rec = toExtends[0];
			var handler = deep(rec);
			handler.flatten().then(function ()
			{
				deep.when(handler.extendsChilds(entry)).then(function () {
					deferred.resolve(entry);
				}, function (error) {
					deferred.reject(error);
				});
			},
			function (error) {
				deferred.reject(error);
			});
			return deep.promise(deferred);
		},
		/**
		 * will perform the backgrounds application FIRSTLY and FULLY (full recursive) on current entries before appying extendsChild.
		 *
		 *	not intend to be call directly by programmer. use at your own risk.  use .flatten instead.
		 * 
		 * @method  extendsBackgrounds
		 * @private
		 * @param  {DeepEntry} entry from where seeking after backgrounds properties
		 * @return {deep.Promise} a promise
		 */
		extendsBackgrounds:function (entry)
		{
			var self = this;
			var value = entry;
			if(!entry)
				return [];
			if(entry._isDQ_NODE_)
				value = entry.value;
			if(value.backgrounds !== null &amp;&amp; typeof value.backgrounds === &quot;object&quot;)
			{
				var deferred = deep.Deferred();
				if(!value.backgrounds.push)
					value.backgrounds = [ value.backgrounds ];
				deep.when(deep.getAll(value.backgrounds, { root:entry })).then(function extendedsLoaded(extendeds){
					var recursion = [];
					while(extendeds.length &gt; 0)
					{
						var exts = extendeds.shift();
						if(exts instanceof Array)
						{
							extendeds = exts.concat(extendeds);
							continue;
						}
						recursion.push(exts);
						recursion.push(self.extendsBackgrounds(exts));
					}
					deep.all(recursion).then(function (extendeds){
						var res = [];
						extendeds.forEach(function (extended){
							res = res.concat(extended);
						});
						delete value.backgrounds;
						deferred.resolve(res);
					},function  (error) {
						console.error(&quot;currentLevel extension (backgrounds property) failed to retrieve pointed ressource(s) : &quot;+JSON.stringify(extendeds));
						deferred.reject(error);
					});
				}, function(res){
					console.error(&quot;currentLevel extension (backgrounds property) failed to retrieve pointed ressource(s) : &quot;+JSON.stringify(extendeds));
					deferred.reject(res);
				});
				return deep.promise(deferred);
			}
			return [];
		},
		/**
		 * will perform FULL backgrounds application on chain entries. (see backgrounds documentation)
		 *
		 * Success injected : entries values
		 * Errors injected : any flatten error
		 * @example
	var a = {
	    obj:{
	    	first:true
	    },
	    myFunc:function(){
	        console.log(&quot;base myFunc&quot;);
	        this.obj.a = true;
	    }
	}

	var b = {
		backgrounds:[a],
		obj:{
			second:true
		},
		myFunc:deep.compose.after(function()
		{
			console.log(&quot;myFunc of b : &quot;, this)
			this.obj.b = true;
		})
	}

	deep({})
	.bottom(b)
	.flatten()
	.run(&quot;myFunc&quot;)
	.query(&quot;./obj&quot;)
	.equal({
   		first:true,
   		second:true,
        a:true,
        b:true
	});
	@example
	deep({
	    sub:{
	        backgrounds:[b],
	        obj:{
	        	third:true
	        }
	    }
	})
	.flatten()
	.query(&quot;/sub&quot;)
	.run(&quot;myFunc&quot;)
	.query(&quot;./obj&quot;)
	.equal({
    	first:true,
   		second:true,
   		third:true,
        a:true,
        b:true
	});

		 * @chainable
		 * @async
		 * @method  flatten
		 * @return {deep.Chain} this
		 */
		flatten : function()
		{
			var self = this;
			var count = 0;
			var doChilds = function(result)
			{
				deep.when(self.extendsChilds(result)).then(function () {
					count--;
					if(count === 0)
						forceNextQueueItem(self, deep.chain.values(self), null);
				}, function (error) {
					console.error(&quot;error : deep.flatten : &quot;,error);
					throw new Error(&quot;error : deep.flatten : &quot;+error);
				});
			};
			var func = function(){
				var alls = [];
				self._entries.forEach(function (result)
				{
					count++;
					if(typeof result.value.backgrounds !== &#x27;undefined&#x27; &amp;&amp; result.value.backgrounds !== null)
					{
						deep.when(self.extendsBackgrounds(result)).then(function(stack) {
							var f = {};
							stack.forEach(function(s){ f = utils.bottom(s, result.value, result.schema); delete s.backgrounds; });
							delete result.value.backgrounds;
							doChilds(result);
						},function (error) {
							console.error(&quot;error : deep.flatten : &quot;, error);
							throw new Error(&quot;error : deep.flatten : &quot;+error);
						});
						delete result.value.backgrounds;
					}
					else
						doChilds(result);
				});
				if(self._entries.length === 0)
					return [deep.chain.values(self), null];
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		//______________________________________________________________  RUNS
		/**
		 * transform : loop on entries, apply &#x27;func&#x27; with &#x27;args&#x27; on each entry : replace entries values with func result
		 * function could return promise.
		 *
		 * - loop on entries : true
		 * - chainable : true
		 * - transparent : false
		 * - promised management : true
		 * - success injected : the array of results of each call on func
		 * - error injected : any error returned (or produced) from a func call
		 * 
		 * @method transform
		 * @chainable
		 * @param  {Function} func any function that need to be apply on each chain entry
		 * @param  {Array} args the arguments to pass to &#x27;func&#x27;
		 * @return {deep.Chain}  the current chain handler (this)
		 */
		transform : function (transformer)
		{
			var self = this;
			var func = function(s,e){
				deep(transformer)
				.done(function  (transformer) {
					var alls = [];
					self._entries.forEach(function(result){
						alls.push(transformer(result.value));
					});
					deep.all(alls).done(function (loadeds)
					{
						var count = 0;
						self._entries.forEach(function(result){
							result.value = loadeds[count];
							if(result.ancestor)
								result.ancestor[result.key] = result.value;
							count++;
						});
						forceNextQueueItem(self, loadeds, null);
					},
					function (error)
					{
						console.error(&quot;error : deep.transform : &quot;, error);
						forceNextQueueItem(self, null, error);
					});
				})
				
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * run : loop on entries, apply &#x27;func&#x27; with &#x27;args&#x27; on each entry (entry become &#x27;this&#x27; of func)
		 * function could retrun promise.
		 *
		 * - loop on entries : true
		 * - chainable : true
		 * - transparent : false
		 * - promised management : true
		 * - success injected : the array of results of each call on func
		 * - error injected : any error returned (or produced) from a func call
		 * @method run
		 * @chainable
		 * @param  {Function} func any function that need to be apply on each chain entry
		 * @param  {Array} args the arguments to pass to &#x27;func&#x27;
		 * @return {deep.Chain}  the current chain handler (this)
		 */
		run : function (funcRef, args)
		{
			var self = this;
			args = args || [];
			var create = function(s,e){
				var alls = [];
				self._entries.forEach(function(result){
					if(!funcRef)
					{
						if(typeof result.value != &quot;function&quot;)
							return;
						if(result.ancestor)
							alls.push(callFunctionFromValue(result.ancestor, result.key, args));
						else
							alls.push(result.value(args || null));
						return;
					}
					if(typeof funcRef === &#x27;function&#x27;)
						alls.push(runFunctionFromValue(result, funcRef, args));
					else if(typeof funcRef === &#x27;string&#x27;)
						alls.push(callFunctionFromValue(result, funcRef, args));
					else
						alls.push(result);
				});
				deep.all(alls).then(function (loadeds)
				{
					forceNextQueueItem(self, loadeds, null);
				},
				function (error)
				{
					console.error(&quot;error : deep.run : &quot;, error);
					forceNextQueueItem(self, null, error);
				});
			};
			addInQueue.apply(this,[create]);
			return this;
		},
		/**
		 * exec :  call &#x27;func&#x27; with &#x27;args&#x27; (the &#x27;this&#x27; of the function isn&#x27;t modified)
		 * function could retruen promise.
		 *
		 * - loop on entries : false
		 * - chainable : true
		 * - transparent : false
		 * - promised management : true
		 * - success injected : the result of the call on func
		 * - error injected : any error returned (or produced) from func call
		 *
		 *
		 * @method  exec
		 * @chainable
		 * @param  {Function} func any function that need to be apply on each chain entry
		 * @param  {Array} args the arguments to pass to &#x27;func&#x27;
		 * @return {deep.Chain}  the current chain handler (this)
		 */
		exec : function (func, args)
		{
			var self = this;
			args = args || [];
			var create = function()
			{
				deep.when(func.apply({}, args)).then(function (loadeds)
				{
					forceNextQueueItem(self, loadeds, null);
				},
				function (error)
				{
					console.error(&quot;error : deep.exec : &quot;, error);
					forceNextQueueItem(self, null, error);
				});
			};
			addInQueue.apply(this,[create]);
			return this;
		},
		/**
		 * apply a &#x27;treatments&#x27; on all chain entries at once (the array of entries values will be the context of the treatment). (renderables are treatments - see doc and example).
		 *
		 * a treaments is an object that contains : {
		 *   what : (optional) object|retrievable_string a value to inject in &#x27;how&#x27; function. if no &#x27;what&#x27; is provided : inject the entry (the context) in &#x27;how&#x27;
		 * 	 how : a function to treat &#x27;what&#x27; (simple function that have a single argument (what) and return its result),
		 * 	 where: (optional) a function to send the results somewhere, return the descriptor of the sended ressource (see deep-ui : dom.apendTo for example),
		 * 	 done : a callback function that will be called on treated entry (the context of the done) when treatment succeed
		 * 	 fail : a callback function that will be called on treated entry (the context of the fail) when treatment failed
		 * }
		 *
		 * if entry contain a &#x27;treat&#x27; function : will be called and provided treatment will be passed as argument
		 *
		 * Keep previous entries (maybe modified by treatment)
		 *
		 * Chain Success Injection : the treatments results
		 * Chain Error Injection : the treatments errors
		 * 
		 * @method  treatAll
		 * @deprecated see .val, .values, .each
		 * @param  {object} treatment
		 * @chainable
		 * @return {deep.Chain} this
		 */
		treatAll: function(treatment) {
			var self = this;
			var func = function(s, e)
			{
				deep.when(deep.get(treatment))
				.done(function(treatment){
					console.log(&quot;treat getted : &quot;, treatment)
					var prom = applyTreatment.apply(treatment, [deep.chain.values(self)]);
					deep.when(prom)
					.done(function(results) {
						console.log(&quot;treatment results : &quot;, results)
						forceNextQueueItem(self, results, null);
					})
					.fail(function(error) {
						forceNextQueueItem(self, null, error);
					});
				});
				
			};
			deep.chain.addInQueue.apply(this, [func]);
			return this;
		},
		/**
		 * apply a &#x27;treatments&#x27; on chain entries (each entry will be the context of the treatment). (renderables are treatments - see doc and example).
		 *
		 * a treaments is an object that contains : {
		 *   what : (optional) object|retrievable_string a value to inject in &#x27;how&#x27; function. if no &#x27;what&#x27; is provided : inject the entry (the context) in &#x27;how&#x27;
		 * 	 how : a function to treat &#x27;what&#x27; (simple function that have a single argument (what) and return its result),
		 * 	 where: (optional) a function to send the results somewhere, return the descriptor of the sended ressource (see deep-ui : dom.apendTo for example),
		 * 	 done : a callback function that will be called on treated entry (the context of the done) when treatment succeed
		 * 	 fail : a callback function that will be called on treated entry (the context of the fail) when treatment failed
		 * }
		 *
		 * if entry contain a &#x27;treat&#x27; function : will be called and provided treatment will be passed as argument
		 *
		 * Keep previous entries (maybe modified by treatment)
		 *
		 * Chain Success Injection : the treatments results
		 * Chain Error Injection : the treatments errors
		 * 
		 * @method  treatEach
		 * @deprecated see .val, .values, .each
		 * @param  {object} treatment
		 * @chainable
		 * @return {deep.Chain} this
		 */
		treatEach: function(treatment) {
			var self = this;
			var func = function(s, e)
			{
				deep.when(deep.get(treatment))
				.done(function(treatment){
					//console.log(&quot;treat getted : &quot;, treatment)
					var alls = [];
					self._entries.forEach(function(entry) {
						alls.push(applyTreatment.apply(treatment, [entry.value]));
					});
					
					deep.all(alls)
					.done(function(results) {
						//console.log(&quot;treatment results : &quot;, results)
						forceNextQueueItem(self, results, null);
					})
					.fail(function(error) {
						forceNextQueueItem(self, null, error);
					});
				});
				
			};
			deep.chain.addInQueue.apply(this, [func]);
			return this;
		},

		//_______________________________________________________________ TESTS AND VALIDATIONS

		/**
		 * valuesEqual : test strict equality between the array of entries values and a provided array of value
		 *
		 * - loop on entries : false
		 * - chainable : true
		 * - transparent : false
		 * - promised management : true (on callBack)
		 * - success injected : the result of the callBack or the report if callback returned nothing
		 * - error injected : the report or any error returned (or produced) from callBack
		 *
		 *
		 * 	Chain Success injection : the valid report
		 *	Chain Error injection : the unvalid report
		 *
		 * @method  valuesEqual
		 * @param  {Object} obj      the object to test equality
		 * @param  {Function} callBack optional : any callBack to manage the report. Could return a promise.
		 * @chainable
		 * @return {deep.Chain}     this
		 */
		valuesEqual : function(obj, callBack)
		{
			var self = this;
			var func = function(){
				var res = deep.chain.values(self);
				var o = {equal:utils.deepEqual(res, obj), needed:obj, needLength:obj.length, valuesLength:res.length, value:res};
				if(o.equal)
					console.info(&quot;deep.valuesEqual : &quot;+ JSON.stringify(o, null, &#x27; &#x27;));
				else
					console.error(&quot;deep.valuesEqual : &quot;+ JSON.stringify(o, null, &#x27; &#x27;));

				if(callBack)
				{
					deep.when(callBack(o)).then(function (argument) {
						if(typeof argument === &#x27;undefined&#x27;)
							argument = o;
						forceNextQueueItem(self, argument, null);
					}, function (error) {
						forceNextQueueItem(self, o, error);
					});
				}
				else
				{
					self.running = false;
					forceNextQueueItem(self, o, !o.equal);
				}
			};
			addInQueue.apply(this,[func]);
			return self;
		},

		/**
		 * equal test strict equality on each entry value against provided object
		 *
		 *	Chain Success injection : the valid report
		 *	Chain Error injection : the unvalid report
		 *
		 * 
		 * @method  equal
		 * @param  {*} obj      the object to test
		 * @param  {Function}	optional. callBack a callBack to manage report
		 * @chainable
		 * @return {deep.Chain}        this
		 */
		equal : function(obj, callBack)
		{
			// console.log(&quot;deep.equal chaining&quot;);
			var self = this;
			var func = function(){
				//console.log(&quot;will do deep.equal : self : &quot;, self._entries)
				var res = [];
				var errors = [];
				self._entries.forEach(function(r){
					//console.log(&quot;deep.equal : r : &quot;,r);
					var ok = utils.deepEqual(r.value, obj);
					var o = {path:r.path, equal:ok, value:r.value, needed:obj};
					res.push(o);
					if(!ok)
						errors.push(o);
					if(o.equal)
						console.info(&quot;deep.equal : &quot;+o.equal+&quot; : &quot;, o);
					else
						console.error(&quot;deep.equal : &quot;+o.equal+&quot; : &quot;, o);
				});
				var report = {
					equal:(self._entries.length &gt; 0) &amp;&amp; (errors.length===0),
					reports:res
				};
				if(callBack)
				{
					deep.when(callBack(report)).then(function (argument) 
					{
						if(report.equal)
							forceNextQueueItem(self, report, null);
						else
							forceNextQueueItem(self, null, report);
					}, function (error) {
						forceNextQueueItem(self, report, error);
					});
				}
				else
				{
					if(report.equal)
						forceNextQueueItem(self, report, null);
					else
						forceNextQueueItem(self, null, report);
				}
			};
			addInQueue.apply(this,[func]);
			return self;
		},

		/**
		 * validate apply validation
		 *
		 *	Chain Success injection : the valid report
		 *	Chain Error injection : the unvalid report
		 * 
		 * @method  validate
		 * @param  {Object} options [description]
		 * @chainable
		 * @return {deep.Chain}         [description]
		 */
		validate:function(schema, options)
		{
			options = options || {};
			var self = this;

			var func = function()
			{
				var report = {
					valid:true,
					reports:[]
				};
				self._entries.forEach(function (e) {
					var rep = Validator.validate(e.value, schema || e.schema);
					report.reports.push(rep);
					if(!rep.valid)
						report.valid = false;
				});
				
				//console.log(&quot;validate is valid : &quot;, report.valid);

				if(options.callBack)
				{
					deep.when(options.callBack(report))
					.then(function (argument) {
						report.callBackResponse = argument;
						if(freport.valid)
							forceNextQueueItem(self, report, null);
						else
							forceNextQueueItem(self, null, report);
					}, function (error) {
						forceNextQueueItem(self, null, error);
					});
				}
				else if(report.valid)
					return [report, null];
				//console.log(&quot;report not valid : &quot;, report)
				return [null, report];
			};
			func._name = &quot;deep.Chain.validate&quot;;
			addInQueue.apply(this,[func]);
			return this;
		},

		// __________________________________________________ LOG
		/**
		 * 
		 * log any provided arguments.
		 * If no arguments provided : will log current success or error state.
		 *
		 * transparent true
		 * 
		 * @method  log
		 * @return {deep.Chain} this
		 * @chainable
		 */
		log:function ()
		{
			var self = this;
			var args = Array.prototype.slice.call(arguments);
			var func = function(s,e)
			{
				if(args.length === 0)
				{
					if(e)
						args.push(&quot;deep.log : ERROR State : &quot;,e);
					else
						args.push(&quot;deep.log : SUCCESS State : &quot;,s);
				}
				args.forEach(function (a) {
					console.log(a);
				});
				forceNextQueueItem(self, s,e);
			};
			func._isTRANSPARENT_ = true;
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 * 
		 * log current chain entries  with optional title
		 *
		 * full option means print full entry in place of just entry.value
		 * pretty option means print pretty json (indented)
		 * 
		 * transparent true
		 *
		 * @method  logValues
		 * @chainable
		 * @param title (optional) the title you want
		 * @param options (optional) could contain : &#x27;full&#x27;:true|false, &#x27;pretty&#x27;:true|false 
		 * @return {deep.Chain} this
		 */
		logValues:function (title, options)
		{
			var self = this;
			options = options || {};
			var func = function(success, error)
			{
				console.log(title||&quot;deep.logValues : &quot;, &quot; (&quot;+self._entries.length+&quot; values)&quot;);
				self._entries.forEach(function (e) {
					var val = e;
					var entry = null;
					if(e.value)
					{
						entry = e.value._deep_entry;
						delete e.value._deep_entry;
					}
					
					if(!options.full)
						val = e.value;
					if(options.pretty)
						val = JSON.stringify(val, null, &#x27; &#x27;);
					console.log(&quot;\t- entry : (&quot;+e.path+&quot;) : &quot;, val);
					if(entry &amp;&amp; e.value)
						e.value._deep_entry = entry;
				});
				self.running = false;
				nextQueueItem.apply(self,[success, error]);
			};
			func._isTRANSPARENT_ = true;
			addInQueue.apply(this,[func]);
			return this;
		},
		// ________________________________________ READ ENTRIES

		/**
		 *
		 * if no callBack is present : just return the FIRST value of entries. It&#x27;s a chain end handle.
		 * If callback is provided : the FIRST entry  value will be passed as argument to callback.
		 * 		and so th chain could continue : the return of this handle is the deep handler.
		 *
		 * transparent true
		 * 
		 * @method  val
		 * @param callBack could be a retrievable (a String pointing something from store), or a Function, or a treatment (an Object - see treatments in doc)
		 * @chainable
		 * @return {deep.Chain|entry.value} this or val
		 */
		val:function  (callBack)
		{
			var self = this;
			var func = function(s,e)
			{
				deep(callBack)
				.done(function (callBack) {
					var  a = self._entries[0]?self._entries[0].value:null;
					var r = null;
					if(typeof callBack === &#x27;object&#x27;)
						r = applyTreatment.apply(callBack, [a]);
					else
						r = callBack(a);
					deep.when(r).then(function (argument) {
						if(typeof argument === &#x27;undefined&#x27;)
							argument = a;
						console.log(&quot;val callBack res : &quot;,argument);
						forceNextQueueItem(self, argument, null);
					}, function (error) {
						//console.error(&quot;error : deep.val : &quot;,error);
						forceNextQueueItem(self, null, error);
					});
				})
				.fail(function (error) {
					forceNextQueueItem(self, null, error);
				})
				
			};
			if(callBack)
			{
				addInQueue.apply(this,[func]);
				return this;
			}
			else
				return deep.chain.values(this).shift();
		},
		 /**
		 *
		 * if no callBack is present : just return the array of values of entries. It&#x27;s a chain end handle.
		 * If callback is provided : the entries values will be passed as argument to callback.
		 * 		and so th chain could continue : the return of this handle is the deep handler.
		 *
		 * transparent true
		 *
		 * 
		 * @method  values
		 * @chainable
		 * @param callBack could be a retrievable (a String pointing something from store), or a Function, or a treatment (an Object - see treatments in doc)
		 * @return {deep.Chain|Array} this or values
		 */
		values:function  (callBack)
		{
			var self = this;
			var func = function(s,e)
			{
				deep(callBack)
				.done(function (callBack) {
					var  a = deep.chain.values(self);
					var r = null;
					if(typeof callBack === &#x27;object&#x27;)
						r = applyTreatment.apply(callBack, [a]);
					else
						r = callBack(a);
					deep.when(callBack(a)).then(function (res) {
						if(typeof res === &quot;undefined&quot;)
							res = a;
						forceNextQueueItem(self, res, null)
					}, function (error) {
						console.error(&quot;error : deep.values : &quot;,error);
						forceNextQueueItem(self, null, error)
					});
				})
				.fail(function (error) {
					forceNextQueueItem(self, null, error);
				});
			};
			if(callBack)
			{
				addInQueue.apply(this,[func]);
				return this;
			}
			else
				return deep.chain.values(this);
		},
		/**
		 * will pass each entries to callback as argument . same behaviours than classical Array.each.
		 * callback could return promise. the chain will wait any promise before continuing.
		 *
		 * Chain Success injection : the results of callback calls (resolved if promises)
		 * Chain Error injection : the errors of callback calls (rejected if promises)
		 * 
		 * @method  each
		 * @chainable
		 * @param callBack could be a retrievable (a String pointing something from store), or a Function, or a treatment (an Object - see treatments in doc)
		 * @return {deep.Chain} this
		 */
		each:function  (callBack)
		{
			var self = this;
			var func = function()
			{
				deep(callBack)
				.done(function (callBack) {
					var alls = [];
					if(typeof callBack === &#x27;object&#x27;)
						self._entries.forEach(function(entry) {
							alls.push(applyTreatment.apply(callBack, [entry.value]));
						});
					else
						self._entries.forEach(function(e){
							alls.push(callBack(e.value));
						});
					deep.all(alls).then(function (results) {
						forceNextQueueItem(self, results, null);
					}, function (error) {
						forceNextQueueItem(self, null, error);
					});
				})
				.fail(function (error) {
					forceNextQueueItem(self, null, error);
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},
		/**
		 *
		 * if no callBack is present : just return the array of entries. It&#x27;s a chain end handle.
		 * If callback is provided : the entries will be passed as argument to callback.
		 * 		and so th chain could continue : the return of this handle is the deep handler.
		 * 
		 * transparent true
		 * 
		 * @method  nodes
		 * @chainable
		 * @param callBack
		 * @return {deep.Chain|Array} this or entries
		 */
		nodes:function  (callBack)
		{
			var self = this;
			var func = function(s,e)
			{
				var  a = self._entries.concat([]);
				deep.when(callBack(a)).then(function (argument) {
					self.running = false;
					nextQueueItem.apply(self, [s, e]);
				}, function (error) {
					console.error(&quot;error : deep.nodes : &quot;,error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			};
			if(callBack)
			{
				addInQueue.apply(this,[func]);
				return this;
			}
			else
				return deep.chain.nodes(this);
		},

		//___________________________________________________________ WAIT

		/**
		 * will wait xxxx ms before contiuing chain
		 *
		 * transparent true
		 * 
		 * 
		 * @chainable
		 * @method delay
		 * @param  {number} ms
		 * @return {deep.Chain} this
		 */
		delay:function (ms)
		{
			var self = this;
			var func = function(s,e){
				//console.log(&quot;deep.delay : &quot;, ms)
				setTimeout(function () {
					console.log(&quot;deep.delay.end : &quot;, ms);
					try{
						forceNextQueueItem(self, s, e);
					}
					catch(e)
					{
						//deep.utils.rethrow(e);
						forceNextQueueItem(self, s, e);
					}
					
				}, ms);
			}
			func._isTRANSPARENT_ = true;
			addInQueue.apply(this,[func]);
			return this;
		},
		//____________________________________________________________________  LOAD

		/**
		 * will seek in entries after any retrievable string OR executable functions : and will replace references by loaded/returned content.
		 *
		 * if context is provided : will try to &#x27;interpret&#x27; (see .interpret) strings before retrieving them.
		 *
		 * Chain Success injection : array of loaded results
		 *
		 * @method deepLoad
		 * @param  {object} context (optional) a context to interpret strings before retrieving
		 * @chainable
		 * @return {deep.Chain} this
		 */
		deepLoad:function(context)
		{
			var self = this;
			function func(){
				return function(s,e){
					var  paths = [];
					var  promises = [];
					//console.log(&quot;deepLoad : &quot;, self)
					self._entries.forEach(function (e) {
						var strings = self.querier.query(e, &quot;.//*?or(_schema.type=string,_schema.type=function)&quot;, {resultType:&quot;full&quot;});
						//console.log(&quot;deep load query result : &quot;, strings)
						strings.forEach(function (toLoad) {

							if(typeof toLoad.value === &#x27;string&#x27;)
							{
								//console.log(&quot;deep.deepLoad : toLoad string : &quot;, JSON.stringify(toLoad.value));
								var val = toLoad.value;
								if(context)
									val = deep.interpret(toLoad.value, context);
								promises.push(deep.get(val, {root:(toLoad.root)?toLoad.root.value:null, basePath:toLoad.path }));
							}
							else if(typeof toLoad.value === &#x27;function&#x27;)
							{
								//console.log(&quot;deep.deepLoad : toLoad function : &quot;, JSON.stringify(toLoad.value));
								promises.push(toLoad.value());
							}	
							else
							{
								//console.log(&quot;deep.deepLoad : toLoad object : &quot;, JSON.stringify(toLoad.value));
								promises.push(toLoad.value);
							}
							paths.push(toLoad);
						});
					});
					deep.all(promises)
					.done(function (results) {
						//console.log(&quot;direct results of deepLoad : &quot;, results);
						var count = 0;
						results.forEach(function  (r) {
							var e = paths[count++];
							if(e.ancestor)
								e.ancestor.value[e.key] = e.value = r;
						});
						self.running = false;
						nextQueueItem.apply(self, [ results, null ]);
					})
					.fail(function (error) {
						console.error(&quot;error : deep.deepLoad : &quot;, error);
						self.running = false;
						nextQueueItem.apply(self, [ null, error ]);
					});
				};
			}
			addInQueue.apply(this,[func()]);
			return this;
		},
		/**
		 *
		 * if request is provided : 
		 * 		try to retrieve &#x27;request&#x27; and replace entries values by loaded result
		 * 	else
		 * 		will try to retrieve any entry.value strings (will not seek deeply) and replace associated entries values by loaded result.
		 * 		OR if entry.value is an object : look if there is any .load() function in it. If so : fire it.
		 * 
		 * if context is provided : will try to &#x27;interpret&#x27; (see .interpret) strings before retrieving them.
		 * 	(on request or entries values)
		 *
		 * Chain success injection : array of loaded content.
		 * 	
		 * @method load
		 * @param  {string} request (optional) 
		 * @param  {object} context (optional) the context to interpret strings
		 * @chainable
		 * @return {deep.Chain} this
		 */
		load:function (request, context)
		{
			var self = this;
			function func(){
				return function(){
					var  paths = [];
					var  promises = [];
					//console.log(&quot;deep.load : &quot;, deep.chain.stringify(self))
					//console.log(&quot;deep.load : entries : &quot;, self.entries)

					if(request)
					{
						if(typeof request === &quot;string&quot;)
						{
							if(context)
								request = deep.interpret(request, context);
							promises.push(deep.get(request));
						}
						if(typeof request === &#x27;function&#x27;)
							promises.push(request());
						else
							promises.push(request);
					}
					else
						self._entries.forEach(function (e) {
							if(!e.value)
								return;
							if(e.value.load)
								promises.push(callFunctionFromValue(e, &quot;load&quot;));
							else if(typeof e.value === &#x27;string&#x27;)
							{
								var toLoad = e.value;
								if(context)
									toLoad = deep.interpret(toLoad, context);
								promises.push(deep.get(toLoad, { root:(e.root)?e.root.value:e.value, basePath:e.path }));
							}
							else
								promises.push(e.value);
							paths.push(e);
						});
					deep.all(promises).then(
					function (results) {
						//console.log(&quot;deep.load results : &quot;, results)
						var count = 0;
						if(request)
						{
							//console.log(&quot;deep.load results from request : &quot;, self._entries)
							self._entries.forEach(function (entry) {
								if(!entry.ancestor)
									//throw new Error(&quot;You couldn&#x27;t interpret root !&quot;);
										entry.value = results[0];
									else
										entry.value = entry.ancestor.value[entry.key] = results[0];
							});
						}
						else
							results.forEach(function  (r) {
								//console.log(&quot;deep.load results from inner : &quot;, r)
								var item = paths[count++];
								if(!item.value.load)
								{
									if(!item.ancestor)
									//throw new Error(&quot;You couldn&#x27;t interpret root !&quot;);
										item.value = r;
									else
										item.value = item.ancestor.value[item.key] = r;
								}
							});
						self.running = false;
						nextQueueItem.apply(self, [results, null]);
					},
					function (error) {
						console.error(&quot;deep.load errors : &quot;, error);
						self.running = false;
						nextQueueItem.apply(self, [null, error]);
					});
				};
			}
			addInQueue.apply(this,[func()]);
			return this;
		},

		//________________________________________________________________________ INTERPET STRINGS

		/*
		 *
		 * seek after any strings and try to interpret it with current context.
		 *
		 * see interpretation for simple case  
		 * @example
		 * 
		 * 		deep({ msg:&quot;hello { name }&quot; }).deepInterpret({ name:&quot;john&quot; }).logValues().equal({ msg:&quot;hello john&quot; });
		 * 
		 * 
		 * @method deepInterpret
		 * @chainable
		 * @param  {object} context the oebjct to inject in strings
		 * @return {deep.Chain} this
		 */
		/*deepInterpret:function(context)
		{
			var self = this;
			var func = function(){
				context = (typeof context === &#x27;string&#x27;)?deep.get(context):context;
				deep(context)
				.done(function (context)
				{
					var res = [];
					self._entries.forEach(function (e) {
						var strings = self.querier.query(e, &quot;.//?_schema.type=string&quot;, {resultType:&quot;full&quot;});
						strings.forEach(function (interpretable) {
							var r = deep.interpret(interpretable.value, context);
							res.push(r);
							if(!interpretable.ancestor)
								//throw new Error(&quot;You couldn&#x27;t interpret root !&quot;);
								interpretable.value = r;
							else
								interpretable.ancestor.value[interpretable.key] = interpretable.value = r;
						});
					});
					self.running = false;
					nextQueueItem.apply(self, [res, null]);
				})
				.fail(function (error)
				{
					console.error(&quot;error : deep.deepInterpret : &quot;, error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},*/
		/**
		 * will interpret entries values with context
		 * @example  
		 * 	 	deep(&quot;hello { name }&quot;).interpret({ name:&quot;john&quot; }).val();
		 *   	//will provide &quot;hello john&quot;.
		 * 		deep({
		 *     		msg:&quot;hello { name }&quot;
		 * 		})
		 * 		.query(&quot;./msg&quot;)
		 * 		.interpret({ name:&quot;john&quot; })
		 * 		.logValues()
		 * 		.equal(&quot;hello john&quot;);
		 *   
		 * @method interpret
		 * @chainable
		 * @param  {object} context the context to inject in strings
		 * @return {deep.Chain} this
		 */
		interpret:function(context)
		{
			var self = this;
			var func = function(){
				console.log(&quot;deep.chain.interpret : context : &quot;,context);
				context = (typeof context === &#x27;string&#x27;)?deep.get(context):context;
				deep(context).then(function (context) {
					console.log(&quot;interpret: received context : &quot;, context);
					var res = [];
					self._entries.forEach(function (interpretable)
					{
						if(typeof interpretable.value === &#x27;string&#x27;)
						{
							var r = deep.interpret(interpretable.value, context);
							res.push(r);
							if(!interpretable.ancestor)
								//	throw new Error(&quot;You couldn&#x27;t interpret root !&quot;);
								interpretable.value = r;
							else
								interpretable.ancestor.value[interpretable.key] = interpretable.value = r;
							console.log(&quot;deep.chain.interpret : res : &quot;, r);
						}
						else
							res.push(interpretable.value);
					});
					self.running = false;
					nextQueueItem.apply(self, [res, null]);
				}, function (error) {
					console.error(&quot;error : deep.interpret : &quot;, error);
					self.running = false;
					nextQueueItem.apply(self, [null, error]);
				});
			};
			addInQueue.apply(this,[func]);
			return this;
		},

		//________________________________________________________ PUSH TO

		pushHandlerTo : function(array)
		{
			var self = this;
			var f = function(s,e)
			{
				// console.log(&quot;pushHandlerTo : init? &quot;, self.initialised)
				array.push(self);
				if(self.initialised)
				{
					self.running = false;
					nextQueueItem.apply(self, [s, e]);
				}
			};
			f._isPUSH_HANDLER_TO_ = true;
			addInQueue.apply(this,[f]);
			return this;
		},


		//__________________________________________________________ MAP
		/**
		 * It&#x27;s the way of performing a SQL JOIN like between two objects.
		 * Objects could be retrievables.
		 *
		 * take current entries, seek after localKeys, use it to get &#x27;what&#x27; with foreignKey=localKey, and finnaly store result at &#x27;whereToStore&#x27; path in current entries values.
		 *
		 * @example

	deep([{ title:&quot;my title&quot;, id:1}, { title:&quot;my title 2&quot;, id:2}])
	.mapOn([
	    {itemId:1, value:true}, 
	    {itemId:2, value:&quot;133&quot;}, 
	    {itemId:2, value:&quot;hello&quot;}
	    ], 
	    &quot;id&quot;,&quot;itemId&quot;,&quot;linkeds&quot;)
	.valuesEqual([
	    {
	        title:&quot;my title&quot;, 
	        id:1, 
	        linkeds:{itemId:1, value:true}
	    },
	    { 
	        title:&quot;my title 2&quot;, 
	        id:2,
	        linkeds:[
	            {itemId:2, value:&quot;133&quot;},
	            { itemId:2, value:&quot;hello&quot;}
	        ]
	    }
	]);
		 * 
		 * @method mapOn
		 * @chainable
		 * @param  {Collection|retrievable_string} what
		 * @param  {string} localKey  the name of the localKey to match with Collection items
		 * @param  {string} foreignKey  the name of the foreignKey to match with current entries
		 * @param  {string} whereToStore the path where save map result in each entries
		 * @return {deep.Chain} this
		 */
		mapOn: function(what, localKey, foreignKey, whereToStore)
		{
			var self = this;
			var doMap = function (what, localKey, foreignKey, whereToStore)
			{
				var map = {};
				what.forEach(function (w) {
					if(w === null)
						return;
					var val = w[foreignKey];
					if(typeof map[val] !== &#x27;undefined&#x27;)
					{
						if(map[val] instanceof Array)
							map[val].push(w);
						else
							map[val] = [map[val] ,w];
					}
					else
						map[val] = w;
				});
				self._entries.forEach(function(entry) {
					if(map[entry.value[localKey]])
						entry.value[whereToStore || localKey] = map[entry.value[localKey]];
				});
				forceNextQueueItem(self, deep.chain.values(self), null);
			};
			var func = function(s, e) {
				if(self._entries.length === 0)
				{
					forceNextQueueItem(self, deep.chain.values(self), null);
					return;
				}
				if(typeof what === &#x27;string&#x27;)
				{
					var parsed = deep.parseRequest(what);
					var cloned = cloneHandler(self, true);
					var foreigns = cloned.select(&quot;./&quot;+localKey).join(&quot;,&quot;);
					var constrain = foreignKey+&quot;=in=(&quot;+foreigns+&quot;)&quot;;
					if(parsed.uri === &#x27;!&#x27;)
						parsed.uri = &quot;&quot;;
					if(parsed.uri.match(/(\/\?)|^(\?)/gi))
						parsed.uri += &quot;&amp;&quot;+constrain;
					else
						parsed.uri += &quot;?&quot;+constrain;
					//console.log(&quot;mapOn : parsedUri with constrains : &quot;,parsed.uri);
					if(parsed.store !== null)
					{
						deep(parsed.store.get(parsed.uri)).done(function (results) {
							results = [].concat(results);
							doMap(results, localKey, foreignKey, whereToStore);
						});
					}
					else
						forceNextQueueItem(self, null, new Error(&quot;deep.mapOn need array as &#x27;what&#x27; : provided : &quot;+ JSON.stringify(what)));
				}
				else
					doMap(what, localKey, foreignKey, whereToStore);
			};
			deep.chain.addInQueue.apply(this, [func]);
			return this;
		},

		/**
		 * retrieve relations described in schema links.
		 *
		 * Inject as success in chain an object that hold each relation, their result and the associated (parsed) request object
		 *
		 * 
		 *
		 * 
		 * @method getRelations
		 * @chainable
		 * @example
		 * 	var schema3 = {
			    properties:{
			        id:{ type:&quot;string&quot;, required:false, indexed:true },
			        label:{ type:&quot;string&quot; },
			        plantId:{ type:&quot;string&quot; },
			        userId:{ type:&quot;string&quot; }
			    },
			    links:[
			        {
			            href:&quot;plant::{ plantId }&quot;,
			            rel:&quot;plant&quot;
			        },
			        {
			            href:&quot;user::{ userId }&quot;,
			            rel:&quot;user&quot;
			        }
			    ]
			}
			//____________________________
			deep({ 
			    plantId:&quot;e1&quot;,
			    userId:&quot;e1&quot;,
			    label:&quot;hello&quot;
			}, schema3)
			.getRelations(&quot;plant&quot;, &quot;user&quot;)
			.log();

		 * @param a list of string arguments that gives which relation to retrieve 
		 * @return {deep.Chain} this
		 */
		getRelations:function () {
			var self = this;
			var relations = Array.prototype.slice.apply(arguments);
			var func = function (s,e) {
				self._entries.forEach(function(entry){
					if(!entry.schema || !entry.schema.links)
						return;
					var alls  = [];
					deep(entry.schema.links)
					.query(&quot;./!?rel=in=(&quot;+relations.join(&quot;,&quot;)+&quot;)&quot;)
					.each(function(relation){
						var path = deep.interpret(relation.href, entry.value);
						var parsed = deep.parseRequest(path);
						alls.push(deep.get(parsed, { defaultProtocole:&quot;json&quot;, wrap:{ relation:relation, request:parsed } }));
					});
					if(alls.length == 0)
						return [s,e];
					deep.all(alls)
					.done(function(results){
						var res = {};
						results.forEach(function(r){
							res[r.relation.rel] = r;
						});
						forceNextQueueItem(self, res, null);
					})
					.fail(function(error){
						forceNextQueueItem(self, null, error);
					})
				});
			}
			deep.chain.addInQueue.apply(this, [func]);
			return this;
		},



		/**
		 * map relations in current entries values
		 * 
		 * @method mapRelations
		 * @chainable 
		 * @example 
		 * 	var schema3 = {
			    properties:{
			        id:{ type:&quot;string&quot;, required:false, indexed:true },
			        label:{ type:&quot;string&quot; },
			        plantId:{ type:&quot;string&quot; },
			        userId:{ type:&quot;string&quot; }
			    },
			    links:[
			        {
			            href:&quot;plant::{ plantId }&quot;,
			            rel:&quot;plant&quot;
			        },
			        {
			            href:&quot;user::{ userId }&quot;,
			            rel:&quot;user&quot;
			        }
			    ]
			}
		  	deep({ 
			    plantId:&quot;e1&quot;,
			    userId:&quot;e1&quot;,
			    label:&quot;hello&quot;
			}, schema3)
			.mapRelations({
			    user:&quot;relations.user&quot;,
			    plant:&quot;relations.plant&quot;
			})
			.logValues();
		 * @param  {Object} map        the map (see examples)
		 * @param  {String} delimitter (optional) the paths delimitter
		 * @return {deep.Chain}       this
		 */
		mapRelations:function (map, delimitter) {
			if(!delimitter)
				delimitter = &quot;.&quot;;
			var self = this;
			var relations = [];
			for(var i in map)
				relations.push(i);
			//console.log(&quot;mapRelations :  relations : &quot;, relations);
			var func = function (s,e) {
				self._entries.forEach(function(entry){
					if(!entry.schema || !entry.schema.links)
						return;
					var alls  = [];
					var count  = 0;
					deep(entry.schema.links)
					.query(&quot;./!?rel=in=(&quot;+relations.join(&quot;,&quot;)+&quot;)&quot;)
					.each(function(relation){
						//console.log(&quot;do map relations on : &quot;, relation);
						var path = deep.interpret(relation.href, entry.value);
						alls.push(deep.get(path, { defaultProtocole:&quot;json&quot;, wrap:{ path:map[relation.rel] } }));
						count++;
					});
					if(alls.length == 0)
						return [s,e];
					deep.all(alls)
					.done(function(results){
						//console.log(&quot;mapRelations : results : &quot;, results);
						results.forEach(function(r){
							//console.log(&quot;do : &quot;, r, &quot; - on : &quot;, entry.value)
							deep.utils.setValueByPath(entry.value, r.path, r.result, delimitter);
						});
						forceNextQueueItem(self, results, null);
					})
					.fail(function(error){
						forceNextQueueItem(self, null, error);
					})
				});
			}
			deep.chain.addInQueue.apply(this, [func]);
			return this;
		},
		/**
		 * return a promise for the chain.
		 * @return {deep.Promise}
		 */
		promise:function () {
			this._listened = true;
			if(this.initialised &amp;&amp; this.callQueue.length === 0 &amp;&amp; !this.running &amp;&amp; !this.deferred.rejected &amp;&amp; !this.deferred.resolved &amp;&amp; !this.deferred.canceled)
				if(this.reports.failure)
					this.reject(this.reports.failure);
				else
					this.resolve(this.reports.result);
			return this.deferred.promise();
		}
	};

	//________________________________________________________ DEEP CHAIN UTILITIES

	deep.chain = {
		nextQueueItem:nextQueueItem,
		forceNextQueueItem:forceNextQueueItem,
		addInQueue:addInQueue,
		stringify:function (handler, options)
		{
			options = options || {};
			var res = &quot;&quot;;
			handler._entries.forEach(function (e) {
				if(options.pretty)
					res += JSON.stringify(e.value, null, &#x27; &#x27;)+&quot;\n&quot;;
				else
					res += JSON.stringify(e.value)+&quot;\n&quot;;
			});
			return res;
		},
		clear:function (handler) {
			handler.oldQueue = [];
			handler.callQueue = [];
			return handler;
		},
		val:function (handler) {
			if(handler._entries.length === 0)
				return undefined;
			return handler._entries[0].value;
		},
		values:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.value);
			});
			return res;
		},
		nodes:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e);
			});
			return res;
		},
		paths:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.paths);
			});
			return res;
		},
		schemas:function (handler) {
			var res = [];
			handler._entries.forEach(function (e) {
				res.push(e.schema);
			});
			return res;
		},
		position : function (handler, name, options) {
			options = options || {};
			handler.positions.push({
				name:name,
				entries:handler._entries.concat([]),
				store:handler._store,
				queue:(options.restartChain)?handler.callQueue.concat([]):null
			});
		}
	};
	

	//______________________________________

	deep.handlers = {};
	deep.handlers.decorations = {};
	//________________________________________________________ DEEP CHAIN UTILITIES

	/**
	 * execute array of funcs sequencially
	 * @for deep
	 * @static 
	 * @method sequence
	 * @param  {String} funcs an array of functions to execute sequentially
	 * @param  {Object} args (optional) some args to pass to first functions
	 * @return {deep.Chain} a handler that hold result 
	 */
	deep.sequence = function (funcs, args)
	{
		if(!funcs || funcs.length === 0)
			return args;
		var current = funcs.shift();
		var def = deep.Deferred();
		var context = {};
		var doIt = function (r) {
			deep.when(r).then(function (r)
			{
				if(funcs.length === 0)
				{
					if(typeof r === &#x27;undefined&#x27;)
					{
						r = args;
						if(args.length == 1)
							r = args[0];
					}
					def.resolve(r);
					return r;
				}
				if(typeof r === &#x27;undefined&#x27;)
					r = args;
				else
					r = [r];
				current = funcs.shift();
				doIt(current.apply(context, r));
			}, function (error) {
				if(!def.rejected &amp;&amp; !def.resolved &amp;&amp; !def.canceled)
					def.reject(error);
			});
		};
		doIt(current.apply(context, args));
		return deep.promise(def);
	};

	

	//__________________________________________________________________ TREATMENTS

	/**
	 * apply treatment 
	 * @param  {[type]} treatment [description]
	 * @param  {[type]} context   [description]
	 * @return {[type]}           [description]
	 */
	deep.treat =  function(treatment, context) {
		return applyTreatment.apply(treatment, [context || {}]);
	};


	var applyTreatment = function(context) 
	{
		if (!this.how || this.condition === false)
			return false;
		if (typeof this.condition === &quot;function&quot; &amp;&amp; !this.condition.apply(this))
			return false;
		//console.log(&quot;deep.applyTtreatment : &quot;, this, context);
		context = context || this;
		var self = this;
		var objs = [];

		if (typeof this.what === &#x27;string&#x27;)
		{
			var what = deep.interpret(this.what, context);
			objs.push(deep.get(what, {
				root: context._deep_entry || context
			}));
		}
		else if (typeof this.what === &#x27;function&#x27;)
			objs.push(this.what.apply(controller));
		else if (this.what)
			objs.push(this.what);

		if (typeof this.how === &quot;string&quot;)
		{
			var how = deep.interpret(this.how, context);
			objs.push(deep.get(how, {
				root: context._deep_entry || context
			}));
		}
		if (typeof this.where === &quot;string&quot;) {
			var where = deep.interpret(this.where, context);
			objs.push(deep.get(where, {
				root: context._deep_entry || context,
				acceptQueryThis: true
			}));
		}
		return deep
		.all(objs)
		.done(function(results) {
			var what = (self.what) ? results.shift() : context;
			if (what._isDQ_NODE_) what = what.value;
			var how = (typeof self.how === &quot;string&quot;) ? results.shift() : self.how;
			var where = (typeof self.where === &quot;string&quot;) ? results.shift() : self.where;
			var r = &quot;&quot;;
			var nodes = self.nodes || null;
			try {
				r = how.apply({}, [what]);
				if (where) nodes = where(r, nodes);
			} catch (e) {
				console.log(&quot;Error while treating : &quot;, e);
				if (typeof self.fail === &#x27;function&#x27;)
					return self.fail.apply(context, [e]) || e;
				return e;
			}
			if (typeof self.done === &quot;function&quot;)
				return self.done.apply(context, [nodes, r, what]) || [nodes, r, what];

			return nodes || r;
		})
		.fail(function(error) {
			console.log(&quot;Error while treating : &quot;, error);
			if (typeof self.fail === &#x27;function&#x27;)
				return self.fail.apply(context, [error]) || error;
			return error;
		});
	};

	var stores = require( &quot;deep/deep-stores&quot; )(deep);

	var deepPromises = require(&quot;deep/deep-promise&quot;)(deep);
	return deep;

	//______________________________________________________________________________________________________________________________________
});






    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
