<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>deep-request.js - deepjs Javascript Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="deepjs Javascript Framework"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.rc</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/deep.html">deep</a></li>
            
                <li><a href="../classes/deep.Chain.html">deep.Chain</a></li>
            
                <li><a href="../classes/deep.collider.html">deep.collider</a></li>
            
                <li><a href="../classes/deep.collider.array.html">deep.collider.array</a></li>
            
                <li><a href="../classes/deep.collider.assert.html">deep.collider.assert</a></li>
            
                <li><a href="../classes/deep.collider.object.html">deep.collider.object</a></li>
            
                <li><a href="../classes/deep.compose.html">deep.compose</a></li>
            
                <li><a href="../classes/deep.Composer.html">deep.Composer</a></li>
            
                <li><a href="../classes/deep.deep.html">deep.deep</a></li>
            
                <li><a href="../classes/deep.Deferred.html">deep.Deferred</a></li>
            
                <li><a href="../classes/deep.Promise.html">deep.Promise</a></li>
            
                <li><a href="../classes/deep.Query.html">deep.Query</a></li>
            
                <li><a href="../classes/deep.Role.html">deep.Role</a></li>
            
                <li><a href="../classes/deep.roles.html">deep.roles</a></li>
            
                <li><a href="../classes/deep.store.html">deep.store</a></li>
            
                <li><a href="../classes/deep.store.Array.html">deep.store.Array</a></li>
            
                <li><a href="../classes/deep.store.Object.html">deep.store.Object</a></li>
            
                <li><a href="../classes/deep.store.Store.html">deep.store.Store</a></li>
            
                <li><a href="../classes/deep.stores.html">deep.stores</a></li>
            
                <li><a href="../classes/deep.stores.aspect.html">deep.stores.aspect</a></li>
            
                <li><a href="../classes/deep.stores.instance.html">deep.stores.instance</a></li>
            
                <li><a href="../classes/deep.stores.js.html">deep.stores.js</a></li>
            
                <li><a href="../classes/deep.stores.queryThis.html">deep.stores.queryThis</a></li>
            
                <li><a href="../classes/deep.utils.html">deep.utils</a></li>
            
                <li><a href="../classes/deep.Validator.html">deep.Validator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/deep.html">deep</a></li>
            
                <li><a href="../modules/deep-collider.html">deep-collider</a></li>
            
                <li><a href="../modules/deep-compose.html">deep-compose</a></li>
            
                <li><a href="../modules/deep-query.html">deep-query</a></li>
            
                <li><a href="../modules/deep-roles.html">deep-roles</a></li>
            
                <li><a href="../modules/deep-rql.html">deep-rql</a></li>
            
                <li><a href="../modules/deep-schema.html">deep-schema</a></li>
            
                <li><a href="../modules/deep-stores.html">deep-stores</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: deep-request.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @author Gilles Coomans &lt;gilles.coomans@gmail.com&gt;
 * DeepRequest : a set of useful function to retreieve ressources
 */
/**
 * TODO : DeepRequest.late.post(...) : return function which will do post later

crossDomainXML : add options with proxy or YQL

maintain cache for each reload seqquence : if in the same load bunch there is sam paths : use cache in place of retreieve multiple time the same file

protocole to add : 

data-model::
fs::




protocoles :

extensions : 

parsers : 

responseParser
	read reponse.headers.contentType : 
	
var jqueryRequest = function(info, options){
	options = options || {};
	var headers = options.headers || {};
	utils.up(this.requestHeaders, headers);
	var self = this;
	return promise.when($.ajax({
		beforeSend :function(req) {
			writeJQueryHeaders(req, headers);
		},
		url:info.uri, 
		method:&quot;GET&quot;, 
		data:null,
		datatype:self.options.datatype || &quot;json&quot;
	})
	.done(function (  data, msg, jqXHR ) {
		return self.parse(data, info, options);
	})
	.fail(function ( jqXHR ) {
		return new Error(&quot;DeepRequest.load failed : &quot;+JSON.stringify(info));
	}))
}
var setHeaders = function (req) {
	
}

var deepAction = {
	&quot;dom.appendTo&quot; : { // dom.appendTo::#id
		action:function (info, datas) {
			// body...
		}
	}
}

var vc = {
	placeInDOM:deep.action(&quot;dom.appendTo::#id&quot;)
}
var dr = {
	lexic:{
		json:{
			options:{
				queriable:true,
				datatype:&quot;json&quot;
			},
			requestHeaders:{
				&quot;accept&quot;:&quot;application/json;charset=utf-8&quot;
			},
			responseHeaders:{
				&quot;content-type&quot;:&quot;application/json;charset=utf-8&quot;
			},
			action:baseRequest,
			parse:function(response, infos, options) {
				// body...
			}
		},
		html:{
			options:{
				queriable:false,
				datatype:&quot;html&quot;
			},
			requestHeaders:{
				&quot;accept&quot;:&quot;text/html;charset=utf-8&quot;
			},
			responseHeaders:{
				&quot;content-type&quot;:&quot;text/html;charset=utf-8&quot;
			},
			action:baseRequest,
			parse:function(response, infos, options) {
				// body...
			}
		}
	},
	get:function (info, options) {
		if(typeof info === &#x27;string&#x27;)
			info = this.parse(info);
		var handler = this.lexic[info.protocole];
		if(!handler)
			throw new Error(&quot;DeepRequest : no handler found with : &quot;,info); 
		return handler.action(info, options);
	}
	all
	_______

	json
	xml
	rss
	text
	html

}


 */

var fs = null;
var HTTPRequest = null;
if(typeof define !== &#x27;function&#x27;)
{
	var define = require(&#x27;amdefine&#x27;)(module);
	fs = require(&quot;promised-io/fs&quot;);
	HTTPRequest = require(&quot;promised-io/http-client&quot;).request;
	var swig = require(&quot;swig&quot;);
	
}
var isNode = false;
if(typeof process !== &#x27;undefined&#x27; &amp;&amp; process.versions &amp;&amp; process.versions.node)
	isNode = true;

/*
	- ecrire la layer
	  	- backgrounds, etc
	- copier la layer dans l&#x27;objet final
	- appliquer le load sur l&#x27;objet final
	- appliquer le render et donc les protocles associés
	- appliquer le placeInDOM et donc les protocoles associés
*/

define(function(require){
//var Plates = require(&#x27;plates&#x27;);


	var loadInfo = {
		currentNumberOfLoad:0,
		paths:{},
		totalLoaded:0,
		totalToLoad:0,
		callCount:0
	};

	function removeLoadInfo(path){
	//	console.log(&quot;removeLoadInfo&quot;, path, loadInfo)

		loadInfo.paths[path]--;
		loadInfo.currentNumberOfLoad--;

		if(loadInfo.paths[path] == 0)
			delete loadInfo.paths[path];

		DeepRequest.handlers.loaded(path);
		if(loadInfo.currentNumberOfLoad == 0)
			DeepRequest.handlers.complete();
	}

	function addLoadInfo(path){
		loadInfo.callCount++;
		if(typeof loadInfo.paths[path] === &#x27;undefined&#x27;)
			loadInfo.paths[path] = 1;
		else
			loadInfo.paths[path]++;
		loadInfo.currentNumberOfLoad++;
		DeepRequest.handlers.added(path);

	}
	var reloadablesUriDico = {};
	var reloadablesRegExpDico = [ /^(json::)/gi ,/* /(\.json)$/gi */ ];
	var manageCache = function (response, uri) {
		if(reloadablesUriDico[uri])
			return;
		var count = 0;
		reg = reloadablesRegExpDico[count];
		while(reg &amp;&amp; !uri.match(reg))
			reg = reloadablesRegExpDico[++count];
		if(count == reloadablesRegExpDico.length)
			cache[uri] = response;
		//console.log(&quot;manag cache : &quot;, uri, &quot; - &quot;, response);
	}

	var cache = {};

	var utils = require(&quot;./utils&quot;);
	var promise = require(&quot;./promise&quot;);
	var Querier = require(&quot;./deep-query&quot;);
	var DeepRequest  = {
		reloadables:function (path, isReloadable /* false or true : true by default*/) 
		{
			if(typeof isReloadable === &#x27;undefined&#x27;)
				isReloadable = true;
			if(isReloadable)
			{
				if(path instanceof RegExp)
					reloadablesRegExpDico.push(path);
				else
					reloadablesUriDico[path] = true;
			}
			else
			{
				if(path instanceof RegExp)
				{
					var count = 0, ok = true, ln = reloadablesRegExpDico.length;
					while(count &lt; ln &amp;&amp; ok)
					{
						if(path.toString() === reloadablesRegExpDico[count].toString())
						{
							if(count == ln-1)
								reloadablesRegExpDico.pop();
							else
								reloadablesRegExpDico[count] = reloadablesRegExpDico.pop();
							ok = false;
						}
						count++;
					}
				}
				else
					reloadablesUriDico[path] = false;
			}
		},
		clearCache:function () 
		{
			cache = {};
		},
		lexic: {
			protocoles:{
				&quot;json&quot;:{
					headers:{
						Accept:&quot;application/json; charset=utf-8;&quot;
					},
					options:{
						queriable:true,
						callable:false
					},
					extensions:[&quot;json&quot;],
					parsers:{
						nodeHttpRequest:function(resolved)
						{
							if(typeof resolved === &quot;string&quot;)
								{
									if(parser)
									{
										resolved = parser(resolved);
									}
									//console.log(&quot;result is string : try parse&quot;)
									else
									{
										var p = null;
										try{
											p = JSON.parse(resolved);
										}catch(e){
											p = null;
										}
										if(p)
											resolved = p; 
									}
								//	console.log(&quot;createHTTPRequestParser : &quot;+method+&quot; -  after parsing/resolving : body ? &quot;, resolved)
								}
							return resolved;
						},
						&quot;default&quot;:function(data){
							if(typeof data === &#x27;string&#x27;)
								data = JSON.parse(data);
							return data;
						},
						nodeFS:function(value, charset){
							charset = charset || &quot;utf-8&quot;;
							return JSON.parse(value.toString(charset));
						}
					}
				},
				&quot;json.range&quot;:{
					&quot;backgrounds&quot;:[&quot;#../json&quot;],
					get:function(requestInfo, callerInfo){
						return DeepRequest.getRange();
					}
				},
				&quot;swig&quot;:{
					extensions:[&quot;html&quot;, &quot;swig&quot;, &quot;htm&quot;, &quot;xhtml&quot;],
					get:function(requestInfo, callerInfo){
						return DeepRequest.html(requestInfo);
					}
				},
				&quot;swig.macros&quot;:{
					parser:function(info, data){
						
					}
				},
				&quot;jquery.htmlOf&quot;:{
					get:function(info, data){
						return function(value){
							$(data).empty();
							return $(value).appendTo(data);	
						}
					}
				},
				&quot;jquery.appendTo&quot;:{
					get:function(info, data){
						return function(value){
							return $(value).appendTo(data);	
						}
					}
				},
				&quot;jquery.prependTo&quot;:{
					get:function(info, data){
						return function(value){
							return $(value).prependTo(data);	
						}
					}
				}
			}
		}
	}

/*
	json : 
		si uri : le choper, le parser + query: donne datas
		si pas uri :prendre query sur caller : donne datas (les parser si string)

	json.range 
		si uri : choper résultats par range : les parser si besoin + appliquer query sur chacun
		si pas uri : prendre query sur caller : donne datas (les parser si string), nchoper le range

	xml : 
		si uri : le choper, le parser + query (si un jour on a une query sur xml) : donne datas
		si pas uri : prendre query sur caller : donne datas, les parser en xml

	swig : 
		si uri : le choper, le parser (si un jour on a une query sur xml) : donne datas      PAS DE QUERY ICI
		si pas uri : prendre query sur caller : donne datas, les parser en swig si string, donne DATAS = function

	swig.macros
		si uri : choper son URL (immédiat),en faire un &quot;include marcos string&quot;, faire fonction qui print macro sur input
		si pas uri : choper son UR
		
*/

	DeepRequest.loadInfo = loadInfo;
	DeepRequest.handlers = {
		loaded:function(uri){
			//console.log(&quot;DeepRequest.loaded handlers : uri : &quot;, uri);
		},
		complete:function(){
			//console.log(&quot;DeepRequest.complete handlers&quot;);

		},
		added:function(uri){
			//console.log(&quot;DeepRequest.added handler : &quot;, uri);

		}
	};

	function manageEndOfRetrieve(info, datas)
	{
		// execute query if any
		// execute info.toCall and pass body

		// 
		return datas;
	}

	DeepRequest.get2 = function(info, callerInfo, headers)
	{
		var deferred = promise.Deferred();
		headers = headers || {};
		if(typeof info === &#x27;string&#x27;)
			info = DeepRequest.parse(info);
		if(!info.protocole)
			info.protocole = &quot;json&quot;;
		var protocole = DeepRequest.lexic.protocoles[info.protocole] || {};
		var parsers = protocole.parsers || {};
		if(!info.uri &amp;&amp; info.query)
		{
			data = Querier.query(callerInfo.callerRoot, info.query, callerInfo.callerPath );
			if(parsers[&quot;default&quot;])
				data = parsers[&quot;default&quot;](data);
			else
				data = DeepRequest.lexic.protocoles.json.parsers[&quot;default&quot;](data);
			return manageEndOfRetrieve(info, data);
		}
		
		if(info.body &amp;&amp; typeof info.body !== &#x27;string&#x27;)
			info.body = JSON.stringify(info.body);
		//console.log(&quot;deep-request.json : will get path : &quot;, path)
		deepCopy(protocole[info.protocole].headers || {}, headers, false);
		copyDefaultHeaders(headers);
		headers.Accept = headers.Accept || &quot;application/json;charset=utf-8&quot;;

		if(isNode)
		{	
			if(/http(s)?:\/\//.test(path))
			{
				HTTPRequest({
					method:&quot;GET&quot;,
					url:info.uri,
					//queryString: query,
					headers:options.headers
				}).then(function  (response) {
					createHTTPRequestParser(&quot;GET&quot;, response, parsers.nodeHttpRequest).then(function  (data) {
						//console.log(&quot;DeepRequest.json : HTTP Request result : &quot;, data)
						deferred.resolve(data);
					})
				}, function(){
					var args = Array.prototype.slice.call(arguments);
					deferred.reject(args);
				} );
			}
			else
			promise.when(fs.readFile(info.uri, options.charset)).then( 
				function(data){ 
					if(parsers.nodeFS)
						data = parsers.nodeFS(data);
					else
						data = JSON.parse(data.toString(options.charset));
					if(query)
						data = Querier.query(data, query,  { keepCache:false });
					deferred.resolve(data);
				}, 
				function(){
					var args = Array.prototype.slice.call(arguments);
					console.log(&quot;DeepRequest.json failed : &quot;+JSON.stringify(args));
					deferred.reject({msg:&quot;DeepRequest.json failed : &quot;+path, details:args, uri:path, options:options}); 
				}
			);
		}
		else 
			promise.when($.ajax({
				beforeSend :function(req) {
					writeJQueryHeaders(req, headers);
				},
				//contentType: &quot;application/json; charset=utf-8&quot;,
				url:info.uri, 
				method:&quot;GET&quot;, 
				//data:info.body||null,
				datatype:&quot;json&quot; 
			})).then(function(data, msg, jqXHR){
				if(parsers[&quot;default&quot;])
					data = parsers[&quot;default&quot;](data);
				else if(typeof data === &#x27;string&#x27;)
					data = JSON.parse(data);
				if(query)
					data = Querier.query(data, query,  { keepCache:false });
				//console.log(&quot;json success : &quot;, path, query, data);
				deferred.resolve(data);
			}, function(){ 
				var args = Array.prototype.slice.call(arguments);
				deferred.reject({msg:&quot;DeepRequest.get failed : &quot;+path, details:args, uri:path, options:options}); 
			})
		return promise.promise(deferred) ;
	}
	/*
	$.ajax({
			beforeSend :function(req) {
			req.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
			},
			contentType: &quot;application/json; charset=utf-8&quot;,
			url:this.context[i], 
			method:&quot;get&quot;, 
			data:{},
			datatype:&quot;json&quot; 
		})
	*/
	DeepRequest.setDefaultHeaders = function(headers)
	{
		//Json object that store the default headers
		this.defaultHeaders = headers;
	}
	var writeJQueryDefaultHeaders = function(req)
	{
		//Json object that store the default headers
		if(DeepRequest.defaultHeaders)
		{
			for(var header in DeepRequest.defaultHeaders){
				//console.log(&quot;DeepRequest Writing default headers : name = &quot;, header, &quot; value =&quot;, this.defaultHeaders[header]);
	            req.setRequestHeader(header, DeepRequest.defaultHeaders[header]);		
	        }
		}
	}

	var writeJQueryHeaders = function(req, headers)
	{
		//Json object that store the default headers
		if(headers)
		{
			for(var header in headers){
				//console.log(&quot;DeepRequest Writing default headers : name = &quot;, header, &quot; value =&quot;, this.defaultHeaders[header]);
	            req.setRequestHeader(header, headers[header]);		
	        }
		}
	}
	var copyDefaultHeaders = function(headers)
	{
		//Json object that store the default headers
		if(DeepRequest.defaultHeaders)
		{
			deepCopy(DeepRequest.defaultHeaders, headers, false);
		}
	}

	DeepRequest.exec = function(request, callerInfo, headers)
	{
		var info = request;
		if(typeof info === &#x27;string&#x27;)
			info = DeepRequest.parse(info);

		
		if(!info.uri &amp;&amp;  info.query)
			var data = Querier.query(callerInfo.callerRoot, info.query, callerInfo.callerPath );
			
		
		var protocole = DeepRequest.lexic.protocole[request.protocole];
		if(!protocole)
			return request;
		var def = promise.Deferred();
		if(protocole.get)
			promise.when(protocole.get(info, headers)).then(function(result){

			}, function(error){
				def.reject(error);
			})
		else
			promise.when(DeepRequest.get2(info, headers)).then(function(result){

			}, function(error){
				def.reject(error);
			});
		return promise.promise(def);
	}

	DeepRequest.parse = function(request)
	{
		//if(request == &quot;instance::autobahn/stores/remote-rest&quot;);
		//console.log(&quot;DeepRequest.parse : &quot;, request)
		var info = {
			type:null, // deprecated, use protocole instead
			request:request,
			uri:null,
			protocole:null,
			protocoleArguments:null,
			query:null,
			body:null,
			toCall:null,
			extension:null
		};
		if(typeof request === &#x27;undefined&#x27;) 
		{
			info.protocole = info.type = &quot;function&quot;;
			info.uri = request;
			return info;
		}
		if(typeof request !== &#x27;string&#x27;)
		{
			info.uri = request;
			return info;
		}	
		var rest = request;
		var index = rest.indexOf(&quot;::&quot;);
		if(index &gt; -1)
		{
			var protoc = rest.substring(0, index);
			rest = request.substring(index+2);
			var matched = protoc.match(/([-a-z0-9_\.]+)|(\([^\)]+\))/gi);
			//console.log(&quot;matching handlers on protocole : &quot;, matched)
			info.protocole = info.type = matched.shift();
			if(matched.length&gt;0)
			{
				info.protocoleArguments = [];
				var args = matched.shift();
				args = args.substring(1,args.length-1);
				args = args.split(&quot;,&quot;);
				//console.log(&quot;got protocole handler args : &quot;, args)
				args.forEach(function(arg){
					if(arg[0] == &quot;&#x27;&quot; || arg[0] == &#x27;&quot;&#x27;)
						arg = arg.substring(1,arg.length-1);
					else
						arg = parseFloat(arg);
					info.protocoleArguments.push(arg);
				});
			}
		}
		info.uri = null;
		var matched = rest.match(/([^#@§]+)|(§.+)|(@[^§]+)|(#[^@§]+)/gi);
		//console.log(&quot;protocole parsed : matched rest : &quot;, matched);
		matched.forEach(function(m){
			switch(m[0])
			{
				case &quot;#&quot; : info.query = m.substring(1); break;
				case &quot;@&quot; : info.toCall = m.substring(1); break;
				case &quot;§&quot; : info.body = m.substring(1); break;
				default:
					info.uri = m;
					var ext = m.substring(m.length-Math.min(6, m.length));
					var indexOfPoint = ext.indexOf(&quot;.&quot;);
					if(indexOfPoint &gt; -1)
						info.extension = ext.substring(indexOfPoint+1);
					if(info.extension &amp;&amp; !info.protocole)
						info.protocole = info.type = info.extension;
			}
		})
		switch(info.protocole)
		{
			case &quot;first&quot; : 
				info.subquery = &quot;first&quot;;
				break;
			case &quot;last&quot; : 
				info.subquery = &quot;last&quot;;
				break;
			case &quot;index&quot; : 
				info.subquery = &quot;index&quot;;
			break;
		}
	//	console.log(&quot;got info : &quot;, info);
		if(info.query &amp;&amp; !info.uri)
			info.type = info.protocole = &quot;queryThis&quot;;
		return info;
	}

	DeepRequest.retrieveAll = function(uris, options)
	{
		if(typeof uris.push != &quot;function&quot;)
			return null;
		var loads = [];
		uris.forEach(function(e){
			loads.push(DeepRequest.retrieve(e, options));
		})
		return promise.all(loads);
	}

	DeepRequest.retrieve = function(uri, options)
	{
		options = options || {};

		var queryBasePath = options.basePath || null;
		var othis = options.root || function(){};

		var info = DeepRequest.parse(uri);
		if(console.flags[&quot;deep-request&quot;]) 
			console.log(&quot;deep-request&quot;, &quot;retrieve : &quot;,info, &quot; -   from : &quot;+uri);
		if(info.protocole == &quot;queryThis&quot; &amp;&amp; !options.acceptQueryThis)
			throw new Error(&quot;you couldn&#x27;t use queryThis protocole in that case&quot;);

		if(cache[uri])
			return cache[uri];

		switch(info.type)
		{
			case &quot;json&quot; : 
				if(!info.range)
					return DeepRequest.json(info.uri, info.query, othis);
				else
					return DeepRequest.retrieveRange(info);
				break;
			case &quot;xml&quot; : 
				return DeepRequest.xml(info.uri);
				break;

			case &quot;text&quot; : 
				return DeepRequest.text(info);
				break;
			case &quot;html&quot; : 
				return DeepRequest.html(info);
				break;
			case &quot;swig&quot; : 
				var defs = promise.Deferred();
				DeepRequest.html(info.uri).then(function (data) {
					//console.log(&quot;retrieve swig : html result: &quot;, data);
					var resi = swig.compile(data, { filename:utils.stripFirstSlash(info.uri) }); 
					delete cache[info.uri];
					manageCache(resi, info.request);
					//console.log(&quot;compiled swig : &quot;, resi)
					defs.resolve(resi);
				}, function(){
					var args = Array.prototype.slice.call(arguments);
					defs.reject({ emiter:&quot;deep-request&quot;, msg:&quot;retrieve swig failed for path : &quot;+info.uri, details:args, basePath:uri });
				});
				return promise.promise(defs) ;
				break;
			/*	
			case &quot;plates&quot; : 
				var defs = promise.Deferred();
				DeepRequest.html(info.uri).then(function (html) {
					var res = function(data, map){
						return  Plates.bind(html, data, map)
					}
					delete cache[info.uri];
					manageCache(res, info.request);
					defs.resolve(res);
				}, function(){
					var args = Array.prototype.slice.call(arguments);
					defs.reject({ emiter:&quot;deep-request&quot;, msg:&quot;retrieve plates failed for path : &quot;+info.uri, details:args, basePath:uri });
				});
				return promise.promise(defs) ;
				break;
				*/
			case &quot;js&quot; : 
				if(info.query)
				{
					var def = promise.Deferred();
					promise.when(require(info.uri)).then(function(res){
						var resi  = Querier.query(res, info.query, { keepCache:false });
						//manageCache(resi, info.request);
						def.resolve(resi)
					}, function(res){
						def.reject(res);
					});
					return promise.promise(def);
				}
				else
					return promise.when(require(info.uri));
				break;   // use require to load lib
			case &quot;aspect&quot; : 
				var def = promise.Deferred();
				promise.when(require(info.uri)).then(function(res){
					def.resolve(res.aspect)
				}, function(res){
					def.reject(res);
				});
				return promise.promise(def);
				break;   // use require to load lib
			case &quot;instance&quot; : 
				var cl = require(info.uri);
				//console.log(&quot;DeepRequest.instance : &quot;, cl);
				if(typeof cl === &#x27;function&#x27; &amp;&amp; cl.prototype)
					return new cl();
				console.log(&quot;DeepRequest : could not instanciate : &quot;+JSON.stringify(info))
				throw new Error(&quot;DeepRequest : could not instanciate : &quot;+JSON.stringify(info))
				break;   // use require to load lib
			case &quot;eval&quot; : 
				return eval(info.uri);
				break;   // use require to load lib
			case &quot;func&quot; : 
				return new Function(info.uri); 
				break;   // use require to load lib
			case &quot;function&quot;:
				//console.log(&quot;DeepRequest.retrieve:function : &quot;, options.dontCallFunctions, info.uri);
				if(options.callFunctions)
					return info.uri();
				return info.uri;
				break;
			case &quot;dummies&quot; : 
				return DeepRequest.json(info.uri, info.query, othis);
				break;

			case &quot;queryThis&quot; : 
				//console.log(&quot;DeepRequest.queryThis : &quot;, othis, info.query)
				//queryBasePath += othis.path || &#x27;&#x27;;
				var res = null;
				if(othis._isDQ_NODE_)
				{
					res = Querier.query(othis, info.query, { keepCache:false });
				}
				else
				{
					queryBasePath = queryBasePath || &#x27;&#x27;;
					var q = info.query;
					res = Querier.query(othis, info.query, { keepCache:false });
				}
				
				if(res)
					switch(info.subquery)
					{
						case &quot;first&quot; : 
							res = res[0] || null;
							break;
						case &quot;last&quot; : 
							res = res[res.length-1] || null;
							break;
						case &quot;index&quot; :
							if(info.protocoleArguments)
								res = res[+info.protocoleArguments[0]] || null;
							break;
						default : ;
					}
				//if(queryBasePath != &#x27;&#x27; &amp;&amp; q.substring(0,3) == &quot;../&quot;)
				//	q = ((queryBasePath[queryBasePath.length-1] != &quot;/&quot;)?(queryBasePath+&quot;/&quot;):queryBasePath)+info.query;
			//	console.log(&quot;QUERY THIS : &quot;+q + &quot; - base path : &quot;+queryBasePath, &quot; - results : &quot;, JSON.stringify(res, null, &#x27; &#x27;))
				return res;
			default:
				if(!info.protocole &amp;&amp; !info.uri &amp;&amp; info.query)
				{
					//console.log(&quot;DeepRequest.queryThis but no protocole : &quot;, othis, info.query)
					if(!options.acceptQueryThis)
						throw new Error(&quot;you couldn&#x27;t use queryThis protocole in that case&quot;);
					//console.log(&quot;DeepRequest.queryThis : &quot;, othis, info.query)
					var res = null;
					if(othis._isDQ_NODE_)
					{
						res = Querier.query(othis, info.query, { keepCache:false });
					}
					else
					{
						queryBasePath = queryBasePath || &#x27;&#x27;;
						var q = info.query;
						res = Querier.query(othis, info.query, { keepCache:false });
					}
				//	console.log(&quot;QUERY THIS : &quot;+q + &quot; - base path : &quot;+queryBasePath, &quot; - results : &quot;, JSON.stringify(res, null, &#x27; &#x27;))
					return res;
				}
				//console.log(&quot;unretrievable object : return it : &quot;, uri)
				return uri;
			//	console.log(&quot;unrecognised extension in ContextLoader.load()&quot;);
		}
		return null;
	}

	DeepRequest.jsons = function(paths, query, othis)
	{
		var deferred = promise.Deferred();
		var arr = new Array();
		paths.forEach(function(path){
			arr.push(DeepRequest.json(path));
		})
		promise.all(arr).then(function(result){
			var res = [];
			var count = 0;
			if(query)
				result.forEach(function(e){
					var data = Querier.query(data, query, { keepCache:false });
					if(data &amp;&amp; data.length &gt; 0)
						res.push(data);
					manageCache(data, paths[count++]);
				});
			else
				res = result;

			deferred.resolve(res);
		}, function(error){ deferred.reject((&quot;DeepRequest.jsons faileds : &quot;, error)); })
		return promise.promise(deferred) ;
	}

	
	function createHTTPRequestParser(method, response, parser)
	{
		//console.log(&quot;createHTTPRequestParser: &quot;+method+&quot; - direct response from remote  : &quot;, response.status, &quot; body : &quot;, response.body)
		var r = {
			status:response.status,
			body:&quot;&quot;,
			__isRemoteResponse__:true
		}
		var def = promise.Deferred();
		promise.when(response.body.join(&#x27;&#x27;)).then(function(resolved){
			//console.log(&quot;createHTTPRequestParser : body.join resolved: &quot;, resolved)
			if(typeof resolved === &quot;string&quot;)
			{
				if(parser)
				{
					resolved = parser(resolved);
				}
				//console.log(&quot;result is string : try parse&quot;)
				else
				{
					var p = null;
					try{
						p = JSON.parse(resolved);
					}catch(e){
						p = null;
					}
					if(p)
						resolved = p; 
				}
				
			//	console.log(&quot;createHTTPRequestParser : &quot;+method+&quot; -  after parsing/resolving : body ? &quot;, resolved)
			}
			r.body = resolved;
			def.resolve(r.body);
		}, function(r){
			console.log(&quot;createHTTPRequestParser : body.join error : &quot;, resolved)
			def.reject(r);
		});
		return promise.promise(def);
	}

	DeepRequest.json = function(path, othis, options)
	{
		var body = null;
		var query = null;
		if(typeof path === &#x27;object&#x27;)
		{
			var info = path;
			path = info.uri;
			query = info.query;
			body = info.body;
		}
		if(typeof body !== &#x27;string&#x27;)
		{
			body = JSON.stringify(body);
		}
		//console.log(&quot;deep-request.json : will get path : &quot;, path)
		var deferred = promise.Deferred();
		if(isNode)
		{	
			if(/http(s)?:\/\//.test(path))
			{
				HTTPRequest({
					method:&quot;GET&quot;,
					url:path,
					//queryString: query,
					headers: {
						Accept:&quot;application/json;charset=utf-8;&quot;

					}
				}).then(function  (response) {
					// body...
					createHTTPRequestParser(&quot;GET&quot;, response).then(function  (data) {
						// body...
						console.log(&quot;DeepRequest.json : HTTP Request result : &quot;, data)
						deferred.resolve(data);

					})

				}, function(){
					var args = Array.prototype.slice.call(arguments);
					deferred.reject(args);

				} );
			}
			else
			{
				function getFacet(path){
					//console.log(&quot;getFacet : &quot;, path)
					if(DeepRequest.autobahn)
					{
						//console.log(&quot;deep-request have autobahn link&quot;)
						var role = DeepRequest.autobahn.compileRoles([&quot;public&quot;]);
						promise.when(role).then(function (role) {
						//	console.log(&quot;getFacet in deep-request.json : &quot;, role)
							var splitted = path.split(&#x27;/&#x27;);
							var serviceName = splitted[1];
							var id = splitted[2]
							if(role.facets[serviceName])
							{
								//console.log(&quot;got service with this name : &quot;, serviceName, &quot; - id ? &quot;, id)
								var method = &quot;get&quot;;
								if(!id || id == &quot;&quot;)
									method = &quot;query&quot;;
								promise.when(role.facets[serviceName][method](id)).then(function (data) {
									//console.log(&quot;results from service : &quot;, data)
									if(query)
										data = Querier.query(data.toString(), query,  { keepCache:false });
									deferred.resolve(data);
								}, function  (error) {
									var args = Array.prototype.slice.call(arguments);
									deferred.reject({msg:&quot;DeepRequest.json failed : &quot;+path, details:args, uri:path}); 
								});
							}
							else
							{
								//console.log(&quot;don&#x27;t found service &quot;, serviceName, &quot; - try from fs : &quot;, path)
								DeepRequest.autobahn.getFile(path, &quot;json&quot;).then(function (data) {
									if(typeof data === &#x27;string&#x27;)
										data = JSON.parse(data.toString(&quot;utf-8&quot;));
									//console.log(&quot;deep request node json loadsuccess from autobahn : &quot;, data)
									if(query)
										data = Querier.query(data.toString(), query,  { keepCache:false });
									//else 
									//	data = data.toString(); 
									deferred.resolve(data);
								}, 
								function(){
									var args = Array.prototype.slice.call(arguments);
									console.log(&quot;DeepRequest.json failed : &quot;+JSON.stringify(args));
									deferred.reject({msg:&quot;DeepRequest.json failed : &quot;+path, details:args, uri:path}); 
								});
							}
						});
					}
					else
						DeepRequest.autobahn.getFile(path, &quot;json&quot;).then(function (data) {
							if(typeof data === &#x27;string&#x27;)
								data = JSON.parse(data.toString(&quot;utf-8&quot;));
							//console.log(&quot;deep request node json loadsuccess from autobahn : &quot;, data)
							if(query)
								data = Querier.query(data.toString(), query,  { keepCache:false });
							//else 
							//	data = data.toString(); 
							deferred.resolve(data);
						}, 
						function(){
							var args = Array.prototype.slice.call(arguments);
							console.log(&quot;DeepRequest.json failed : &quot;+JSON.stringify(args));
							deferred.reject({msg:&quot;DeepRequest.json failed : &quot;+path, details:args, uri:path}); 
						});
				}
				getFacet(path);
			}
		}
		else {
			$.ajaxSetup({
			   jsonp: null,
			   jsonpCallback: null
			});
			promise.when($.ajax({
				beforeSend :function(req) {
					writeJQueryDefaultHeaders(req);
					req.setRequestHeader(&quot;Accept&quot;, &quot;application/json; charset=utf-8&quot;);
					//console.log(&quot;INFO. JSON = &quot;+ JSON.stringify(path));

				},
				contentType: &quot;application/json; charset=utf-8&quot;,
				url:path, 
				method:&quot;GET&quot;, 
				//data:body||null,
				datatype:&quot;json&quot; 
			}))
			.done(function(data, msg, jqXHR){
			//	console.log(&quot;deep.request.json response : &quot;, data)
				if(typeof data === &#x27;string&#x27;)
					data = JSON.parse(data);
				if(query)
					data = Querier.query(data, query,  { keepCache:false });
				//console.log(&quot;json success : &quot;, path, query, data);
				manageCache(data, path);
				deferred.resolve(data);
			})
			.fail( function(){ 
				var args = Array.prototype.slice.call(arguments);
				console.log(&quot;deep.request.json error : &quot;, arguments)
				deferred.reject(new Error(&quot;DeepRequest.json failed : &quot;+path+&quot; - \n\n&quot;+JSON.stringify(args))); 
			})
		}
		return promise.promise(deferred) ;
	}



	DeepRequest.html = function(path)
	{
		var body = null;
		var query = null;
		if(typeof path === &#x27;object&#x27;)
		{
			var info = path;
			path = info.uri;
			query = info.query;
			body = info.body;
		}
		var deferred = promise.Deferred();

		if(isNode)
		{
			if(/http(s)?:\/\//.test(path))
			{
				HTTPRequest({
					method:&quot;GET&quot;,
					url:path,
					//queryString: query,
					headers: {
						Accept:&quot;application/json;charset=utf-8;&quot;

					}
				}).then(function  (response) {
					// body...
					createHTTPRequestParser(&quot;GET&quot;, response).then(function  (data) {
						// body...
						//console.log(&quot;DeepRequest.json : HTTP Request result : &quot;, data)
						deferred.resolve(data);

					})

				}, function(){
					var args = Array.prototype.slice.call(arguments);
					deferred.reject(args);
				} );
			}
			else
			{
				DeepRequest.autobahn.getFile(path, &quot;html&quot;).then(function (data) {
					//data = JSON.parse(data.toString(&quot;utf-8&quot;));
					//else 
					//	data = data.toString(); 
					deferred.resolve(data);
				}, 
				function(){
					var args = Array.prototype.slice.call(arguments);
					console.log(&quot;DeepRequest.html failed : &quot;+JSON.stringify(args));
					deferred.reject({msg:&quot;DeepRequest.json failed : &quot;+path, details:args, uri:path}); 
				});
			/*	promise.when(fs.readFile(path, &quot;utf-8&quot;)).then( 
					function(data){ 
						deferred.resolve(data.toString()); 
					}, 
					function(msg){
						deferred.reject((&quot;DeepRequest.html failed : &quot;+JSON.stringify(msg)));
					}
				);*/
			}
		}
			
		else
			$.when($.ajax({
				beforeSend :function(req) {
					req.setRequestHeader(&quot;Accept&quot;, &quot;text/plain; charset=utf-8&quot;);
				},
				contentType: &quot;text/plain; charset=utf-8&quot;,
				url:path, 
				method:&quot;get&quot;, 
				//data:body||null,
				datatype:&quot;html&quot; 
			})).then(
				function(data, msg, jqXHR){
					manageCache(data, path);

					deferred.resolve(data);
				}, 
				function(msg){ 
					deferred.reject((&quot;DeepRequest.html failed : &quot;+JSON.stringify(msg)));
				}
			)
		return promise.promise(deferred) ;
	}
	DeepRequest.xml = function(path)
	{
		var body = null;
		var query = null;
		if(typeof path === &#x27;object&#x27;)
		{
			var info = path;
			path = info.uri;
			query = info.query;
			body = info.body;
		}
		var deferred = promise.Deferred();
		if(isNode)
			promise.when(fs.readFile(path, &quot;utf-8&quot;)).then( 
				function(data){ 
					deferred.resolve( data.toString() ); 
				}, 
				function(msg){
					var args = Array.prototype.slice.call(arguments);
					console.log(&quot;DeepRequest.xml failed : &quot;+JSON.stringify(args));
					deferred.reject({msg:&quot;deep-request : xml load failed &quot;, arguments:args});
					
				}
			);
		else
		 promise.when($.ajax({
			beforeSend :function(req) {
			req.setRequestHeader(&quot;Accept&quot;, &quot;application/xml&quot;);
			},
			contentType: &quot;aplication/xml; charset=utf-8&quot;,
			url:path, 
			method:&quot;get&quot;, 
			//data:body||null,
			datatype:&quot;xml&quot; 
		})).then(function(data){
			data = jQuery.parseXML(data);
			manageCache(data, path);
			deferred.resolve(data);
		}, function(jqXHR){
			var args = Array.prototype.slice.call(arguments);
			console.log(&quot;DeepRequest.xml failed : &quot;+JSON.stringify(args));
			deferred.reject({msg:&quot;deep-request : xml load failed &quot;, arguments:args});
		});
		return promise.promise(deferred);
	}

	DeepRequest.rss = function(url)
	{
		var def = promise.Deferred();
	 	//console.log(&quot;requestCrossDomain : &quot;, url);
	    // Take the provided url, and add it to a YQL query. Make sure you encode it!
	    //var yql = &#x27;http://query.yahooapis.com/v1/public/yql?q=&#x27; + encodeURIComponent(&#x27;select * from xml where url=&quot;&#x27; + url + &#x27;&quot;&#x27;) + &#x27;&amp;format=xml&amp;callback=?&#x27;;
	    var google = (document.location.protocol||&quot;http:&quot;) + &#x27;//ajax.googleapis.com/ajax/services/feed/load?v=1.0&amp;num=10&amp;callback=?&amp;q=&#x27; + encodeURIComponent(url);
	    // Request that YSQL string, and run a callback function.
	    // Pass a defined function to prevent cache-busting.
	 	 addLoadInfo(url);
	 	 var succ = function (data) {
	 	 	var res = null;

			if(data.responseData)
	      	{
	      	 	res = data.responseData.feed;
				manageCache(res, url);
	        	def.resolve(res);
	      		return;
	      	}
	        def.reject({msg:&quot;deep-request : rss load failed &quot;+url, arguments:arguments});
	 	 }
	    $.getJSON(google).then(function(data, msg, jqXHR){
	    	removeLoadInfo(url);
	    	succ(data)
	      	//console.log(&quot;no responseData : &quot;+url, JSON.stringify(data, null, &#x27; &#x27;))
	    }, function(data, msg, jqXHR){

	    	removeLoadInfo(url);
	    	if(jqWHR.status &lt;400)
	    		console.log(&quot;WARNING : error but success with jquery/rss google : &quot;, jqXHR)
	    	def.reject({msg:&quot;deep-request : rss load failed &quot;+url, arguments:arguments});
	    });
		return promise.promise(def);
	}



	DeepRequest.text = function(path)
	{
		return DeepRequest.get(path, {accept:&quot;text/plain;charset=utf-8;&quot;});
	}

	DeepRequest.get = DeepRequest.retrieve;

	DeepRequest.put = function(uri, object)
	{
		var info = DeepRequest.parse(uri);
		var deferred = promise.Deferred();
		 $.ajax({
			type:&quot;PUT&quot;,
			beforeSend :function(req) {
				writeJQueryDefaultHeaders(req);
				req.setRequestHeader(&quot;Accept&quot;, &quot;application/json; charset=utf-8&quot;);
			},
			url:info.uri,
			dataType:&quot;application/json&quot;,
			contentType:&quot;application/json; charset=utf-8&quot;,
			data:JSON.stringify(object)
		}).then(function  (res) {
			// body...
			console.log(&quot;DeepRequest.put : success : &quot;, res)
			deferred.resolve(res);
		}, function  (jqXHR, textStatus, errorThrown) {
			var test = $.parseJSON(jqXHR.responseText);
			if(jqXHR.status &lt; 300)
			{
				console.log(&quot;DeepRequest.put : error but status 2xx : &quot;, test, &quot; - status provided : &quot;+jqXHR.status);
				if(typeof test === &#x27;string&#x27;)
					test = $.parseJSON(test);
				deferred.resolve(test);
			}
			else
			{
				var args = Array.prototype.slice.call(arguments);
				console.log(&quot;DeepRequest.put : failed (status &gt; 2xx) : &quot;, test, &quot; - status provided : &quot;, jqXHR.status )
				deferred.reject({msg:&quot;DeepRequest.put failed : &quot;+info.request, status:jqXHR.status, details:args, uri:info.uri})
			}
			// body...
		})
		return promise.promise(deferred);
		
	}
	DeepRequest.rpc = function(uri, method, params)
	{
		var callId = &quot;call&quot;+new Date().valueOf();
		var deferred  = promise.Deferred();
		  $.ajax({
			beforeSend :function(req) {
				writeJQueryDefaultHeaders(req);
				req.setRequestHeader(&quot;Accept&quot;, &quot;application/json; charset=utf-8;&quot;);
			},
			type:&quot;POST&quot;,
			url:uri,
			dataType:&quot;application/json-rpc; charset=utf-8;&quot;,
			contentType:&quot;application/json-rpc; charset=utf-8;&quot;,
			data:JSON.stringify({
				id:callId,
				method:method,
				params:params||[]
			})
		}).then(function  (res) {
			console.log(&quot;DeepRequest.rpc : success : &quot;, res)
			deferred.resolve(res);
		}, function  (jqXHR, textStatus, errorThrown) {
			var test = $.parseJSON(jqXHR.responseText);
			if(jqXHR.status &lt; 300)
			{
				//console.log(&quot;DeepRequest.post : error but status 2xx : &quot;, test, &quot; - status provided : &quot;+jqXHR.status);
				if(typeof test === &#x27;string&#x27;)
					test = $.parseJSON(test);
				deferred.resolve(test);
			}
			else
			{
				//console.log(&quot;DeepRequest.post : failed (status &gt; 2xx) : &quot;, test, &quot; - status provided : &quot;, jqXHR.status )
				var args = Array.prototype.slice.call(arguments);
				deferred.reject({msg:&quot;DeepRequest.post failed : &quot;+uri, status:jqXHR.status, details:args, uri:uri})
			}
			// body...
		})


		return promise.promise(deferred);
	}

	DeepRequest.post = function(uri, object)
	{
		var info = DeepRequest.parse(uri);
		var deferred  = promise.Deferred();
		  $.ajax({
			beforeSend :function(req) {
				writeJQueryDefaultHeaders(req);
				req.setRequestHeader(&quot;Accept&quot;, &quot;application/json; charset=utf-8;&quot;);
			},
			type:&quot;POST&quot;,
			url:info.uri,
			dataType:&quot;application/json; charset=utf-8;&quot;,
			contentType:&quot;application/json; charset=utf-8;&quot;,
			data:JSON.stringify(object)
		}).then(function  (res) {
			// body...
			console.log(&quot;DeepRequest.post : success : &quot;, res)
			deferred.resolve(res);
		}, function  (jqXHR, textStatus, errorThrown) {
			var test = $.parseJSON(jqXHR.responseText);
			if(jqXHR.status &lt; 300)
			{
				//console.log(&quot;DeepRequest.post : error but status 2xx : &quot;, test, &quot; - status provided : &quot;+jqXHR.status);
				if(typeof test === &#x27;string&#x27;)
					test = $.parseJSON(test);
				deferred.resolve(test);
			}
			else
			{
				//console.log(&quot;DeepRequest.post : failed (status &gt; 2xx) : &quot;, test, &quot; - status provided : &quot;, jqXHR.status )
				var args = Array.prototype.slice.call(arguments);
				deferred.reject({msg:&quot;DeepRequest.post failed : &quot;+info.request, status:jqXHR.status, details:args, uri:info.uri})
			}
			// body...
		})


		return promise.promise(deferred);
	}

	DeepRequest.patch = function(uri, object)
	{
		var info = DeepRequest.parse(uri);
		var deferred  = promise.Deferred();
		  $.ajax({
			beforeSend :function(req) {
				writeJQueryDefaultHeaders(req);
				req.setRequestHeader(&quot;Accept&quot;, &quot;application/json; charset=utf-8;&quot;);
			},
			type:&quot;PATCH&quot;,
			url:info.uri,
			dataType:&quot;application/json; charset=utf-8;&quot;,
			contentType:&quot;application/json; charset=utf-8;&quot;,
			data:JSON.stringify(object)
		}).then(function  (res) {
			// body...
			console.log(&quot;DeepRequest.patch : success : &quot;, res)
			deferred.resolve(res);
		}, function  (jqXHR, textStatus, errorThrown) {
			var test = $.parseJSON(jqXHR.responseText);
			if(jqXHR.status &lt; 300)
			{
				//console.log(&quot;DeepRequest.post : error but status 2xx : &quot;, test, &quot; - status provided : &quot;+jqXHR.status);
				if(typeof test === &#x27;string&#x27;)
					test = $.parseJSON(test);
				deferred.resolve(test);
			}
			else
			{
				//console.log(&quot;DeepRequest.post : failed (status &gt; 2xx) : &quot;, test, &quot; - status provided : &quot;, jqXHR.status )
				var args = Array.prototype.slice.call(arguments);
				deferred.reject({msg:&quot;DeepRequest.patch failed : &quot;+info.request, status:jqXHR.status, details:args, uri:info.uri})
			}
		})
		return promise.promise(deferred);
	}

	DeepRequest.deleteItems = function(uri, ids)
	{
		var info = DeepRequest.parse(uri);

		if(typeof rql === &#x27;undefined&#x27;)
			rql = &quot;&quot;;
		return $.ajax({
			type:&quot;POST&quot;,
			url:info.uri,
			dataType:&quot;message/json&quot;,
			contentType:&quot;application/json; charset=utf-8&quot;
			//data:JSON.stringify(object)
		})
	}

	DeepRequest.retrieveRange = function(info){
		//console.log(&quot;__________________retrieve range : &quot;, uri, &quot; - &quot;, range)
		var type = info;//DeepRequest.isRetrievable(uri);
		var deferred = promise.Deferred();
		function success(jqXHR, data){
			//console.log(&quot;argyuments : &quot;, arguments)
			var rangePart = [];
			var rangeResult = {};

			var resultsArray = [];

			if(type.type == &quot;dummies&quot;)
			{
				var range = info.range;
				//console.log(&quot;getRange success dummies&quot;);
				if(!data.push){
					data = [data];
				}
				rangeResult.totalCount = data.length;
				//verif si le range ne dépasse pas le max
				if(range.end &lt;= data.length)
				{
					rangeResult.range = range.start + &quot;-&quot; + range.end ;
					for (var i = 0; i &lt; data.length; i++) {
						if(i &gt;= range.start &amp;&amp;  i &lt;= range.end)
							resultsArray.push( data[i] );
					};
				} else {
					//le range dépasse , on renvoi toutes les datas par defaut + un log
					resultsArray = data;
					console.log(&quot;ERROR deep-request.retrieveRange range is higher then dummies array - giving all Array by default !! &quot;);
				}
				
			} else {
				
				var headers = jqXHR.getResponseHeader(&quot;content-range&quot;);
				headers = headers.substring(6);
				//console.log(&quot;browse ajax rrsult : headers &quot; + JSON.stringify(headers))
				
				if(headers)
					rangePart = headers.split(&#x27;/&#x27;);

				if(headers &amp;&amp; rangePart &amp;&amp; rangePart.length &gt; 0) 
				{
					rangeResult.range = rangePart[0];
					if(rangeResult.range == &quot;0--1&quot;)
					{
						rangeResult.totalCount = 0;
						rangeResult.start = 0;
						rangeResult.end = 0;
					}
					else
					{
						rangeResult.totalCount = parseInt(rangePart[1]);
						var spl = rangePart[0].split(&quot;-&quot;);
						rangeResult.start = parseInt(spl[0]);
						rangeResult.end = parseInt(spl[1]);
					}
				} else {
					console.log(&quot;ERROR deep-request.retrieveRange range header missing !! &quot;);
				}
				resultsArray = data;
				//console.log(&quot;getRange success not dummies : &quot;, rangeResult, resultsArray.length);
			}
			deferred.resolve({
					results : resultsArray,
					range : rangeResult
			});
		}
		$.ajax({
			beforeSend :function(req) {
				req.setRequestHeader(&quot;Accept&quot;, &quot;application/json; charset=utf-8&quot;);
				req.setRequestHeader(&quot;range&quot;, &quot;items=&quot; + info.range.start+&quot;-&quot;+info.range.end);	
			},
			type:&quot;GET&quot;,
			url:info.uri,
			dataType:&quot;application/json&quot;,
			contentType:&quot;application/json; charset=utf-8&quot;

		}).then(function(data, text, jqXHR) {
			success(jqXHR, data);
		}, function  (jqXHR, statusText, errorThrown) {
			//console.log(&quot;get range failed : &quot;, jqXHR)
			var args = Array.prototype.slice.call(arguments);
			if(jqXHR.status == 200 || jqXHR.status == 206)
				success(jqXHR, JSON.parse(jqXHR.responseText));
			else
				deferred.reject(args);
		});
		return promise.promise(deferred);
	}

	DeepRequest.crossDomainXML= function(url, type)
	{
		var def = promise.Deferred();
	 	//console.log(&quot;requestCrossDomain : &quot;, url);
	    // Take the provided url, and add it to a YQL query. Make sure you encode it!
	    var yql = &#x27;http://query.yahooapis.com/v1/public/yql?q=&#x27; + encodeURIComponent(&#x27;select * from xml where url=&quot;&#x27; + url + &#x27;&quot;&#x27;) + &#x27;&amp;format=xml&amp;callback=?&#x27;;
	    // Request that YSQL string, and run a callback function.
	    // Pass a defined function to prevent cache-busting.
	    $.getJSON(yql).then(function(data){
			var args = Array.prototype.slice.call(arguments);
	    	if (data.results[0])
	    	{
	    		var res = null;
	    		switch(type)
	    		{
	    			case &quot;xml&quot; : 
	    			res = $.parseXML(data.results);
	    			break;
	    			case &quot;rss&quot; : 
	    			res = new JFeed($.parseXML(data.results));
	    			break;
	    			default :
	        			def.reject({msg:&quot;deep-request : cross domain xml load failed : bad type provided : &quot;+type, arguments:args});
	    		} 
					manageCache(res, path);
	                def.resolve(res);
	        }else
	        	def.reject({msg:&quot;deep-request : cross domain xml load failed &quot;, arguments:args});
	    }, function(){
			var args = Array.prototype.slice.call(arguments);
	    	def.reject({msg:&quot;deep-request : cross domain xml load failed &quot;, arguments:args});
	    });
		return promise.promise(def);
	}

	return DeepRequest;
})

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
