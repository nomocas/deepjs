<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>deep-stores.js - deepjs Javascript Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="deepjs Javascript Framework"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.rc</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/deep.html">deep</a></li>
            
                <li><a href="../classes/deep.Chain.html">deep.Chain</a></li>
            
                <li><a href="../classes/deep.collider.html">deep.collider</a></li>
            
                <li><a href="../classes/deep.collider.array.html">deep.collider.array</a></li>
            
                <li><a href="../classes/deep.collider.assert.html">deep.collider.assert</a></li>
            
                <li><a href="../classes/deep.collider.object.html">deep.collider.object</a></li>
            
                <li><a href="../classes/deep.compose.html">deep.compose</a></li>
            
                <li><a href="../classes/deep.Composer.html">deep.Composer</a></li>
            
                <li><a href="../classes/deep.Deferred.html">deep.Deferred</a></li>
            
                <li><a href="../classes/deep.Promise.html">deep.Promise</a></li>
            
                <li><a href="../classes/deep.Query.html">deep.Query</a></li>
            
                <li><a href="../classes/deep.Role.html">deep.Role</a></li>
            
                <li><a href="../classes/deep.roles.html">deep.roles</a></li>
            
                <li><a href="../classes/deep.stores.html">deep.stores</a></li>
            
                <li><a href="../classes/deep.stores.Array.html">deep.stores.Array</a></li>
            
                <li><a href="../classes/deep.stores.aspect.html">deep.stores.aspect</a></li>
            
                <li><a href="../classes/deep.stores.instance.html">deep.stores.instance</a></li>
            
                <li><a href="../classes/deep.stores.js.html">deep.stores.js</a></li>
            
                <li><a href="../classes/deep.stores.Object.html">deep.stores.Object</a></li>
            
                <li><a href="../classes/deep.stores.queryThis.html">deep.stores.queryThis</a></li>
            
                <li><a href="../classes/deep.stores.Store.html">deep.stores.Store</a></li>
            
                <li><a href="../classes/deep.utils.html">deep.utils</a></li>
            
                <li><a href="../classes/deep.Validator.html">deep.Validator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/deep.html">deep</a></li>
            
                <li><a href="../modules/deep-collider.html">deep-collider</a></li>
            
                <li><a href="../modules/deep-compose.html">deep-compose</a></li>
            
                <li><a href="../modules/deep-query.html">deep-query</a></li>
            
                <li><a href="../modules/deep-roles.html">deep-roles</a></li>
            
                <li><a href="../modules/deep-rql.html">deep-rql</a></li>
            
                <li><a href="../modules/deep-schema.html">deep-schema</a></li>
            
                <li><a href="../modules/deep-stores.html">deep-stores</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: deep-stores.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * how manage collections and objects as http styled stores
 *
 * One interface for all stores.
 *
 * @module deep
 * @submodule deep-stores
 * @author Gilles Coomans &lt;gilles.coomans@gmail.com&gt;
 */
if(typeof define !== &#x27;function&#x27;)
	var define = require(&#x27;amdefine&#x27;)(module);

define([&quot;require&quot;, &quot;deep/deep&quot;],function(require)
{
	return function(deep){
		//_______________________________________________________________________________ STORES
		//var deep = require(&quot;deep/deep&quot;);
		var Querier = require(&quot;deep/deep-query&quot;);
		/**
		 *
		 * 
		 * @submodule deep-stores
		 */
		
		/**
		 * Just a namespace : where default and custom stores are mainly... stored. ;)
		 * @class deep.stores
		 */
		deep.stores = {};

		/**
		 * create a custom store or start chain with a certain store
		 * @for deep
		 * @method store
		 * @static
		 */
		deep.store = function (name, definer, options)
		{
			options = options || {};
			var store = null;
			if(!definer)
			{
				if(!deep.stores[name])
					throw new Error(&quot;deep.store(name) : no store found with : &quot;, name);
				return deep.stores[name];
			}
			else if(definer instanceof Array)
				store = deep.stores[name] = deep.store.ArrayStore(definer, options);
			else if(definer instanceof deep.store.DeepStore)
				store = deep.stores[name] = definer.create(name, options);
			else store = deep.stores[name] = deep.store.ObjectStore(definer, options);
			store.name = name;
			store.options = options;
			return store;
		};

		/**
		 * set chain with a certain store. If no store founded : throw an error.
		 * @for deep.Chain
		 * @method store
		 * @param {String} name the name of the store to select
		 * @return {deep.Chain} the chain to manage selected store. Inject chain&#x27;s values as success object.
		 */
		deep.Chain.prototype.store = function (name)
		{
			var self = this;
			var store = null;
			if(typeof name === &#x27;string&#x27;)
			{
				if(!deep.stores[name])
					throw new Error(&quot;no store found with : &quot;+name);
				store = deep.stores[name];
			}
			else
				store = name;
			var func = function (s,e) {
				//console.log(&quot;chain.store : set store : &quot;, store.name);
				self._store = store;
				deep.chain.position(self, store.name);
				deep.chain.forceNextQueueItem(self, deep.chain.values(self), null);
			};
			deep.handlers.decorations.store(store, self);
			deep.chain.addInQueue.apply(this,[func]);
			return self;
		};
		deep.handlers.decorations.store = function (store, handler) {
			//console.log(&quot;store decoration&quot;);
			deep.utils.up({
				_store : deep.collider.replace(store),

				get : deep.compose
				.condition(typeof store.get === &quot;function&quot;)
				.createIfNecessary()
				.replace(function (id, options) {
					var self = this;
					if(id == &quot;?&quot; || !id)
						id = &quot;&quot;;

					var func = function (s,e) {
						self._store.get(id, options)
						.done(function (success) {
							//console.log(&quot;deep(...).store : get : success : &quot;, success);
							if(success instanceof Array)
								self._entries = deep(success).nodes();
							else
								self._entries = [deep.Querier.createRootNode( success )];
							deep.chain.forceNextQueueItem(self, success, null);
						})
						.fail(function (error) {
							deep.chain.forceNextQueueItem(self, null, error);
						});
					};
					deep.chain.addInQueue.apply(this,[func]);
					self.range = deep.Chain.range;
					return self;
				}),

				post : deep.compose
				.condition(typeof store.post === &quot;function&quot;)
				.createIfNecessary()
				.replace(function (object, id, options) {
					var self = this;
					var func = function (s,e)
					{
						self._store.post(object || deep.chain.val(self),id, options)
						.done(function (success) {
							self._entries = [deep.Querier.createRootNode(success)];
							deep.chain.forceNextQueueItem(self, success, null);
						})
						.fail(function (error) {
							console.log(&quot;deeo.chain.store.post : post failed : &quot;, error);
							deep.chain.forceNextQueueItem(self, null, error);
						});
					};
					self.range = deep.Chain.range;
					deep.chain.addInQueue.apply(this,[func]);
					return self;
				}),

				put : deep.compose
				.condition(typeof store.put === &quot;function&quot;)
				.createIfNecessary()
				.replace(function (object, options) {
					var self = this;
					//console.log(&quot;deep.chain.put : add in chain : &quot;, object, id);
					var func = function (s,e) {
						//console.log(&quot;deep.chain.put : &quot;, object, id);
						self._store.put(object  || deep.chain.val(self),id, options)
						.done(function (success) {
							self._entries = [deep.Querier.createRootNode(success)];
							deep.chain.forceNextQueueItem(self, success, null);
						})
						.fail(function (error) {
							deep.chain.forceNextQueueItem(self, null, error);
						});
					};
					self.range = deep.Chain.range;
					deep.chain.addInQueue.apply(this,[func]);
					return self;
				}),

				patch : deep.compose
				.condition(typeof store.patch === &quot;function&quot;)
				.createIfNecessary()
				.replace(function (object, id, options) {
					var self = this;
					var func = function (s,e) {
						self._store.patch(object  || deep.chain.val(self),id, options)
						.done(function (success) {
							self._entries = [deep.Querier.createRootNode(success)];
							deep.chain.forceNextQueueItem(self, success, null);
						})
						.fail(function (error) {
							deep.chain.forceNextQueueItem(self, null, error);
						});
					};
					self.range = deep.Chain.range;
					deep.chain.addInQueue.apply(this,[func]);
					return self;
				}),

				del : deep.compose
				.condition(typeof store.del === &quot;function&quot;)
				.createIfNecessary()
				.replace(function (id, options) {
					var self = this;
					var func = function (s,e) {
						var val = deep.chain.val(self);
						self._store.del(id || val.id, options)
						.done(function (success) {
							self._entries = [deep.Querier.createRootNode(success)];
							deep.chain.forceNextQueueItem(self, success, null);
						})
						.fail(function (error) {
							deep.chain.forceNextQueueItem(self, null, error);
						});
					};
					self.range = deep.Chain.range;
					deep.chain.addInQueue.apply(this,[func]);
					return self;
				}),

				rpc : deep.compose
				.condition(typeof store.rpc === &quot;function&quot;)
				.createIfNecessary()
				.replace(function (method, body, uri, options) {
					var self = this;
					var func = function (s,e) {
						self._store.rpc(method, body, uri, options)
						.done(function (success) {
							self._entries = [deep.Querier.createRootNode(success)];
							deep.chain.forceNextQueueItem(self, success, null);
						})
						.fail(function (error) {
							deep.chain.forceNextQueueItem(self, null, error);
						});
					};
					self.range = deep.Chain.range;
					deep.chain.addInQueue.apply(this,[func]);
					return self;
				}),

				range : deep.compose
				.condition(typeof store.range === &quot;function&quot;)
				.createIfNecessary()
				.replace(function (arg1, arg2, uri, options) {
					var self = this;
					var func = function (s,e) {
						self._store.range(arg1, arg2, uri, options)
						.done(function (success) {
							self._entries = deep(success.results).nodes();
							deep.chain.forceNextQueueItem(self, success, null);
						})
						.fail(function (error) {
							deep.chain.forceNextQueueItem(self, null, error);
						});
					};
					self.range = deep.Chain.range;
					deep.chain.addInQueue.apply(this,[func]);
					return self;
				}),

				bulk : deep.compose
				.condition(typeof store.bulk === &quot;function&quot;)
				.createIfNecessary()
				.replace(function (arr, uri, options) {
					var self = this;
					var func = function (s,e) {
						self._store.bulk(arr, uri, options)
						.done(function (success) {
							self._entries = deep(success).nodes();
							deep.chain.forceNextQueueItem(self, success, null);
						})
						.fail(function (error) {
							deep.chain.forceNextQueueItem(self, null, error);
						});
					};
					self.range = deep.Chain.range;
					deep.chain.addInQueue.apply(this,[func]);
					return self;
				})
			}, handler);
			return handler;
		};
		/**
		 * Empty class : Just there to get instanceof working (be warning with iframe issue in that cases).
		 * @class deep.stores.Store
		 * @constructor
		 */
		deep.store.DeepStore = function () {};
		deep.store.DeepStore.prototype = {
			_deeo_store_:true
		};

		/**
		 * A store based on simple array
		 * @class deep.stores.Array
		 * @constructor
		 * @param {Array} arr a first array of objects to hold
		 * @param {Object} options could contain &#x27;schema&#x27;
		 */
		deep.store.ArrayStore = function (arr, options) {
			var store = new deep.store.DeepStore();
			options = options || {};
			store.schema = options.schema || {};
			var stock = {
				collection:arr
			};
			/**
			 * @method get
			 * @param  {String} id the id of the object to retrieve. Could also be a (deep)query.
			 * @param {Object} options an options object (here there is no options)
			 * @return {Object} the retrieved object
			 */
			store.get = function (id, options) {
				if(id === &quot;&quot;)
					id = &quot;?&quot;;
				if( id.match( /^((\.?\/)?\?)|^(\?)/gi ) )
					return deep(stock).query(&quot;collection/*&quot;+id).store( this);
				return deep(stock).query(&quot;./collection/*?id=&quot;+id).store(this);
			};
			/**
			 * @method put
			 * @param  {Object} object the object to update
			 * @param  {Object} options an options object : could contain &#x27;id&#x27;
			 * @return {Object} the updated object
			 */
			store.put = function (object, options) {
				options = options || {};
				var id = options.id || object.id;
				if(!id)
					throw new Error(&quot;Array store need id on put&quot;)
				var schema = options.schema || this.schema;
				if(schema)
					deep(object)
					.validate(schema)
					.fail(function (error) {
						object = error;
					})
					.root(stock)
					.replace(&quot;./collection/*?id=&quot;+id, object);
				else
					deep(stock)
					.replace(&quot;./collection/*?id=&quot;+id, object);
				return deep(object).store(this);
			};
			/**
			 * @method post
			 * @param  {Object} object
			 * @param  {Object} options (optional)
			 * @return {Object} the inserted object (decorated with it&#x27;s id)
			 */
			store.post = function (object, options) {
				options = options || {};
				object.id = id = new Date().valueOf(); // mongo styled id
				var schema = options.schema || this.schema;
				if(schema)
					deep(object)
					.validate(schema)
					.done(function (report) {
						arr.push(object);
					})
					.fail(function (error) {
						object = error;
					});
				else
					arr.push(object);
				return deep(object).store(this);
			};
			/**
			 * @method del
			 * @param  {String} id
			 * @param  {Object} options no options for the moment
			 * @return {Object} the removed object
			 */
			store.del = function (id, options) {
				return deep(stock).remove(&quot;./collection/*?id=&quot;+id).store(this);
			};
			/**
			 * @method patch
			 * @param  {Object} object  the update to apply to object
			 * @param  {Object} options  could contain &#x27;id&#x27;
			 * @return {deep.Chain} a chain that hold the patched object and has injected values as success object.
			 */
			store.patch = function (object, options) {
				options = options || {};
				var id = object.id || options.id;
				if(!id)
					throw new Error(&quot;deep.stores.Array need id on patch&quot;);
				var schema = options.schema || this.schema;
				if(schema &amp;&amp; !)
				{
					var report = deep.validate(object, schema, { partial:true });
					if(!report.valid)
						throw new Error(&quot;412 : Precondition Failed : deep.stores.Array patch failed : &quot;+JSON.stringify());
				}	
				return deep(stock).query(&quot;./collection/*?id=&quot;+id).up(object).store(this);
			};
			/**
			 * select a range in collection
			 * @method range
			 * @param  {Number} start
			 * @param  {Number} end
			 * @return {deep.Chain} a chain that hold the selected range and has injected values as success object.
			 */
			store.range = function (start, end) {
				return deep(stock.collection).range(start,end).store(this);
			};
			return store;
		};

		/**
		 * A store based on simple object
		 * @class deep.stores.Object
		 * @constructor
		 * @param {Object} obj the root object to hold
		 * @param {Object} options could contain &#x27;schema&#x27;
		 */
		deep.store.ObjectStore = function (obj, options)
		{
			var store = new deep.store.DeepStore();
			options = options || {};
			store.schema = options.schema || {};
			/**
			 * @method get
			 * @param  {[type]} id
			 * @return {[type]}
			 */
			store.get = function (id)
			{
				if(id[0] == &quot;.&quot; || id[0] == &quot;/&quot;)
					return deep(obj).query(id).store(this);
				return deep(obj).query(&quot;./&quot;+id).store(this);
			};
			/**
			 * @method put
			 * @param  {[type]} object
			 * @param  {[type]} query
			 * @return {[type]}
			 */
			store.put = function (object, query)
			{
				//console.log(&quot;ObjectStore.put : &quot;, object, query);
				deep(obj)
				.setByPath(query, object);
				return deep(object).store(this);
			};
			/**
			 * @method post
			 * @param  {[type]} object
			 * @param  {[type]} path
			 * @return {[type]}
			 */
			store.post = function (object, path)
			{
				if(options.schema)
					deep(object)
					.validate(options.schema)
					.fail(function (error) {
						object = error;
					})
					.root(obj)
					.setByPath(path, object);
				else
					deep(obj)
					.setByPath(path, object);
				return deep(object).store(this);
			};
			/**
			 * @method del
			 * @param  {[type]} id
			 * @return {[type]}
			 */
			store.del = function (id)
			{
				var res = [];
				if(id[0] == &quot;.&quot; || id[0] == &quot;/&quot;)
					deep(obj).remove(id)
					.done(function (removed)
					{
						res = removed;
					});
				else
					deep(obj).remove(&quot;./&quot;+id)
					.done(function (removed)
					{
						res = removed;
					});
				return deep(res).store(this);
			};
			/**
			 * @method patch
			 * @param  {[type]} object
			 * @param  {[type]} id
			 * @return {[type]}
			 */
			store.patch = function (object, id)
			{
				if(id[0] == &quot;.&quot; || id[0] == &quot;/&quot;)
					return deep(obj).query(id).up(object).store(this);
				return deep(obj).query(&quot;./&quot;+id).up(object).store(this);
			};
			return store;
		};


		/**
		 * retrieve request (if string in retrievable format) (e.g. &quot;json::test.json&quot;)
		 * perform an http get
		 * if request is not a string : will just return request
		 * @for deep
		 * @static 
		 * @method get
		 * @param  {String} request a string to retrieve
		 * @param  {Object} options (optional)
		 * @return {deep.Chain} a handler that hold result 
		 */
		deep.get = function  (request, options)
		{
			if(typeof request !== &quot;string&quot;)
				return request;
			var infos = deep.parseRequest(request);
			if(!infos.store)
				if(!infos.protocole)
					return request;
				else
					return new Error(&quot;no store found with : &quot;, request);
			if(infos.queryThis)
				return infos.store.get(infos, options);
			if(infos.method )
			{
				if(infos.method !== &quot;range&quot; || !infos.store.range)
					return deep(new Error(&quot;store doesn&#x27;t contain method : &quot;,request));
				var splitted = infos.uri.split(&quot;?&quot;);
				var rangePart = splitted.shift();
				var query = splitted.shift() || &quot;&quot;;
				if(query !== &quot;&quot; &amp;&amp; query[0] !== &quot;?&quot;)
					query = &quot;?&quot;+query;
				var rn = rangePart.split(&quot;,&quot;);
				var start = parseInt(rn[0], 10);
				var end = parseInt(rn[1], 10);
				return infos.store[infos.method](start, end, query, options);
			}
			else
				return infos.store.get(infos.uri, options);
		};
		/**
		 * retrieve an array of retrievable strings (e.g. &quot;json::test.json&quot;)
		 * if request is not a string : will just return request
		 * @for deep
		 * @static 
		 * @method getAll
		 * @param  {String} requests a array of strings to retrieve
		 * @param  {Object} options (optional)
		 * @return {deep.Chain} a handler that hold result 
		 */
		deep.getAll = function  (requests, options)
		{
			var alls = [];
			requests.forEach(function (request) {
				alls.push(deep.get(request,options));
			});
			return deep.all(alls);
		};

		/**
		 * parse &#x27;retrievable&#x27; string request (e.g. &quot;json::test.json&quot;)
		 * @for deep
		 * @method parseRequest
		 * @static
		 * @param  {String} request
		 * @return {Object} infos an object containing parsing result
		 */
		deep.parseRequest = function (request) {
			var protoIndex = request.indexOf(&quot;::&quot;);
			var protoc = null;
			var uri = request;
			var store = null;
			var method = null;
			if(protoIndex &gt; -1)
			{
				protoc = request.substring(0,protoIndex);
				var subprotoc = protoc.split(&quot;.&quot;);
				if(subprotoc.length &gt; 1)
				{
					protoc = subprotoc.shift();
					method = subprotoc.shift();
				}
				uri = request.substring(protoIndex+2);
			}
			//console.log(&quot;parseRequest : protoc : &quot;, protoc, &quot; - uri : &quot;, uri);
			var queryThis = false;
			if(request[0] == &#x27;#&#x27; || protoc == &quot;first&quot; || protoc == &quot;last&quot; || protoc == &quot;this&quot;)
			{
				store = deep.stores.queryThis;
				queryThis = true;
			}
			else if(!protoc)
			{
				//console.log(&quot;no protocole : try extension&quot;);
				for( var i in deep.stores )
				{
					var storez = deep.stores[i];
					if(!storez.extensions)
						continue;
					for(var j =0; j &lt; storez.extensions.length; ++j)
					{
						var extension = storez.extensions[j];
						if(uri.match(extension))
						{
							store = storez;
							break;
						}
					}
					if(store)
						break;
				}
			}
			else
				store = deep.stores[protoc];
			var res = {
				request:request,
				queryThis:queryThis,
				store:store,
				protocole:protoc,
				method:method,
				uri:uri
			};
			//console.log(&quot;deep.parseRequest : results : &quot;, res);
			return res;
		};

		//__________________________________________________________________________ CORE STORES
		/**
		 * the store to manage &#x27;query this&#x27; approach. see query usage in object when flatten for example.
		 * not intended to be used directly. use  &quot;this::./...&quot; || &quot;first::./...&quot; || &quot;last::&quot;./...&quot; somewhere in objects instead.
		 * @class deep.stores.queryThis
		 */
		deep.stores.queryThis = {
			/**
			 * @method get
			 * @param  {String} request the query to apply on object
			 * @param  {Object} options { root:theObjectToQuery, basePath:&quot;the_path_of_the_object_if_any&quot;}
			 * @return {Object} the query result
			 */
			get:function (request, options) {
				//console.log(&quot;deep.stores.queryThis : &quot;, request)
				options = options || {};
				var root = options.root;
				var basePath = options.basePath;
				var infos = request;
				if(typeof infos === &#x27;string&#x27;)
					infos = deep.parseRequest(infos);
				if(infos.uri[0] == &#x27;#&#x27;)
					infos.uri = infos.uri.substring(1);
				var res = null;
				if(root._isDQ_NODE_)
					res = Querier.query(root, infos.uri, { keepCache:false });
				else
				{
					basePath = basePath || &#x27;&#x27;;
					if(basePath !== &#x27;&#x27; &amp;&amp; infos.uri.substring(0,3) == &quot;../&quot;)
						infos.uri = ((basePath[basePath.length-1] != &quot;/&quot;)?(basePath+&quot;/&quot;):basePath)+infos.uri;
					res = Querier.query(root, infos.uri, { keepCache:false });
				}
				if(res)
					switch(infos.protocole)
					{
						case &quot;first&quot; :
							res = res[0] || null;
							break;
						case &quot;last&quot; :
							res = res[res.length-1] || null;
							break;
					}
				//if(infos.protocole == &quot;first&quot;)
				//	console.log(&quot;QUERY THIS : &quot;+request + &quot; - base path : &quot;+basePath)//, &quot; - results : &quot;, JSON.stringify(res, null, &#x27; &#x27;));
				return res;
			}
		};

		/**
		 * store to manage javascript instanciation with requirejs load.
		 * not intended to be used directly. use deep.store(&quot;instance&quot;) or &quot;instance::...js&quot; instead
		 * @class deep.stores.instance
		 */
		deep.stores.instance = {
			/**
			 * @method get
			 * @param  {String} id the path of the requirejs module to load
			 * @param  {Object} options
			 * @return {Object} the instanciated module
			 */
			get:function (id, options) {
				var cl = require(id);
				//console.log(&quot;DeepRequest.instance : &quot;, cl);
				if(typeof cl === &#x27;function&#x27; &amp;&amp; cl.prototype)
					return deep(new cl());
				console.log(&quot;DeepRequest : could not instanciate : &quot;+JSON.stringify(info));
				throw new Error(&quot;DeepRequest : could not instanciate : &quot;+JSON.stringify(info));
			}
		};

		/**
		 * store to manage javascript instanciation with requirejs load
		 * not intended to be used directly. use deep.store(&quot;aspect&quot;) or &quot;aspect::...js&quot; instead
		 * @class deep.stores.aspect
		 */
		deep.stores.aspect = {
			/**
			 * @method get
			 * @param  {String} id the path of the requirejs module to load
			 * @param  {Object} options
			 * @return {Object} the loaded aspect
			 */
			get:function (id, options) {
				return deep(require(id)).then(function(res){
					return res.aspect;
				}, function(res){
					return res;
				});
			}
		};

		/**
		 * store to manage requirejs module load
		 * not intended to be used directly. use deep.store(&quot;js&quot;) or &quot;js::...js&quot; instead
		 * @class deep.stores.js
		 */
		deep.stores.js = {
			/**
			 * @method get
			 * @param  {String} id the path of the module to load
			 * @param  {Object} options
			 * @return {Object} the loaded module
			 */
			get:function (id, options) {
				return deep(require(id));
			}
		};

		return deep;
	}
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
