<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>utils.js - deepjs API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="deepjs API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.rc</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/deep.html">deep</a></li>
            
                <li><a href="../classes/DeepDecorator.html">DeepDecorator</a></li>
            
                <li><a href="../classes/DeepDeferred.html">DeepDeferred</a></li>
            
                <li><a href="../classes/DeepHandler.html">DeepHandler</a></li>
            
                <li><a href="../classes/DeepPromise.html">DeepPromise</a></li>
            
                <li><a href="../classes/DeepQuery.html">DeepQuery</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/deep.html">deep</a></li>
            
                <li><a href="../modules/deep-collider.html">deep-collider</a></li>
            
                <li><a href="../modules/deep-compose.html">deep-compose</a></li>
            
                <li><a href="../modules/deep-query.html">deep-query</a></li>
            
                <li><a href="../modules/deep-rql.html">deep-rql</a></li>
            
                <li><a href="../modules/deep-schema.html">deep-schema</a></li>
            
                <li><a href="../modules/deep.stores.html">deep.stores</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: utils.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 *
 *	a bunch of utilities functions for deep
 * 
 * @author Gilles Coomans &lt;gilles.coomans@gmail.com&gt;
 * @module deep
 * @submodule utils
 */
if(typeof define !== &#x27;function&#x27;)
	var define = require(&#x27;amdefine&#x27;)(module);

define(function(require){
	var collider = require(&quot;./deep-collider&quot;);
	var compose = require(&quot;./deep-compose&quot;);
	var utils = {};

	// _______________________________________ swig related

	utils.getMacroImport = function(controller, macrosSet)
	{
		var renderedTemplate = &quot;&quot;;
		if(controller.layer &amp;&amp; controller.layer.templates)
		{    
			var macros = controller.layer.templates.macros;
			for (var i in macros)
			{
				if(!macros.hasOwnProperty(i) || (macrosSet &amp;&amp; ! i in macrosSet))
					continue;
				var  m = macros[i];
				var prefix = &quot;&quot;;
				var index = m.indexOf(&quot;:&quot;);
				if(index &gt; -1)
				{    
					prefix = m.substring(0,index);
					m = m.substring(index+2);
				}
				renderedTemplate += &quot;{% import &#x27;&quot; + m + &quot;&#x27; as &quot;+i+&quot; %}\n&quot;;
			}
		}
		return renderedTemplate;
	}

	// ______________________________________ STRINGS RELATED

	// TODO : need to be asynch and to retrieve values from stores : as app::language
	utils.interpret = function (string, context)
	{
		var count = string.indexOf(&#x27;{&#x27;);
		if(count == -1)
			return string;
		var parsed = string.substring(0,count);
		count++;
		var ln = string.length;
		while(count &lt; ln)
		{
			var toAnalyse = &quot;&quot;;
			while(count &lt; ln &amp;&amp; string[count] != &#x27;}&#x27;)
			{
				if(string[count] != &#x27; &#x27;)
					toAnalyse += string[count];
				count++;
			}
			if(string[count] == &#x27;}&#x27;)
			{
				parsed += utils.retrieveValueByPath(context, toAnalyse, &quot;.&quot;);
				count++;
			}
			while(count &lt; ln &amp;&amp; string[count] != &#x27;{&#x27;)
				parsed += string[count++];
			if(string[count] == &#x27;{&#x27;)
				count++;
		}
		return parsed;
	};


	utils.stripFirstSlash = function(text)
	{
		if(text.substring(0,1) == &quot;/&quot;)
			return text.substring(1);
		return text;
	}

	utils.catchParenthesis = function(path)
	{
		if(path[0] != &#x27;(&#x27;)
			return null;
		var count = 1;
		var catched = 1;
		var res = &quot;&quot;;
		while(( path[ count ] != &#x27;)&#x27; || catched &gt; 1) &amp;&amp; count &lt; path.length )
		{
			if( path[ count ] == &#x27;(&#x27; )
				catched++;
			if( path[ count ] == &#x27;)&#x27; )
				catched--;
			if(path[ count ] == &#x27;)&#x27; )
			{	
				if(catched &gt; 1)
					res += path[ count++ ]
			}
			else
				res += path[ count++ ]
		}
		count++;
		return { value:res, rest:path.substring(count)};
	}

	function trim_words(theString, numWords, maxChar) {
	    expString = theString.split(/\s+/,numWords);
	    if(expString.length == 1)
	    {
			maxChar = maxChar || 10;
	    	if(expString[0].length &gt; maxChar)
	    		return theString.substring(0,maxChar)
	    	return expString[0];
	    }
	    theNewString=expString.join(&quot; &quot;);
	    if(theNewString.length &lt; theString.length &amp;&amp; theNewString[theNewString.length-1] != &quot;.&quot;)
			theNewString += &quot;...&quot;;
	    return theNewString;
	}

	utils.trimWords = function(string, numWords, maxChar){
		var reg=new RegExp(&quot;&lt;[^&gt;]*&gt;&quot;, &quot;gi&quot; );
		var desc = string.replace(reg, &quot;&quot;);
		desc = trim_words(desc, numWords, maxChar);
		return desc;
	}

	//_________________________________________________________________ OBJECTS/ARRAY RELATED

	utils.copyArray = function(arr){
		if(!arr)
			return [];
		return arr.concat([]);
	};

	utils.cloneFunction = function(fct)
	{
		//console.log(&quot;cloneFunction : fct.decorator = &quot;, fct.decorator)
	    var clone = function() {
	        return fct.apply(this, arguments);
	    };
	    clone.prototype = fct.prototype;
	    for (property in fct) 
	        if (fct.hasOwnProperty(property)) 
	            clone[property] = utils.copy(fct[property]);
	    return clone;
	};

	utils.copy = function copy(obj){
		var res = null;
		if(obj instanceof Array)
		{
			res = [];
			obj.forEach(function(e){
				res.push(copy(e));
			})
		}
		else if(obj &amp;&amp; typeof obj === &#x27;object&#x27;)
		{
			if(obj instanceof RegExp)
				return obj;
			if(obj instanceof Date)
				return new Date(obj.valueOf());
		
			res = {};
			for(var i in obj)
			{
				if(i == &quot;_deep_entry&quot;)
					continue;
				if(obj.hasOwnProperty(i))
					res[i] = copy(obj[i]);
			}
		}
		else if(typeof obj === &#x27;function&#x27;)
		{
			if(obj.decorator instanceof compose.Decorator)
				res = compose.cloneStart(obj);
			else
				res = obj; //utils.cloneFunction(obj);
		}
		else
			res = obj;
		return res;
	}

	utils.getObjectClass = function(obj) {
	    if (obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor.toString) {
	        var arr = obj.constructor.toString().match(/function\s*(\w+)/);
	        if (arr &amp;&amp; arr.length == 2) 
	            return arr[1];
	    }
	    return undefined;
	}




	utils.setValueByPath = function setValueByPath(object, path, value, pathDelimiter)
	{
		var parts = path.split(pathDelimiter||&quot;.&quot;);
		if(pathDelimiter == &quot;/&quot; &amp;&amp; parts[0] == &quot;&quot;)
			parts.shift();
		var tmp = object;
		while(parts.length&gt;1)
		{
			var part = parts.shift();
			if(!tmp[part])
				return null;
			tmp = tmp[part];
		}
		return tmp[parts.shift()] = value;
	}

	utils.retrieveValueByPath = function retrieveValueByPath(object, path, pathDelimiter)
	{
		var parts = path.split(pathDelimiter||&quot;.&quot;);
		if(pathDelimiter == &quot;/&quot; &amp;&amp; parts[0] == &quot;&quot;)
			parts.shift();
		var tmp = object;
		while(parts.length&gt;1)
		{
			var part = parts.shift();
			if(!tmp[part])
				return null;
			tmp = tmp[part];
		}
		if(tmp)
			return tmp[parts.shift()];
		else return null;
	}

	utils.deletePropertyByPath = function deletePropertyByPath(object, path, pathDelimiter)
	{
		var parts = path.split(pathDelimiter||&quot;.&quot;);
		if(pathDelimiter == &quot;/&quot; &amp;&amp; parts[0] == &quot;&quot;)
			parts.shift();
		var tmp = object;
		while(parts.length&gt;1)
		{
			var part = parts.shift();
			if(!tmp[part])
				return;
			tmp = tmp[part];
		}
		delete tmp[parts.shift()];
	}


	utils.retrieveSchemaByPath = function retrieveSchemaByPath(schema, path, pathDelimiter)
	{
		//console.log(&quot;retrieveSchemaByPath : &quot;, schema, path);
		var parts = path.split(pathDelimiter||&quot;.&quot;);
		if(pathDelimiter == &quot;/&quot; &amp;&amp; parts[0] == &quot;&quot;)
			parts.shift();
		var tmp = schema;
		while(parts.length&gt;1)
		{
			var part = parts.shift();
			if(!tmp.properties || !tmp.properties[part])
				return null;
			tmp = tmp.properties[part];
		}
		if(tmp.properties)
			return tmp.properties[parts.shift()];
		else
			return null;
	}
	/*
		Does not make a deep-copy if collision : just if collid : make unique
	*/
	utils.arrayUnique = function arrayUnique(arr1, uniqueOn){
		if(!arr1.forEach)
			return arr1;
		var map = {}
		var count = 0;
		var arr = [];
		arr1.forEach(function(a){
			var val = null;
			if(uniqueOn)
				val = utils.retrieveValueByPath(a,uniqueOn);
			else if(a.uri)
				val = a.uri;
			if(val == null || val == undefined)
				val = String(a);
			if(typeof map[val] === &#x27;undefined&#x27;)
			{
				map[val] = true;
				arr.push(a);
			}
		})
		return arr;
	}

	utils.arrayFusion = function arrayFusion(arr1, arr2, uniqueOn){
		var map = {}
		var count = 0;
		var arr = [];
		if(arr1 &amp;&amp; arr1.length &gt; 0)
			arr = arr.concat(arr1);
		arr.forEach(function(a){
			var val = null;
			if(uniqueOn)
				val = utils.retrieveValueByPath(a,uniqueOn);
			else if(a.uri)
				val = a.uri;
			if(val == null || val == undefined)
				val = String(a);
			map[val] = true;
		})
		arr2.forEach(function(a){
			var val = null;
			if(uniqueOn)
				val = utils.retrieveValueByPath(a,uniqueOn);
			else if(a.uri)
				val = a.uri;
			if(val == null || val == undefined)
				val = String(a);
			if(typeof map[val] === &#x27;undefined&#x27;)
				arr.push(a);
		})
		return arr;
	}

	utils.inArray = function inArray(what, inArr)
	{
		//console.log(&quot;inArray : what : &quot;+JSON.stringify(what) + &quot; - in : &quot;+JSON.stringify(inArr));
		if(!inArr || !inArr instanceof Array)
			return false;
		var test = {};
		inArr.forEach(function(e){
			test[e] = true;
		})
		if(what.forEach)
		{	
			var okCount = 0;
			what.forEach(function(e){
				if(typeof test[e] !== &#x27;undefined&#x27;)
					okCount++;
			})
			if(okCount == what.length)
				return true;
			return false;
		}
		else if(test[what])
			return true
		return false;
	}

	utils.getJSPrimitiveType = function (obj)
	{
		if(obj instanceof Array)
			return &quot;array&quot;
		return typeof obj;
	}

	utils.deepEqual = function(a,b, ordered)
	{
		if(ordered == undefined)
			ordered = true;
		if(typeof a !== typeof b)
			return false;
		if(typeof a === &#x27;object&#x27;)
		{
			if(a == null &amp;&amp; a !== b)
				return false;
			if(b == null &amp;&amp; a !== b)
				return false;
			var ok = true;
			var tmpA = [];
			var tmpB = [];
			for(var i in b)
			{
				if(i == &quot;_deep_entry&quot;)
					continue;
				if(!b.hasOwnProperty(i))
					continue;
				if(typeof a[i] === &#x27;undefined&#x27;)
					return false;
				ok = ok &amp;&amp; utils.deepEqual(a[i], b[i]);
				if(!ok)
					return false;
				tmpB.push(i);
			}
			for(var i in a)
			{
				if(i == &quot;_deep_entry&quot;)
					continue;
				if(!a.hasOwnProperty(i))
					continue;
				tmpA.push(i);
			}
			if(tmpA.length != tmpB.length)
				return false;
			if(ordered)
				for(var j = 0; j &lt; tmpB.length; ++j)
					if(tmpB[j] != tmpA[j])
						return false;
		}
		else if(a !== b)
			return false;
		return true;
	}
	//var result = {};

	var retrieveFullSchemaByPath = utils.retrieveFullSchemaByPath =  function (schema, path, delimitter)
	{
		var parts = path.split(delimitter || &quot;.&quot;);
		if(parts[0] == &quot;&quot; || parts[0] == &quot;.&quot;)
			parts.shift();
		 // console.log(&quot;retrieveSchemaByPath : &quot;, parts, schema);
		var tmp = schema;
		while(parts.length&gt;1)
		{
			var part = parts.shift();
			if(part.match(/^[0-9]*$/))
			{
				if(tmp.type == &quot;array&quot;)
				{
					tmp = tmp.items || {};
					continue;
				}
			}
			if(!tmp.properties || !tmp.properties[part])
				return null;
			tmp = tmp.properties[part];
		}
		// console.log(&quot;after test last part -1 : &quot;, tmp);

		var lastPart = parts.shift();
		var res= [];
		if(lastPart.match(/^[0-9]*$/))
		{
			if(tmp.type == &quot;array&quot;)
			{
				tmp = tmp.items || {};
				res.push(tmp)
			}
			// TODO : gestion pattern items
		}
		else
		{
			if(tmp.properties &amp;&amp; tmp.properties[lastPart])
				res.push(tmp.properties[lastPart]);
			// console.log(&quot;after test last part : &quot;, res);
			if(tmp.patternProperties)
				for(var i in tmp.patternProperties)
					if(new RegExp(i).test(lastPart))
						res.push(tmp.patternProperties[i])

			 // console.log(&quot;after test last part pattern props : &quot;, res);

			if(res.length ==0)
				if (tmp.additionalProperties == undefined || tmp.additionalProperties == false)
					return null;
				else
					return tmp.additionalProperties;
		}

		
		var finalSchema = {};
		if(res.length &gt; 1)
			res.forEach(function(e){
				finalSchema = utils.up(e, finalSchema);
			});
		else if(res.length == 1)
			finalSchema = res[0];
		 // console.log(&quot;retrieveSchemaByPath : finally : &quot;, path, finalSchema);

		return finalSchema;
	}

	var deepArrayFusion = utils.deepArrayFusion = function deepArrayFusion(arr1, arr2, schema)
	{
		var map = {}
		var count = 0;
		var arr = [];
		var itemsSchema = {};
		var mergeOn = null;
		if(schema)
		{
			if(schema.items)
				itemsSchema = schema.items;
			if(schema.collision &amp;&amp; schema.collision.unique)
				mergeOn = (schema.collision.unique === true)?null:schema.collision.unique;
		}	

		if(!mergeOn)
			return arr1.concat(arr2);

		if(arr1 &amp;&amp; arr1.length &gt; 0)
			arr = arr.concat(arr1);
		arr.forEach(function(a){
			var val = null;
			if(mergeOn)
				val = utils.retrieveValueByPath(a,mergeOn);
			else if(a.uri)
				val = a.uri;
			else if(a.name)
				val = a.name;
			else if(a.id)
				val = a.id;
			if(val == null || val == undefined)
				val = String(a);
			map[val] = {ref:a, index:count++};
		})
		arr2.forEach(function(a){
			var val = null;
			if(mergeOn)
				val = utils.retrieveValueByPath(a,mergeOn);
			else if(a.uri)
				val = a.uri;
			else if(a.name)
				val = a.name;
			else if(a.id)
				val = a.id;
			if(val == null || val == undefined)
				val = String(a);
			if(!map[val])
				arr.push(a);
			else
				utils.up(map[val].ref, a, true, itemsSchema, arr, map[val].index);
		})
		return arr;
	}

	var up = function (src, target, schema, parent, key) 
	{
		if( typeof src === &#x27;undefined&#x27; )
			return target;
		if(src === null)
		{
			if(parent &amp;&amp; key)
				parent[key] = null;
			return null;
		}

		
		// console.log(&quot;deepUp : objects not nulls.&quot;)
		var result = null;
		var srcType = utils.getJSPrimitiveType(src);
		var targetType = utils.getJSPrimitiveType(target);
		//console.log(&quot;deepUp : objects types : &quot;, srcType, targetType);
		if (srcType === &#x27;function&#x27;)
		{	
			if (targetType === &#x27;function&#x27;)
			{
				if(src.decorator &amp;&amp; src.decorator instanceof compose.Decorator)
				{
					if(src.decorator.condition &amp;&amp; typeof src.decorator.condition === &#x27;function&#x27; &amp;&amp; !src.decorator.condition())
						return target;
					//console.log(&quot;deepUp: src is decorator : &quot;,src)
					result = compose.up(target, src);
				}	
				else if(src._deep_collider)
				{
					//console.log(&quot;deepUp: src is collider : &quot;,src)
					if(target._deep_collider)
						result = collider.wrap(src,target);
					else
						result = src(target, parent, key);
				}
				else
				{
					//console.log(&quot;deepUp: src is simple function : &quot;,src)
					result = src;
				}	
			}
			else
			{
				if(src.decorator &amp;&amp; src.decorator instanceof compose.Decorator)
				{
					if(typeof target === &#x27;undefined&#x27;)
					{
						if(src.decorator.ifExists)
						{
							return target;
						}	
						else{
							//src.decorator.createIfNecessary = true;
							result = src;
						}
					}
					else
						throw new Error(&quot;deep.compose need to be applied on function ! &quot;);
				}	
				else if(src._deep_collider)
					result = src(target, parent, key);
				else
					result = src;
			}
		}
		if(result)
		{
			//console.log(&quot;deepUp : objects functions collison gives : &quot;, result);
			if(parent &amp;&amp; key)
				parent[key] = result;
			return result;
		}
		if(typeof target === &#x27;undefined&#x27; || target === null)
		{
			target = utils.copy(src);
			if(parent &amp;&amp; key)
				parent[key] = target;
			return target;
		}	
		if(srcType !== targetType)
		{
			target = utils.copy(src);
			if(parent &amp;&amp; key)
				parent[key] = target;
			return target;
		}
		switch(srcType)
		{
			case &#x27;array&#x27; : 
				result = deepArrayFusion(target, src, schema);
				if(parent &amp;&amp; key)
					parent[key] = result;
				//console.log(&quot;array fusion up rsult : &quot;, JSON.stringify(result), parent, key, JSON.stringify(parent))
				return result;
				break;
			case &#x27;object&#x27; :
				if(src instanceof RegExp)
				{
					if(parent &amp;&amp; key)
						parent[key] = src;
					return src;
				}	
				if(src instanceof Date)
				{
					target = new Date(src.valueOf());
					if(parent &amp;&amp; key)
						parent[key] = target;
					return target;
				}	
				
				for(var i in src)
				{
					if(i == &quot;_deep_entry&quot;)
						continue;

					if(src[i] == null)
					{

						target[i] = null;
						continue;
					}

					if(src[i] &amp;&amp; src[i]._deep_colliderRemove)
					{
						delete target[i];
						continue;
					}

					var sch = {};
					if(schema)
						sch = retrieveFullSchemaByPath(schema, i);
					target[i] = utils.up(src[i], target[i], sch, target, i);
				}
				return target;
				break;
			default : 
				if(parent &amp;&amp; key)
					parent[key] = src;
				return src;
		}
	}

	var bottom = function (src, target, schema, parent, key) 
	{
		 // console.log(&quot;utils.bottom : objects &quot;, src, target)

		if(src === null || typeof src === &quot;undefined&quot;)
			return target;
		if(target == null)
			return target;
		if(typeof target === &#x27;undefined&#x27;)
		{
			target = utils.copy(src);
			if(parent &amp;&amp; key)
				parent[key] = target;
			return target;
		}	
		//console.log(&quot;utils.bottom : objects not nulls.&quot;)
		var result= null;
		var srcType = utils.getJSPrimitiveType(src);
		var targetType = utils.getJSPrimitiveType(target);
		// console.log(&quot;utils.bottom : objects types : &quot;, srcType, targetType);
		if ( targetType === &#x27;function&#x27;)
		{	
			if ( srcType === &#x27;function&#x27;)
			{
				if(target.decorator &amp;&amp; target.decorator instanceof compose.Decorator)
				{
					// console.log(&quot;utils.bottom: target is decorator : &quot;,target)
					result = compose.bottom(src, target); 

				}	

				else if(target._deep_collider)
				{
					//console.log(&quot;utils.bottom: src is collider : &quot;,src)
					if(src._deep_collider)
						result = collider.wrap(target, src);
					else
						result = target(src, parent, key);
				}
				else
				{
					//console.log(&quot;utils.bottom: src is simple function : &quot;,src)
					result = target;
				}	
			}
			else
			{
				if(target.decorator &amp;&amp; target.decorator instanceof compose.Decorator)
					throw new Error(&quot;deep.compose need to be applied on function ! &quot;);
				if(target._deep_collider)
					result = target(src, parent, key);
				else
					result = target;
			}
		}
		if(result)
		{
			// console.log(&quot;deep.bottom : objects functions collison gives : &quot;, result);
			if(parent &amp;&amp; key)
				parent[key] = result;
			return result;
		}
		if(srcType !== targetType)
		{
			return target;
		}
		switch(srcType)
		{
			case &#x27;array&#x27; : 
				result = deepArrayFusion(src, target, schema);
				if(parent &amp;&amp; key)
					parent[key] = result;
				console.log(&quot;array fusion bottom rsult : &quot;, result, parent, key, parent[key])
				return result;
				break;
			case &#x27;object&#x27; :
				// console.log(&quot;deep.bottom : apply objects together&quot;)
				var oldProps = {};
				for(var i in target)
				{
					if(i == &quot;_deep_entry&quot;)
						continue;
					oldProps[i] = target[i];
					delete target[i];
				}	
				for(var i in src)
				{
					if(i == &quot;_deep_entry&quot;)
						continue;
					target[i] = utils.copy(src[i]);
				}	

				for(var i in oldProps)
				{
					if(i == &quot;_deep_entry&quot;)
						continue;
					if(oldProps[i] == null)
					{
						target[i] = null;
						continue;
					}
					if(oldProps[i] &amp;&amp; oldProps[i]._deep_colliderRemove)
					{
						delete target[i];
						continue;
					}
					var sch = {};
					if(schema)
						sch = retrieveFullSchemaByPath(schema, i);
					target[i] = utils.up(oldProps[i], target[i], sch, target, i);
				}
				return target;
				break;
			default : 
				return target;
		}
	}

	var deepCopy = utils.deepCopy = function deepCopy(source, target, overwrite, schema, parent, key)
	{
		overwrite = (overwrite != null &amp;&amp; overwrite != undefined)?overwrite:true;
	//	console.log(&quot;deep-copy : &quot;,source, &quot; in &quot;, target, &quot; - ow : &quot;, overwrite, &quot; - parent &quot;, parent, &quot; - key : &quot;, key)
		if(overwrite)
			return utils.up(source, target, schema, parent, key);
		return utils.bottom(source, target, schema, parent, key);
	}
	utils.up = up;
	utils.bottom = bottom;

	//___________________________________________ RANGE RELATED

	utils.createRangeObject = function (start, end, total) {
		var res = {
			total:total,
			start:0,
			end:0,
			hasNext:false,
			hasPrevious:false,
			next:function (width) 
			{
				if(!this.hasNext)
					return this;
				this.start += width;
				this.end = this.start+(width-1);
				return  this.update(this.start, this.end);
			},
			previous:function (width) 
			{
				if(!this.hasPrevious)
					return this;
				this.start -= width;
				this.end = this.start+(width-1);
				return this.update(this.start, this.end);
			},
			update:function (start, end, total) 
			{
				this.total = total || this.total || 0;
				if(this.total == 0)
				{
					this.start = this.end = 0
					return this;
				}
				this.start = Math.max(Math.min(this.total-1,start), 0);
				this.end = Math.max(Math.min(end, this.total-1),0);
				this.hasNext = (this.end &lt; (this.total-1));
				this.hasPrevious = (this.start &gt; 0);
				//console.log(&quot;update range  : res : &quot;,this);
				return this;
			}
		};
		res.update(start,end,total)
		return res;
	}

	//_________________________________________________ HTTP RELATED

	utils.parseBody = function (body, headers) 
	{
		if(typeof body === &#x27;undefined&#x27; || body == null)
			return null;
		var contentType = headers[&quot;content-type&quot;] || headers[&quot;Content-Type&quot;] || &quot;application/json&quot;;
		var contentType = contentType.split(&quot;;&quot;)[0];
		switch(contentType)
		{
			case &quot;application/json-rpc&quot; : 
				var b = &quot;&quot;;
				if(body.forEach)
					body.forEach(function (bd) {
						b += bd.toString();
					});
				else
					b = body.toString();
				return JSON.parse(b);
				break;	

			case &quot;application/json&quot; : 
				var b = &quot;&quot;;
				if(body.forEach)
					body.forEach(function (bd) {
						b += bd.toString();
					});
				else
					b = body.toString();
				return JSON.parse(b);
				break;	

			case &quot;application/javascript&quot; :   // TODO : should be parsed by json-extended parser
				var b = &quot;&quot;;
				if(body.forEach)
					body.forEach(function (bd) {
						b += bd.toString();
					});
				else
					b = body.toString();
				return JSON.parse(b);
				break;	
			default :
				return body;
		}
	}

	return utils;	
})

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
