{
    "project": {
        "name": "deepjs Javascript Framework",
        "description": "The deepjs API: where tree, branch, layer, landscape, colliders, (mutable) chaines and promises merge. For better programming...",
        "version": "1.0.rc",
        "url": "http://www.deepjs.net"
    },
    "files": {
        "testcases/app.js": {
            "name": "testcases/app.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "deep-collider.js": {
            "name": "deep-collider.js",
            "modules": {
                "deep-collider": 1
            },
            "classes": {
                "Collider": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "deep-compose.js": {
            "name": "deep-compose.js",
            "modules": {
                "deep-compose": 1
            },
            "classes": {
                "DeepDecorator": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "deep-query.js": {
            "name": "deep-query.js",
            "modules": {
                "deep-query": 1
            },
            "classes": {
                "DeepQuery": 1
            },
            "fors": {},
            "namespaces": {}
        },
        "deep-request.js": {
            "name": "deep-request.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "deep-restart.js": {
            "name": "deep-restart.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "deep-roles.js": {
            "name": "deep-roles.js",
            "modules": {
                "deep-roles": 1
            },
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "deep-rql.js": {
            "name": "deep-rql.js",
            "modules": {
                "deep-rql": 1
            },
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "deep-schema.js": {
            "name": "deep-schema.js",
            "modules": {
                "deep-schema": 1
            },
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "deep-stores.js": {
            "name": "deep-stores.js",
            "modules": {
                "deep-stores": 1
            },
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "deep.js": {
            "name": "deep.js",
            "modules": {
                "deep": 1,
                "deep.stores": 1
            },
            "classes": {
                "deep": 1,
                "DeepHandler": 1,
                "DeepDeferred": 1,
                "DeepPromise": 1
            },
            "fors": {
                "deep": 1
            },
            "namespaces": {}
        },
        "promise.js": {
            "name": "promise.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "utils.js": {
            "name": "utils.js",
            "modules": {
                "utils": 1
            },
            "classes": {
                "utils": 1
            },
            "fors": {},
            "namespaces": {}
        }
    },
    "modules": {
        "deep": {
            "name": "deep",
            "submodules": {
                "deep-collider": 1,
                "deep-compose": 1,
                "deep-query": 1,
                "deep-roles": 1,
                "deep-rql": 1,
                "deep-schema": 1,
                "deep-stores": 1,
                "deep.stores": 1,
                "utils": 1
            },
            "classes": {
                "Collider": 1,
                "DeepDecorator": 1,
                "DeepQuery": 1,
                "deep": 1,
                "DeepHandler": 1,
                "DeepDeferred": 1,
                "DeepPromise": 1,
                "utils": 1
            },
            "fors": {
                "deep": 1
            },
            "namespaces": {},
            "tag": "module",
            "file": "utils.js",
            "line": 15,
            "description": "deep : just say : Powaaaaaa ;)"
        },
        "deep-collider": {
            "name": "deep-collider",
            "submodules": {},
            "classes": {
                "Collider": 1
            },
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "deep-collider.js",
            "line": 32,
            "description": "layer-data-composition : inspired by Compose, it offer a large set of tools that permit to manipulate values \n from within the object used as layer when applied together. \n As Compose merge two prototype by wrapping collided functions by appropriate Compose method (after, before, around),\n layer-compose do the same by applying a function when values are collided with that function.\n\n If you know photoshop : it's an equivalent of the fusion modes between two layers (or part of two layers).",
            "author": "Gilles Coomans <gilles.coomans@gmail.com>"
        },
        "deep-compose": {
            "name": "deep-compose",
            "submodules": {},
            "classes": {
                "DeepDecorator": 1
            },
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "deep-compose.js",
            "line": 164,
            "description": "When you collide two functions together, you could use deep.compose to manage how collision is resolved.\n Keep in mind that if you collide a simple function (up) on a composition (chained or not) : it mean : simply overwrite the composition by the function.\n So if you apply a composition from bottom on a function, the composition will never b applied.\n If you collide two compositions : they will be merged to give a unique composition chain.",
            "example": [
                "\n deep.compose : Chained Aspect Oriented Programming\n==========================\nSEE DOCS/deep.md for full doc\n\n\n\n## deep.compose.before( func )\n\nIf it returns something, it will be injected as argument(s) in next function.\nIf it return nothing, th original arguments are injected in next function.\nIf it returns a promise or a chain : it will wait until the resolution of the returned value.\nIf the returned object isn't a promise, the next function is executed immediately.\n\nex : \n\n\tvar base = {\n\t    myFunc:deep.compose.after(function(arg)\n\t    {\n\t        return arg + \" _ myfunc base\";\n\t    })\n\t}\n\n\tdeep(base)\n\t.bottom({\n\t    myFunc:function(arg){\n\t        return arg + \" _ myfunc from bottom\";\n\t    }\n\t});\n\n\tbase.myFunc(\"hello\");\n\n\n## deep.compose.after( func )\n\nIf the previous returns something, it will be injected as argument(s) in 'func'.\nIf the previous return nothing, th original arguments are injected in 'func'.\nIf the previous returns a promise or a chain : it will wait until the resolution of the returned value before executing 'func'.\nIf the previous returned object isn't a promise, 'func' is executed immediately.\n\nSame thing for returned object(s) from 'func' : it will be chained..\n\n\tex : \n\n\tvar base = {\n\t    myFunc:function(arg)\n\t    {\n\t        return arg + \" _ myfunc base\";\n\t    }\n\t}\n\n\tdeep(base)\n\t.up({\n\t    myFunc:deep.compose.after(function(arg){\n\t        return arg + \" _ myfunc from after\";\n\t    })\n\t});\n\n\tbase.myFunc(\"hello\");\n\n## deep.compose.around( func )\n\nhere you want to do your own wrapper.\nJuste provid a function that receive in argument the collided function (the one which is bottom),\nan which return the function that use this collided function.\n\n\tex : \n\n\tvar base = {\n\t\tmyFunc:function(arg)\n\t\t{\n\t\t\treturn arg + \" _ myfunc base\";\n\t\t}\n\t}\n\n\tdeep(base)\n\t.up({\n\t    myFunc:deep.compose.around(function(collidedMyFunc){\n\t    \treturn function(arg){\n\t    \t\treturn collidedMyFunc.apply(this, [arg + \" _ myfunc from around\"]);\n\t    \t}\n\t    })\n\t});\n\n\tbase.myFunc(\"hello\");\n\n\n## deep.compose.parallele( func )\n\nwhen you want to call a function in the same time of an other, and to wait that both function are resolved (even if deferred)\nbefore firing eventual next composed function, you could use deep.compose.parallele( func )\n\nKeep in mind that the output of both functions will be injected as a single array argument in next composed function.\nBoth will receive in argument either the output of previous function (if any, an even if deferred), or the original(s) argument(s).\n\nSo as implies a foot print on the chaining (the forwarded arguments become an array) : \nIt has to be used preferently with method(s) that do not need to handle argument(s), and that return a promise just for maintaining the chain asynch management.\n\nAn other point need to be clarify if you use deep(this).myChain()... in the composed function.\nAs you declare a new branch on this, you need to be careful if any other of the composed function (currently parallelised) do the same thing.\n\nYou'll maybe work on the same (sub)objects in the same time.\n\n## compositions chaining \n\nYou could do \n\tvar obj = {\n\t\tfunc:deep.compose.after(...).before(...).around(...)...\n\t}\nIt will wrap, in the order of writing, and immediately, the compositions themselves.\nYou got finally an unique function that is itself a composition (and so could be applied later an other functions).\n\nSo when you do : \n\ndeep.parallele(...).before(...) and deep.before(...).parallel(...)\n\nit does not give the same result of execution.\n\nIn first : you wrap the collided function with a parallele, and then you chain with a before.\nSo finally the execution will be : the before and then the parallelised call.\n\nIn second : you wrap the collided function with a before, and then wrap the whole in a parallele.\nSo the execution will be the parallelised call, but on one branche, there is two chained calls (the before and the collided function). \n\nKeep in mind that you WRAP FUNCTIONS, in the order of writing, and IMMEDIATELY.",
                "\n\n\tvar a = {\n   \tmyFunc:function(){\n   \t\t// do something\n  \t }\n \t}\n\tvar b = {\n \t\tmyFunc:deep.compose.after(function(){\n \t   \t\t// do something\n \t\t})\n \t}\n\n\tdeep.utils.up(b,a).myFunc()\n "
            ],
            "author": "Gilles Coomans <gilles.coomans@gmail.com>"
        },
        "deep-query": {
            "name": "deep-query",
            "submodules": {},
            "classes": {
                "DeepQuery": 1
            },
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "deep-query.js",
            "line": 177,
            "description": "A other proposal for (json/object)-query which (as differences from official proposal):\n \t- use simple slash delimitted syntax, \n \t- could handle regular expression for step selection, \n \t- could handle rql (for filtering) on each step selection,\n \t- could be relative to where the query are placed in a object/json\n \t- so could handle steps toward any ancestor\n \t- could handle json-schema in rql filtering\n \t- could handle ancestor in rql filtering",
            "example": [
                "\n deep-query : tools to query json/object structures. \n==========================\n\nsee Docs/deep-query.md   for full documentations\n\n\n\n## Queries examples:  the result is always the result of the last step.\n\n/foo/bar/\nFrom root : Select from root the property foo then give me the property bar in it\n\n\n../foo/bar?zoo.name//price?=in=(12,55)\nFrom ME (somewhere in a json/object) : Give me in my parent the property named foo\nOn this, give me 'bar' which has a property 'zoo' which has a property 'name'\nOn this give me any price (at any sublevel) equal to 12 or 55\n\n\n//(p.+)gi/../../foo//bar?=3\nFrom root : Give me recursively any property which its name correspond to (p.+)gi.\non this, take the parent of its parent (if any).\non this : take 'foo'.\non this : recursively take any property named bar and equal to 3\n\n\n/?foo=2&bar/(myArray.*)?length=gt=10/[1:4:2,@.length-2]//(^p.*)g?=in=(hello,bye)&_parent.taxerate=lt=0.12&_schema.type=string\nFrom root : Give me any property. \nOn this : give me those which have a property named foo and equal to 2 AND has a property named bar (different of undefined, null, false, or 0).\nOn this : select any property named myArray.* (RegExp) where length > 10.\nOn this : give me property (if any) named 1 or 3 or an index equal to parent.length-2 (parent is myAtrray.*).\nOn this : Recursively give me any property where its name correspond to (^p.*)g AND where its value is either 'hello' or 'bye'\n\tAND its parent has a property taxerate less than 0,12\n\tAND its type is 'string'\n\n\n## Syntaxe\n\nA query consist of succession of steps.\n\nA step is : \nmove selector ? rql\n\n\n### Start (first move)\n\n/\tstart from root\n./\tstart from me (from somewhere in a json/object)\n../ start from my parent (from somewhere in a json/object)\n// \tstart from root and give me any properties at any sub level\n\n### Moves\n\n/ \t\tcurrent level\n//\t\trecursively seek any property from current level\n../\t\ttake my parent level (you could select any of its properties from there)\n../!\ttake my parent reference (you need to add '/' (e.g. ../!/) to select any of its properties as above))\n/!\t\twill give you current reference\n\n\n### Selector\n\nany step selector is either a direct string, or an int (array index) or a regular expression, or a union of them (expressed as a coma separated list of them surrounded with square brackets).\nYou could express range of array indexes as 0:10:2 which says : take items from 0 to 10 (included) by step of two. (see examples below for optionals placement)\nRegular expression are always surrounded by parenthesis, and could be ended with 'g', 'i' or 'gi'.\n\nexamples of valid selectors : \n1\nfoo\n(foo.*)\n[0:20:2]\n[:]\n[1:,hello,(^prop.*)gi]\n\nquery example :\n/foo/1/(^bar)/[::2]\nSay : give me foo from root,\non this, give the first items (or any property called '1'),\non this, give me any property named bar... ,\non this, get all items by step of two (if any). (it's the result of the query) \n\n\nAll those below are equivalent and say : give me all properties or items of the last move\n/(.*)\n/*\n/[]\n/\n\n\n#### Length cases : \nIn array brackets access : you could use @.length to get the length (if any) of the parent IF IT'S AN ARRAY.\nexample : \n//[@.length-1]  \nwill give you any last array childs at any level from root.\n\n//length\nwill give you any array length at any level from root (or any 'length' property founded in the json/object)\n\nIn deep-rql : length could also give you the length of the strings.\n\n\n\n### Filter\n\nany RQL filter (deep-rql : see its doc for full description) could be added to any selector.\n\nexamples :\n\n/foo?=gt=12\ngive me foo property from root only if it's greater than 12\n\n//address?zip=1190\ngive me any adress which contains a zip equal to 1190\n\n//category?distinct()&sort(-)\ngive me any distinct category and sort them descendant\n\n\n\n## Concreet usage example\n\nHere's an example on how to query some JSON/object with deep-query:\n\n\tvar Querier = require(\"deep/deep-query\");\n\tvar json = {\n\t\t// ....\n\t};\n\tvar schema = {\n\t\t// content schema\n\t};\n\tvar res = Querier.query(object, \"/my/path/[0]\",{schema:schema});     // options with schema are optional\n\tres.forEach(function(e){\n\t\tconsole.log(\"result : \",e)\n\t})"
            ],
            "author": "Gilles Coomans <gilles.coomans@gmail.com>"
        },
        "deep-roles": {
            "name": "deep-roles",
            "submodules": {},
            "classes": {},
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "deep-roles.js",
            "line": 1,
            "author": "Gilles Coomans <gilles.coomans@gmail.com>"
        },
        "deep-rql": {
            "name": "deep-rql",
            "submodules": {},
            "classes": {},
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "deep-rql.js",
            "line": 1,
            "description": "A deep oriented implementation of RQL for JavaScript arrays based on rql/js-array from Kris Zyp (https://github.com/persvr/rql).\n\tWhat's different from js-array ? It could handle schema properties and ancestor access when filtering",
            "example": [
                " \n\t\trequire(\"deep/deep-rql\").query(\"a=3\", {}, [{a:1},{a:3}]) -> [{a:3}]"
            ],
            "author": "Gilles Coomans <gilles.coomans@gmail.com>"
        },
        "deep-schema": {
            "name": "deep-schema",
            "submodules": {},
            "classes": {},
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "deep-schema.js",
            "line": 1,
            "description": "JSON-Schema validator : based on json-schema draft 02, 03, and 04 + extensions\n \thttp://tools.ietf.org/html/draft-zyp-json-schema-03",
            "example": [
                "\n\n\tAjout par rapport à la v3\n\n\n\ttype:\n\t\tschema\n\t\tfalse\n\t\ttrue\n\t\tfunction\n\t\tdate\n\t\thash     !!!!!     différent de object ou array == TROISIEME TYPE non simple : hash table d'items\n\n\tnotNull\n\n\tabsoluteMinimum\n\tabsoluteMaximum\n\n\tmerge\n\tloadable\n\t\"interpretation-deepness\"   ==> have equivalent in draft 4 : template : bad word : template-engine is better or href-interpreter (because it's the only interpretable string)\n\n\n\tdeprecated : \n\t$ref : to be removed : incoherent with backgrounds\n\n\n\tsemantic misuse :\n\tid has to became uri\n\n\n\tv3 / V4\n\tpattern remplace format ?\n\tdivisibleBy -> mod\n\tmax/minProperties\n\n\trequired : fuzzy concept now : need \n\tdependencies : always fuzzy : need example to be clear\n\n\tI propose : \n\n\t{\n\t\tmyConstraintProperty:{\n\t\t\trequired:Boolean,   // means that's, in any case, this property is needed\n\t\t\trequire:{\n\t\t\t\t// is the schema that the whole object (from root) need to satisfy\n\t\t\t\tpath:{\n\t\t\t\t\tto:{\n\t\t\t\t\t\trequiredProperty:{\n\t\t\t\t\t\t\t// schema that requiredProperty need to satisfy\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tFuzzy : format/pattern/value :    value is more clear : \n\tI propose : \n\t\twhen object.value is a leaf of the object instance (no array, nor object):\n\t\tif(schema.value is RegExp)\n\t\t\tobject.value must match schema.value (equivalent of pattern)\n\t\telse\n\t\t\tobject.value must be equal to schema.value\n\t\t\t\n\tthat permit to be a mecanisme for true or false constraint value (no more \"true\" or \"false\" type)\n\tthat also permit to be a constraint on the object.value for any dependencies :\n\n\tso : \n\ttaxerate:{\n\t\trequired:true,\n\t\tdependencies:[\n\t\t\t{ \n\t\t\t\tconstraint:{\n\t\t\t\t\t// the schema that need to be matched on the dependant value\n\t\t\t\t\tpattern:\"tva-pattern-uk\"\n\t\t\t\t}, \n\t\t\t\tinstance:{\n\t\t\t\t\t// the schemas that pointed properties (from root) need to satisfy to evaluate \n\t\t\t\t\tpath:{\n\t\t\t\t\t\tto:{\n\t\t\t\t\t\t\tcountry:{\n\t\t\t\t\t\t\t\tpattern:\"UK\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ \n\t\t\t\tconstraint:{\n\t\t\t\t\t// the schema that need to be matched on the dependant value\n\t\t\t\t\tpattern:\"tva-pattern-eu\"\n\t\t\t\t}, \n\t\t\t\tinstance:{\n\t\t\t\t\t// the schema that pointed properties (from root) need to satisfy to evaluate \n\t\t\t\t\tproperties:{\n\t\t\t\t\t\tpathTo:{\n\t\t\t\t\t\t\tproperties:{\n\t\t\t\t\t\t\t\tcountry:{\n\t\t\t\t\t\t\t\t\tenum:[\"SE\",\"FR\",\"ES\"]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n\n\n\tWith json-pointer :\n\ttaxerate:{\n\t\trequired:true,\n\t\tdependencies:[\n\t\t\t{ \n\t\t\t\tconstraint:{  // the schema that need to be matched on the dependant value. Optional : empty schema by default\n\t\t\t\t\tpattern:\"tva-pattern-uk\"\n\t\t\t\t}, \n\t\t\t\ttest:{\n\t\t\t\t\t// the schemas that pointed property (from root - in object instance) need to be satisfied to evaluate constraint above\n\t\t\t\t\t\"#/address/country\":{\n\t\t\t\t\t\tpattern:\"UK\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ \n\t\t\t\tconstraint:{\n\t\t\t\t\t// the schema that need to be matched on the dependant value\n\t\t\t\t\tpattern:\"tva-pattern-eu\"\n\t\t\t\t}, \n\t\t\t\ttest:{\n\t\t\t\t\t// the schema that whole object (from root) needs to be satisfied to evaluate constraint above\n\t\t\t\t\t\"#/address/country\":{ \n\t\t\t\t\t\tenum:[\"FR\", \"ES\"]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n\n\tthe order of evaluation is done up-bottom, and the first dependecy that match the test will test his constraint on the value.\n\tOnly the first is interpreted.\n\n\tif there is \n\n\n\tDonc : SI l'instance satisfait tels schema : ALORS la valeur dépendante doit satisfaire tels contraintes\n\n\tmanque mécanisme de référence interne : \n\n\tgenre : \n\n\tmySchema:{\n\t\tobj:{\n\t\t\tobj2:{\n\t\t\t\t\"$ref\": \"/\"\n\t\t\t}\n\t\t}\n\t}\n\n\t==> utiliser backgrounds + json-pointer\n\n\t{\n\t\tproperties:{\n\t\t\tmyNestedChilds:{\n\t\t\t\tpatternProperties:{\n\t\t\t\t\t/.* /g:{\n\t\t\t\t\t\tbackgrounds:[\"#/\"],   // TOdo faire attention dans l'backgrounds d'un ancêtre : cycle possible : faut que l'extension ne cycle pas mais que la structure soit bien nesté à l'infini : solution faire l'backgrounds le plus tard possible : ne pas extender toute la structure dés le début\n\t\t\t\t\t\tproperties:{ \n\t\t\t\t\t\t\tparent:{ type:\"any\" } \n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\tsinon : addionnal items n'a de sens que si items est une array.\n\n\n\n\tREFACTORING EXTENDS\n\tbackgrounds dans deep-schema : faire un mix : \n\tprécompilation du schéma : dés qu'on voit qu'on doit choper un ancetre pour un backgrounds (dans le schema) : on laisse l'backgrounds  (on remplace dans l'array backgrounds tout ce qui peut etre compilé par sa compilation (par groupe en laissant l'ordre et les référence vers anc^etres tel quel - tout ce qui est en dessous de la première référence à un parent peut déjà être appliqué))\n\tlorsqu'on a une instance : lors du parsing/compilation (au deep-copy par exemple, lorsqu'on voit passer tous les champs) : \n\t\ton chope le schema associé à la propriété courante\n\t\t\tsi backgrounds encore présent dans schema : copier ancetre dans vide, (sans backgrounds), coller schema prop courante dessus (sans backgrounds) : retourner le tout\n\n\tsi backgrounds vers ancetres dans instance : throw : error : cycle present ! structure infinie\n\n\n\n\tbackgrounds et foregrounds : \n\t\tne pas les mettre dans l'instance : ca devient difficile à gérer : les mettre dans le schema : la c'est cohérent\n \n \t\tau final : comme un schema chope de plus en plus de propriétés d'un deep-factory : il faudrait que le schema soit un deep-factory \n \t\tdont son propre schema soit le meta schema du schema"
            ],
            "author": "gilles.coomans@gmail.com"
        },
        "deep-stores": {
            "name": "deep-stores",
            "submodules": {},
            "classes": {},
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "deep-stores.js",
            "line": 1,
            "author": "Gilles Coomans <gilles.coomans@gmail.com>"
        },
        "deep.stores": {
            "name": "deep.stores",
            "submodules": {},
            "classes": {
                "deep": 1
            },
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "deep.js",
            "line": 57,
            "description": "how manage collections and objects as http styled stores"
        },
        "utils": {
            "name": "utils",
            "submodules": {},
            "classes": {
                "utils": 1
            },
            "fors": {},
            "is_submodule": 1,
            "namespaces": {},
            "module": "deep",
            "namespace": "",
            "file": "utils.js",
            "line": 15,
            "description": "a bunch of utilities functions for deep",
            "author": "Gilles Coomans <gilles.coomans@gmail.com>"
        }
    },
    "classes": {
        "Collider": {
            "name": "Collider",
            "shortname": "Collider",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "deep",
            "submodule": "deep-collider",
            "namespace": "",
            "file": "deep-collider.js",
            "line": 32,
            "description": "the collider interface"
        },
        "DeepDecorator": {
            "name": "DeepDecorator",
            "shortname": "DeepDecorator",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "deep",
            "submodule": "deep-compose",
            "namespace": "",
            "file": "deep-compose.js",
            "line": 164,
            "is_constructor": 1,
            "params": [
                {
                    "name": "stack",
                    "description": "stack of functions to chain",
                    "type": "Array"
                }
            ]
        },
        "DeepQuery": {
            "name": "DeepQuery",
            "shortname": "DeepQuery",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "deep",
            "submodule": "deep-query",
            "namespace": "",
            "file": "deep-query.js",
            "line": 177,
            "is_constructor": 1
        },
        "deep": {
            "name": "deep",
            "shortname": "deep",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "deep",
            "namespace": "",
            "file": "deep.js",
            "line": 57,
            "description": "Start of deep chain",
            "example": [
                "\n\t\tdeep(\"./json/simple.json\").logValues(\"simple.json : \");"
            ],
            "is_constructor": 1,
            "params": [
                {
                    "name": "obj",
                    "description": "an object (or retrievable string) or an array of objects to start chain. will wait if there is promise",
                    "type": "Object"
                },
                {
                    "name": "schema",
                    "description": "(optional) a schema for entries. could be a retrievable",
                    "type": "Object"
                },
                {
                    "name": "options",
                    "description": "(optional) an option object. could contain : rethrow:true|false",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a deep handler that hold object(s)",
                "type": "DeepHandler"
            },
            "submodule": "deep.stores"
        },
        "DeepHandler": {
            "name": "DeepHandler",
            "shortname": "DeepHandler",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "deep",
            "namespace": "",
            "file": "deep.js",
            "line": 397,
            "description": "Deep Chain Handler  : manage asynch and synch in one chain",
            "is_constructor": 1,
            "params": [
                {
                    "name": "obj",
                    "description": "[description]",
                    "type": "Object"
                },
                {
                    "name": "schema",
                    "description": "[description]",
                    "type": "Object"
                }
            ]
        },
        "DeepDeferred": {
            "name": "DeepDeferred",
            "shortname": "DeepDeferred",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "deep",
            "namespace": "",
            "file": "deep.js",
            "line": 2859,
            "description": "A deep implementation of Deferred object (see promise on web)",
            "is_constructor": 1
        },
        "DeepPromise": {
            "name": "DeepPromise",
            "shortname": "DeepPromise",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "deep",
            "namespace": "",
            "file": "deep.js",
            "line": 2962,
            "description": "a deep implementation of Promise (see web for Promise)",
            "is_constructor": 1,
            "params": [
                {
                    "name": "deferred",
                    "description": "",
                    "type": "DeepDeferred"
                }
            ]
        },
        "utils": {
            "name": "utils",
            "shortname": "utils",
            "classitems": [],
            "plugins": [],
            "extensions": [],
            "plugin_for": [],
            "extension_for": [],
            "module": "deep",
            "submodule": "utils",
            "namespace": "",
            "file": "utils.js",
            "line": 15
        }
    },
    "classitems": [
        {
            "file": "testcases/app.js",
            "line": 1,
            "author": "Gilles Coomans <gilles.coomans@gmail.com>",
            "class": "Collider"
        },
        {
            "file": "deep-collider.js",
            "line": 38,
            "description": "wrap wrapped function with wrapper function. wrapped will receive ollided value as argument.",
            "itemtype": "method",
            "name": "wrap",
            "params": [
                {
                    "name": "wrapper",
                    "description": "",
                    "type": "Function"
                },
                {
                    "name": "wrapped",
                    "description": "",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "the wrapper",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 52,
            "description": "copy collided value somewhere",
            "itemtype": "method",
            "name": "copyTo",
            "params": [
                {
                    "name": "object",
                    "description": "where copy value",
                    "type": "Object"
                },
                {
                    "name": "path",
                    "description": "a dot delimitted path in object where copy value",
                    "type": "String"
                }
            ],
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 67,
            "description": "simply wrap collided value by wrapper function",
            "itemtype": "method",
            "name": "around",
            "params": [
                {
                    "name": "wrapper",
                    "description": "",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 80,
            "description": "replace collided value by new one",
            "itemtype": "method",
            "name": "replace",
            "params": [
                {
                    "name": "newValue",
                    "description": "the value to assign",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 94,
            "description": "log collided value",
            "itemtype": "method",
            "name": "log",
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 108,
            "description": "validate collided value with provided schema.\nthrow an error with report if not valid.",
            "itemtype": "method",
            "name": "validate",
            "params": [
                {
                    "name": "schema",
                    "description": "",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 125,
            "description": "remove collided value",
            "itemtype": "method",
            "name": "remove",
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 139,
            "category": [
                "assertions"
            ],
            "type": "{Object}",
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 144,
            "description": "assert is true on collided value.",
            "itemtype": "method",
            "name": "isTrue",
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 165,
            "description": "test equality (deep-equal) with collided value",
            "params": [
                {
                    "name": "equalTo",
                    "description": "the object to test",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "te collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 192,
            "category": [
                "array"
            ],
            "type": "{Object}",
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 197,
            "description": "reverse collided array",
            "itemtype": "method",
            "name": "reverse",
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-collider.js",
            "line": 211,
            "description": "remove value in array",
            "itemtype": "method",
            "name": "remove",
            "return": {
                "description": "the collider",
                "type": "Function"
            },
            "class": "Collider",
            "module": "deep",
            "submodule": "deep-collider"
        },
        {
            "file": "deep-compose.js",
            "line": 239,
            "description": "If it returns something, it will be injected as argument(s) in next function.\n\t\t\tIf it return nothing, th original arguments are injected in next function.\n\t\t\tIf it returns a promise or a chain : it will wait until the resolution of the returned value.\n\t\t\tIf the returned object isn't a promise, the next function is executed immediately.",
            "example": [
                "\n\n\t\t\t\tvar base = {\n\t\t\t\t    myFunc:deep.compose.after(function(arg)\n\t\t\t\t    {\n\t\t\t\t        return arg + \" _ myfunc base\";\n\t\t\t\t    })\n\t\t\t\t}\n\n\t\t\t\tdeep(base)\n\t\t\t\t.bottom({\n\t\t\t\t    myFunc:function(arg){\n\t\t\t\t        return arg + \" _ myfunc from bottom\";\n\t\t\t\t    }\n\t\t\t\t});\n\n\t\t\t\tbase.myFunc(\"hello\"); // will log 'bottom' then 'base'"
            ],
            "itemtype": "method",
            "name": "before",
            "chainable": 1,
            "params": [
                {
                    "name": "argument",
                    "description": "the function to execute BEFORE the collided one",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "",
                "type": "[type]"
            },
            "class": "DeepDecorator",
            "module": "deep",
            "submodule": "deep-compose"
        },
        {
            "file": "deep-compose.js",
            "line": 277,
            "description": "chainable around composition\n\n here you want to do your own wrapper.\n Juste provid a function that receive in argument the collided function (the one which is bottom),\n an which return the function that use this collided function.",
            "example": [
                "\n \t\tvar base = {\n\t\t\t\t\tmyFunc:function(arg)\n\t\t\t\t\t{\n\t\t\t\t\t\t\treturn arg + \" _ myfunc base\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdeep(base)\n\t\t\t\t.up({\n\t\t\t\t    myFunc:deep.compose.around(function(collidedMyFunc){\n\t\t\t\t    \treturn function(arg){\n\t\t\t\t    \t\treturn collidedMyFunc.apply(this, [arg + \" _ myfunc from around\"]);\n\t\t\t\t    \t}\n\t\t\t\t    })\n\t\t\t\t});\n\n\t\t\t\tbase.myFunc(\"hello\");"
            ],
            "itemtype": "method",
            "name": "around",
            "chainable": 1,
            "params": [
                {
                    "name": "wrapper",
                    "description": "a fonction to wrap the collided one",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDecorator"
            },
            "class": "DeepDecorator",
            "module": "deep",
            "submodule": "deep-compose"
        },
        {
            "file": "deep-compose.js",
            "line": 319,
            "description": "If the previous returns something, it will be injected as argument(s) in 'func'.\nIf the previous return nothing, th original arguments are injected in 'func'.\nIf the previous returns a promise or a chain : it will wait until the resolution of the returned value before executing 'func'.\nIf the previous returned object isn't a promise, 'func' is executed immediately.\n\nSame thing for returned object(s) from 'func' : it will be chained..",
            "example": [
                "\n\n\tvar base = {\n\t    myFunc:function(arg)\n\t    {\n\t        return arg + \" _ myfunc base\";\n\t    }\n\t}\n\n\tdeep(base)\n\t.up({\n\t    myFunc:deep.compose.after(function(arg){\n\t        return arg + \" _ myfunc from after\";\n\t    })\n\t});\n\n\tbase.myFunc(\"hello\"); // will log 'base' before 'after'"
            ],
            "itemtype": "method",
            "name": "after",
            "chainable": 1,
            "params": [
                {
                    "name": "argument",
                    "description": "the function to execute AFTER the collided one",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDecorator"
            },
            "class": "DeepDecorator",
            "module": "deep",
            "submodule": "deep-compose"
        },
        {
            "file": "deep-compose.js",
            "line": 359,
            "description": "wrap collided function with fn and execute fn only if collided function return an error.",
            "itemtype": "method",
            "name": "fail",
            "chainable": 1,
            "params": [
                {
                    "name": "fn",
                    "description": "",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDecorator"
            },
            "class": "DeepDecorator",
            "module": "deep",
            "submodule": "deep-compose"
        },
        {
            "file": "deep-compose.js",
            "line": 390,
            "description": "replace collided function by this one",
            "itemtype": "method",
            "name": "replace",
            "chainable": 1,
            "params": [
                {
                    "name": "argument",
                    "description": "",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDecorator"
            },
            "class": "DeepDecorator",
            "module": "deep",
            "submodule": "deep-compose"
        },
        {
            "file": "deep-compose.js",
            "line": 406,
            "description": "execute collided function PARALLELY with provided function\n\nwhen you want to call a function in the same time of an other, and to wait that both function are resolved (even if deferred)\nbefore firing eventual next composed function, you could use deep.compose.parallele( func )\n\nKeep in mind that the output of both functions will be injected as a single array argument in next composed function.\nBoth will receive in argument either the output of previous function (if any, an even if deferred), or the original(s) argument(s).\n\nSo as it implies that the forwarded arguments become an array : \nIt has to be used preferently with method(s) that do not need to handle argument(s), and that return a promise just for maintaining the chain asynch management.",
            "example": [
                "\n\n\t\tvar a = {\n\t\t\tload:function(){\n\t\t\t\treturn deep(\"json::myfile.json\")\n\t\t\t\t.done(function (success) {\n\t\t\t\t\t// do something\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tdeep({\n\t\t\tload:deep.compose.parallele(function(){\n\t\t\t\treturn deep(\"json::myotherfile.json\")\n\t\t\t\t.done(function (success) {\n\t\t\t\t\t// do something\n\t\t\t\t});\n\t\t\t})\n\t\t})\n\t\t.bottom(a)\n\t\t.load(); // will perform both loads (http get on json files) parallely (in the same time)"
            ],
            "itemtype": "method",
            "name": "parallele",
            "chainable": 1,
            "params": [
                {
                    "name": "argument",
                    "description": "",
                    "type": "[type]"
                }
            ],
            "return": {
                "description": "",
                "type": "[type]"
            },
            "class": "DeepDecorator",
            "module": "deep",
            "submodule": "deep-compose"
        },
        {
            "file": "deep-query.js",
            "line": 222,
            "description": "analyse path and return parsed paths objects",
            "params": [
                {
                    "name": "path",
                    "description": "",
                    "type": "String"
                }
            ],
            "return": {
                "description": "parsed paths",
                "type": "Array"
            },
            "class": "DeepQuery",
            "module": "deep",
            "submodule": "deep-query"
        },
        {
            "file": "deep-query.js",
            "line": 444,
            "description": "create a DeepQuery entry that hold info of objet node (path, value, ancestor, etc)",
            "itemtype": "method",
            "name": "createEntry",
            "params": [
                {
                    "name": "key",
                    "description": "",
                    "type": "[type]"
                },
                {
                    "name": "ancestor",
                    "description": "",
                    "type": "[type]"
                }
            ],
            "return": {
                "description": "",
                "type": "[type]"
            },
            "class": "DeepQuery",
            "module": "deep",
            "submodule": "deep-query"
        },
        {
            "file": "deep-query.js",
            "line": 731,
            "description": "perform the query on object",
            "itemtype": "method",
            "name": "query",
            "params": [
                {
                    "name": "obj",
                    "description": "any object to query on",
                    "type": "Object"
                },
                {
                    "name": "q",
                    "description": "the query",
                    "type": "String"
                },
                {
                    "name": "options",
                    "description": "(optional) :  options : resultType:\"full\" when you want to get the array of nodes results, not only the values results.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "an array of results (maybe empty)",
                "type": "Array"
            },
            "class": "DeepQuery",
            "module": "deep",
            "submodule": "deep-query"
        },
        {
            "file": "deep-query.js",
            "line": 818,
            "description": "perform the query (static access of query method)",
            "static": 1,
            "itemtype": "method",
            "name": "query",
            "params": [
                {
                    "name": "root",
                    "description": "",
                    "type": "Object"
                },
                {
                    "name": "path",
                    "description": "",
                    "type": "String"
                },
                {
                    "name": "options",
                    "description": "",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "results",
                "type": "Array"
            },
            "class": "DeepQuery",
            "module": "deep",
            "submodule": "deep-query"
        },
        {
            "file": "deep-query.js",
            "line": 834,
            "description": "create a root DeepQuery node",
            "static": 1,
            "itemtype": "method",
            "name": "createRootNode",
            "params": [
                {
                    "name": "obj",
                    "description": "",
                    "type": "Object"
                },
                {
                    "name": "schema",
                    "description": "",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a DeepQuery root node",
                "type": "Object"
            },
            "class": "DeepQuery",
            "module": "deep",
            "submodule": "deep-query"
        },
        {
            "file": "deep-request.js",
            "line": 1,
            "author": "Gilles Coomans <gilles.coomans@gmail.com>\nDeepRequest : a set of useful function to retreieve ressources",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep-request.js",
            "line": 5,
            "description": "TODO : DeepRequest.late.post(...) : return function which will do post later\n\ncrossDomainXML : add options with proxy or YQL\n\nmaintain cache for each reload seqquence : if in the same load bunch there is sam paths : use cache in place of retreieve multiple time the same file\n\nprotocole to add : \n\ndata-model::\nfs::\n\n\n\n\nprotocoles :\n\nextensions : \n\nparsers : \n\nresponseParser\n\tread reponse.headers.contentType : \n\t\nvar jqueryRequest = function(info, options){\n\toptions = options || {};\n\tvar headers = options.headers || {};\n\tutils.up(this.requestHeaders, headers);\n\tvar self = this;\n\treturn promise.when($.ajax({\n\t\tbeforeSend :function(req) {\n\t\t\twriteJQueryHeaders(req, headers);\n\t\t},\n\t\turl:info.uri, \n\t\tmethod:\"GET\", \n\t\tdata:null,\n\t\tdatatype:self.options.datatype || \"json\"\n\t})\n\t.done(function (  data, msg, jqXHR ) {\n\t\treturn self.parse(data, info, options);\n\t})\n\t.fail(function ( jqXHR ) {\n\t\treturn new Error(\"DeepRequest.load failed : \"+JSON.stringify(info));\n\t}))\n}\nvar setHeaders = function (req) {\n\t\n}\n\nvar deepAction = {\n\t\"dom.appendTo\" : { // dom.appendTo::#id\n\t\taction:function (info, datas) {\n\t\t\t// body...\n\t\t}\n\t}\n}\n\nvar vc = {\n\tplaceInDOM:deep.action(\"dom.appendTo::#id\")\n}\nvar dr = {\n\tlexic:{\n\t\tjson:{\n\t\t\toptions:{\n\t\t\t\tqueriable:true,\n\t\t\t\tdatatype:\"json\"\n\t\t\t},\n\t\t\trequestHeaders:{\n\t\t\t\t\"accept\":\"application/json;charset=utf-8\"\n\t\t\t},\n\t\t\tresponseHeaders:{\n\t\t\t\t\"content-type\":\"application/json;charset=utf-8\"\n\t\t\t},\n\t\t\taction:baseRequest,\n\t\t\tparse:function(response, infos, options) {\n\t\t\t\t// body...\n\t\t\t}\n\t\t},\n\t\thtml:{\n\t\t\toptions:{\n\t\t\t\tqueriable:false,\n\t\t\t\tdatatype:\"html\"\n\t\t\t},\n\t\t\trequestHeaders:{\n\t\t\t\t\"accept\":\"text/html;charset=utf-8\"\n\t\t\t},\n\t\t\tresponseHeaders:{\n\t\t\t\t\"content-type\":\"text/html;charset=utf-8\"\n\t\t\t},\n\t\t\taction:baseRequest,\n\t\t\tparse:function(response, infos, options) {\n\t\t\t\t// body...\n\t\t\t}\n\t\t}\n\t},\n\tget:function (info, options) {\n\t\tif(typeof info === 'string')\n\t\t\tinfo = this.parse(info);\n\t\tvar handler = this.lexic[info.protocole];\n\t\tif(!handler)\n\t\t\tthrow new Error(\"DeepRequest : no handler found with : \",info); \n\t\treturn handler.action(info, options);\n\t}\n\tall\n\t_______\n\n\tjson\n\txml\n\trss\n\ttext\n\thtml\n\n}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep-restart.js",
            "line": 352,
            "description": "select login controller : give controller chain",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep-restart.js",
            "line": 388,
            "description": "Permit to manipulate server store through restful IO...",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep-restart.js",
            "line": 395,
            "description": "Do post on login services.\n\t\tIf arg is provided : post arg as login object.\n\t\tIf no args : use from ui if possible",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep-restart.js",
            "line": 406,
            "description": "get object from store",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep-rql.js",
            "line": 14,
            "description": "TODO : \nadd distinct(testPropertyPath)\nadd merge()\nadd backgrounds()  :  do object extension with deep-extender + schema\n\n\n\nadd _ancestor (any ancestor)\nadd _brothers  (any brothers)\n\n! TEST ALL operations !",
            "class": "deep",
            "module": "deep",
            "submodule": "deep-rql"
        },
        {
            "file": "deep-schema.js",
            "line": 208,
            "description": "TODO : \njson-pointer dereferencement\t\t\t\t\t\t\tOK\nadd relative reference to json-pointer\t\t\t\t\tOK\ndependencies : clarify, and/or implement if(constraint.match(root)) constraint(value)\nlinks dereferencer  : template-engine + instance injection + DeepRequest.retrieve\nréférencement interne : backgrounds ou $ref with json-pointer\t\t\t\t\tOK\n\n\n\nPatterns :\n\t- name patterns + data : regExp, enum, direct       (could be external)\n\t- query pattern : if query then pattern match\n\n\tproperties:{\n\t\tchristophil:{\n\t\t\tdependenciesQueries:\n\t\t\t{\n\t\t\t\tmatchEurope:{     // it's the relation/dependency name\n\t\t\t\t\tquery:\"\",\n\t\t\t\t\trequired:true,   // mean that the query MUST give something : so the dependency MUST be valid\n\t\t\t\t\tpatternProperties:{\n\t\t\t\t\t\t\"$ref\":[ \"json::/Pathologies/?type=perenial&zone=europe&$result=hash\" ]  // exemple of external patterns definitions\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tmatchUK:{\n\t\t\t\t\tquery:\"\";\n\t\t\t\t\trequired:false,  // optional dependency\n\t\t\t\t\tproperties:{\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\nproperty name + data pattern : could be an external link to a service that provides a list of acceptable values.\nImagine you would define a pathologie list for plants. Each plant could be sensible to a subset of those pathologies, and could have different kinds of sensibility...\nThe service could provids the list of known pathologies, and the subset have to match",
            "class": "deep",
            "module": "deep",
            "submodule": "deep-schema"
        },
        {
            "file": "deep-schema.js",
            "line": 253,
            "description": "console.flags : {\n\tvalidationError,\n\tvalidator\n}",
            "class": "deep",
            "module": "deep",
            "submodule": "deep-schema"
        },
        {
            "file": "deep.js",
            "line": 2,
            "author": "Gilles Coomans <gilles.coomans@gmail.com>",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 117,
            "description": "rethrow any throw during chain execution.",
            "itemtype": "property",
            "name": "rethrow",
            "static": 1,
            "type": "{Boolean}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 125,
            "description": "final namespace for deep/utils",
            "static": 1,
            "itemtype": "property",
            "name": "utils",
            "type": "{Object}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 132,
            "description": "perform a deep-schema validation",
            "static": 1,
            "itemtype": "method",
            "name": "validate",
            "type": "{Function}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 139,
            "description": "perform a deep-schema partial validation",
            "static": 1,
            "itemtype": "method",
            "name": "partialValidation",
            "type": "{Function}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 146,
            "description": "final namespace for deep/deep-compose",
            "static": 1,
            "itemtype": "property",
            "name": "compose",
            "type": "{Object}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 153,
            "description": "are you on nodejs or not",
            "static": 1,
            "itemtype": "property",
            "name": "isNode",
            "type": "{Boolean}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 160,
            "description": "perform a deep-rql query",
            "static": 1,
            "itemtype": "method",
            "name": "rql",
            "type": "{Function}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 167,
            "description": "perform a deep-query query",
            "itemtype": "method",
            "name": "query",
            "static": 1,
            "type": "{Function}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 174,
            "description": "final namespace for deep/deep-collider",
            "static": 1,
            "itemtype": "property",
            "name": "collider",
            "type": "{Object}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 181,
            "description": "final namespace for deep/deep-query",
            "static": 1,
            "itemtype": "property",
            "name": "Querier",
            "type": "{DeepQuery}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 188,
            "description": "shortcut for utils.interpret",
            "static": 1,
            "itemtype": "method",
            "name": "interpret",
            "type": "{Function}",
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 429,
            "description": "allow to create chain branches \n\nsynch\ntransparent : not relevant",
            "itemtype": "method",
            "name": "brancher",
            "return": {
                "description": "brancher function"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 454,
            "description": "reverse entries order\n\ninject entries values as chain success.",
            "chainable": 1,
            "itemtype": "method",
            "name": "reverse",
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 474,
            "description": "catch any throwned error while chain running\n\nasycnh\ntransparent true",
            "itemtype": "method",
            "name": "catchError",
            "chainable": 1,
            "params": [
                {
                    "name": "catchIt",
                    "description": "if true : catch all future chain error. (true by default)",
                    "type": "Boolean"
                }
            ],
            "return": {
                "description": "",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 500,
            "description": "cancel chain. \n\nend of chain\nsynch",
            "itemtype": "method",
            "name": "cancel",
            "params": [
                {
                    "name": "reason",
                    "description": "the reason of the chain cancelation (any string or object)"
                }
            ],
            "return": {
                "description": "nothing"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 520,
            "description": "reject chain. \n\nend of chain\nsynch",
            "itemtype": "method",
            "name": "reject",
            "params": [
                {
                    "name": "reason",
                    "description": "the reason of the chain cancelation (any string or object)",
                    "type": "*"
                }
            ],
            "return": {
                "description": "nothing"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 541,
            "description": "asynch handler for chain branches creation\n\nif you return the branches function (the branch creator) : the chain will wait until all the branches are done before continuing\n\n Inject function result in chain as success or error.",
            "example": [
                "\n\tchain.branches( function(branches)\n\t{\n\t\tbranches.branch().query(...).load().log()\n\t\tbranches.branch().query(...).post().log();\n\t\t//...\n\t\treturn branches;\n\t});\n\n\t// if you want to return a subset of branches promises : \n\t// you could use deep.all([array_of_promises]) :\n\n\t\tvar branch = branches.branch().myChain()...;\n\t\t//...\n\t\treturn deep.all([deep.promise(branch), ...]);"
            ],
            "itemtype": "method",
            "name": "branches",
            "async": 1,
            "chainable": 1,
            "params": [
                {
                    "name": "func",
                    "description": "the callback that will receive the brancher (see above)",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 591,
            "description": "wait promise resolution or rejection before continuing chain\n\n\tasynch\n\ttransparent false",
            "itemtype": "method",
            "name": "when",
            "params": [
                {
                    "name": "prom",
                    "description": "the promise to waiting for",
                    "type": "Promise"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "",
                "type": "Deephandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 622,
            "description": "handle previous chain's handle success\n\nthe callback receive 3 arguments : \n\t\tsuccess, handler, brancher\n\nthe success is the success object produced by previous chain's handle\nthe handler is the chain handle itself\nthe brancher is the brancher function that create clone of the chain to produce chain branches\n\n\tasynch",
            "itemtype": "method",
            "name": "done",
            "chainable": 1,
            "params": [
                {
                    "name": "callback",
                    "description": "the calback function to handle success"
                }
            ],
            "return": {
                "description": "Deephandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 675,
            "description": "handle previous chain handle error\n\nthe callback receive 3 arguments : \n\t\terror, handler, brancher\n\nthe error is the success object produced by previous chain's handle\nthe handler is the chain handle itself\nthe brancher is the brancher function that create clone of the chain to produce chain branches\n\n\tasynch",
            "itemtype": "method",
            "name": "fail",
            "chainable": 1,
            "params": [
                {
                    "name": "callback",
                    "description": "the calback function to handle error"
                }
            ],
            "return": {
                "description": "Deephandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 723,
            "description": "handle previous chain handle success and error\n\n\tadd a .done and a .fail (orderedly) in chain with callbacks.",
            "itemtype": "method",
            "name": "then",
            "params": [
                {
                    "name": "successCallBack",
                    "description": "the calback function to handle success"
                },
                {
                    "name": "errorCallBack",
                    "description": "the calback function to handle error"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this",
                "type": "Deephandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 743,
            "description": "perform a range on chain entries : so will remove any chain entries of of range index.\n\n\tasynch\n\n\n inject a rangeObject as chain success : \n \t{\n \t\tstart:number,\n \t\tend:number,\n \t\ttotal:number,\n \t\tresults:Array,\n \t\thasNext:boolean,\n \t\thasPrevious:boolean\n \t}",
            "example": [
                "\n\tdeep([0,1,2,3,4,5])\n\t.range(1,4)\n\t.valuesEqual([1,2,3,4]);\n\n\tdeep([0,1,2,3,4,5])\n\t.range(3,5)\n\t.valuesEqual([3,4,5]);"
            ],
            "itemtype": "method",
            "name": "range",
            "params": [
                {
                    "name": "start",
                    "description": "the index of range start"
                },
                {
                    "name": "end",
                    "description": "the index of range end"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 787,
            "description": "save current chain position. it means that it will save\n\t- current entries \n\t- current success and errors\n\t- current store (if any) in private queue before continuing.\n\n\tasynch\n\ttransparent true",
            "itemtype": "method",
            "name": "position",
            "params": [
                {
                    "name": "name",
                    "description": "the name of position (its id/label)"
                },
                {
                    "name": "options",
                    "description": "optional object (no options for the moment)"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 812,
            "description": "go back to a previously saved position (see .position).\nIf no name is provided : go back to last position (if any)\n\nthrow an error if no position founded.\n\ninject chain values as chain success",
            "itemtype": "method",
            "name": "back",
            "chainable": 1,
            "params": [
                {
                    "name": "name",
                    "description": "the name of the last position asked"
                },
                {
                    "name": "options",
                    "description": "(optional - no options for the moment)"
                }
            ],
            "return": {
                "description": "",
                "type": "[type]"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 858,
            "description": "keep only the first chain entries. remove all others\n\nasynch\ninject selected entry value as chain success",
            "chainable": 1,
            "itemtype": "method",
            "name": "first",
            "return": {
                "description": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 879,
            "description": "keep only the last chain entries. remove all others\n\nasynch\ninject selected entry value as chain success",
            "chainable": 1,
            "itemtype": "method",
            "name": "last",
            "return": {
                "description": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 900,
            "description": "take current entries parents (if any) as new entries.\n\ninject new entries values as chain success.\n\nasynch",
            "itemtype": "method",
            "name": "parents",
            "chainable": 1,
            "params": [
                {
                    "name": "boolean",
                    "description": "errorIfEmpty : if true and no parents was selected : throw an error"
                }
            ],
            "return": {
                "description": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 930,
            "description": "take object, shcema, options and create fresh chain entries from it. Same mecanism as new chain.",
            "itemtype": "method",
            "name": "root",
            "chainable": 1,
            "params": [
                {
                    "name": "object",
                    "description": "the object to produce entries  (could be a retrievable string - e.g. \"json::myobject.json\" - see retrievable doc)"
                },
                {
                    "name": "schema",
                    "description": "the schema of the object  (could be a retrievable string - e.g. \"json::myobject.json\" - see retrievable doc)"
                }
            ],
            "return": {
                "description": "[DeepHandler] this"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 954,
            "description": "Apply the query on EACH chain entries and concatened all the results to form new chain entries.\n\n\ninject queried results as chain success",
            "itemtype": "method",
            "name": "query",
            "chainable": 1,
            "params": [
                {
                    "name": "q",
                    "description": "the deep-query. Could be an ARRAY of Queries : the result will be the concatenation of all queries on all entries",
                    "type": "String"
                },
                {
                    "name": "errorIfEmpty",
                    "description": ": if true : throw an error if query return nothing",
                    "type": "Boolean"
                }
            ],
            "return": {
                "description": "this (chain handler)",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 990,
            "description": "same as .query : but in place of holding queried entries : it return directly the query results.\nIs the synch version of the query handle.\n\nsynch true\ntransparent false",
            "itemtype": "method",
            "name": "select",
            "chainable": 1,
            "params": [
                {
                    "name": "q",
                    "description": "the deep-query. Could be an ARRAY of Queries : the result will be the concatenation of all queries on all entries",
                    "type": "String"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1016,
            "description": "set schema of all entries (purely assignation)\ninject entries shemas as chain success",
            "itemtype": "method",
            "name": "schema",
            "chainable": 1,
            "params": [
                {
                    "name": "schema",
                    "description": "could be a retrievable string (e.g. \"json::myschema.json\" - see retrievable doc)",
                    "type": "String|object"
                }
            ],
            "return": {
                "description": "this (chain handler)",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1047,
            "description": "apply provided schema on all entries schemas (.up application)\ninject entries shemas as chain success",
            "itemtype": "method",
            "name": "schemaUp",
            "chainable": 1,
            "params": [
                {
                    "name": "schema",
                    "description": "could be a retrievable string (e.g. \"json::myschema.json\" - see retrievable doc)",
                    "type": "String|object"
                }
            ],
            "return": {
                "description": "this (chain handler)",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1085,
            "description": "apply provided schema on all entries schemas (.bottom application)\n\ninject entries shemas as chain success",
            "itemtype": "method",
            "name": "schemaBottom",
            "chainable": 1,
            "params": [
                {
                    "name": "schema",
                    "description": "could be a retrievable string (e.g. \"json::myschema.json\" - see retrievable doc)",
                    "type": "String|object"
                }
            ],
            "return": {
                "description": "this (chain handler)",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1127,
            "description": "set entries properties by path.\n\nsynch\ninject setted values as chain success",
            "itemtype": "method",
            "name": "setByPath",
            "chainable": 1,
            "params": [
                {
                    "name": "path",
                    "description": "a slash delimitted path (e.g. \"/my/property\")",
                    "type": "String"
                },
                {
                    "name": "obj",
                    "description": "the value to assign (could be a retrievable strings)",
                    "type": "Object|primitive"
                }
            ],
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1159,
            "description": "apply arguments from UP on each entries : will merge objects and array together DEEPLY. see docs and examples.\n\nsynch\ninject entries values as chain success.",
            "itemtype": "method",
            "name": "up",
            "chainable": 1,
            "params": [
                {
                    "name": "objects",
                    "description": "a list (coma separated - not an array) of objects to apply on each chain entries"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1194,
            "description": "apply arguments from BOTTOM on each entries : will merge objects and array together DEEPLY. see docs and examples.\n\n synch\n inject entries values as chain success.",
            "itemtype": "method",
            "name": "bottom",
            "chainable": 1,
            "params": [
                {
                    "name": "objects",
                    "description": "a list (coma separated - not an array) of objects to apply on each chain entries"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1229,
            "description": "synch\n \n replace queried entries properties by new value and inject replaced properties as chain success.",
            "example": [
                "\n\t\t \n\tvar a = {\n\t\taString : \"Hello\",\n\t\tanInt : 5,\n\t\tanArray : [\"1\",\"2\",\"3\"],\n\t\tanObject : {\n\t\t\tanArray : [\"4\",\"5\",\"6\"],\n\t\t\taString : \"World\"\n\t\t}\n\t}\n\tdeep(a)\n\t.replace(\"./anArray/1\",\"replaceString\")\n\t.equal({\n\t\taString : \"Hello\",\n\t\tanInt : 5,\n\t\tanArray : [\"1\",\"replaceString\",\"3\"],\n\t\tanObject : {\n\t\t\tanArray : [\"4\",\"5\",\"6\"],\n\t\t\taString : \"World\"\n\t\t}\n\t});"
            ],
            "itemtype": "method",
            "name": "replace",
            "params": [
                {
                    "name": "what",
                    "description": "a query to select properties to replace",
                    "type": "String"
                },
                {
                    "name": "by",
                    "description": "any value to assign (could be a retrievable string)",
                    "type": "Object"
                },
                {
                    "name": "options",
                    "description": "(optional) : it is the options object for the deep.get which will eventually retrieve the 'by' object (see deep.get)",
                    "type": "Object"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1290,
            "description": "remove queried properties from entries and inject removed properties as chain success.",
            "example": [
                "\n\tvar a = {\n\t\taString : \"Hello\",\n\t\tanInt : 5,\n\t\tanArray : [\"1\",\"2\",\"3\"],\n\t\tanObject : {\n\t\t\tanArray : [\"4\",\"5\",\"6\"],\n\t\t\taString : \"World\"\n\t\t}\n\t}\n\n\tdeep(a)\n\t.remove(\"./anArray/1\").log().valuesEqual([{\n\t\taString : \"Hello\",\n\t\tanInt : 5,\n\t\tanArray : [\"1\",\"3\"],\n\t\tanObject : {\n\t\t\tanArray : [\"4\",\"5\",\"6\"],\n\t\t\taString : \"World\"\n\t\t}\n\t}]);",
                "\n\n\tvar obj = { \n\t\temail: 'test@test.com',\n\t\tpassword: 'test54',\n\t \tid: '51013dec530e96b112000001' \n\t}\n\t var schema = { \n\t \tproperties: \n\t\t{ \n\t\t  \tid: { type: 'string', required: false, minLength: 1 },\n\t\t    email: { type: 'string', required: true, minLength: 1 },\n\t\t    password: { type: 'string', required: true, \"private\": true } \n\t\t},\n\t \tadditionalProperties: false \n\t}\n\n\tdeep(obj, schema)\n\t.remove(\".//*?_schema.private=true\")\n\t.equal({ \n\t\temail: 'test@test.com',\n\t \tid: '51013dec530e96b112000001' \n\t });"
            ],
            "chainable": 1,
            "itemtype": "method",
            "name": "remove",
            "params": [
                {
                    "name": "what",
                    "description": "a query to select properties to replace",
                    "type": "String"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1369,
            "description": "will perform the backgrounds application on any backgrounds properties at any level\n\n\tnot intend to be call directly by programmer. use at your own risk. use .flatten instead.",
            "itemtype": "method",
            "name": "extendsChilds",
            "access": "private",
            "tagname": "",
            "params": [
                {
                    "name": "entry",
                    "description": "from where seeking after backgrounds properties",
                    "type": "DeepEntry"
                }
            ],
            "return": {
                "description": "a promise",
                "type": "DeepPromise"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1403,
            "description": "will perform the backgrounds application FIRSTLY and FULLY (full recursive) on current entries before appying extendsChild.\n\n\tnot intend to be call directly by programmer. use at your own risk.  use .flatten instead.",
            "itemtype": "method",
            "name": "extendsBackgrounds",
            "access": "private",
            "tagname": "",
            "params": [
                {
                    "name": "entry",
                    "description": "from where seeking after backgrounds properties",
                    "type": "DeepEntry"
                }
            ],
            "return": {
                "description": "a promise",
                "type": "DeepPromise"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1458,
            "description": "will perform FULL backgrounds application on chain entries. (see backgrounds documentation)\n\nSuccess injected : entries values\nErrors injected : any flatten error",
            "example": [
                "\n\tvar a = {\n\t    obj:{\n\t    \tfirst:true\n\t    },\n\t    myFunc:function(){\n\t        console.log(\"base myFunc\");\n\t        this.obj.a = true;\n\t    }\n\t}\n\n\tvar b = {\n\t\tbackgrounds:[a],\n\t\tobj:{\n\t\t\tsecond:true\n\t\t},\n\t\tmyFunc:deep.compose.after(function()\n\t\t{\n\t\t\tconsole.log(\"myFunc of b : \", this)\n\t\t\tthis.obj.b = true;\n\t\t})\n\t}\n\n\tdeep({})\n\t.bottom(b)\n\t.flatten()\n\t.run(\"myFunc\")\n\t.query(\"./obj\")\n\t.equal({\n  \t\tfirst:true,\n  \t\tsecond:true,\n       a:true,\n       b:true\n   });\n\n\tdeep({\n\t    sub:{\n\t        backgrounds:[b],\n\t        obj:{\n\t        \tthird:true\n\t        }\n\t    }\n\t})\n\t.flatten()\n\t.query(\"/sub\")\n\t.run(\"myFunc\")\n\t.query(\"./obj\")\n\t .equal({\n   \tfirst:true,\n  \t\tsecond:true,\n  \t\tthird:true,\n       a:true,\n       b:true\n   });"
            ],
            "chainable": 1,
            "async": 1,
            "itemtype": "method",
            "name": "flatten",
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1572,
            "description": "transform : loop on entries, apply 'func' with 'args' on each entry : replace entries values with func result\nfunction could return promise.\n\n- loop on entries : true\n- chainable : true\n- transparent : false\n- promised management : true\n- success injected : the array of results of each call on func\n- error injected : any error returned (or produced) from a func call",
            "itemtype": "method",
            "name": "transform",
            "chainable": 1,
            "params": [
                {
                    "name": "func",
                    "description": "any function that need to be apply on each chain entry",
                    "type": "Function"
                },
                {
                    "name": "args",
                    "description": "the arguments to pass to 'func'",
                    "type": "Array"
                }
            ],
            "return": {
                "description": "the current chain handler (this)",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1617,
            "description": "run : loop on entries, apply 'func' with 'args' on each entry (entry become 'this' of func)\nfunction could retrun promise.\n\n- loop on entries : true\n- chainable : true\n- transparent : false\n- promised management : true\n- success injected : the array of results of each call on func\n- error injected : any error returned (or produced) from a func call",
            "itemtype": "method",
            "name": "run",
            "chainable": 1,
            "params": [
                {
                    "name": "func",
                    "description": "any function that need to be apply on each chain entry",
                    "type": "Function"
                },
                {
                    "name": "args",
                    "description": "the arguments to pass to 'func'",
                    "type": "Array"
                }
            ],
            "return": {
                "description": "the current chain handler (this)",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1672,
            "description": "exec :  call 'func' with 'args' (the 'this' of the function isn't modified)\nfunction could retruen promise.\n\n- loop on entries : false\n- chainable : true\n- transparent : false\n- promised management : true\n- success injected : the result of the call on func\n- error injected : any error returned (or produced) from func call",
            "itemtype": "method",
            "name": "exec",
            "chainable": 1,
            "params": [
                {
                    "name": "func",
                    "description": "any function that need to be apply on each chain entry",
                    "type": "Function"
                },
                {
                    "name": "args",
                    "description": "the arguments to pass to 'func'",
                    "type": "Array"
                }
            ],
            "return": {
                "description": "the current chain handler (this)",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1711,
            "description": "apply a 'treatments' on chain entries (each entry will be the context of the treatment). (renderables are treatments - see doc and example).\n\na treaments is an object that contains : {\n  what : (optional) object|retrievable_string a value to inject in 'how' function. if no 'what' is provided : inject the entry (the context) in 'how'\n\t how : a function to treat 'what' (simple function that have a single argument (what) and return its result),\n\t where: (optional) a function to send the results somewhere, return the descriptor of the sended ressource (see deep-ui : dom.apendTo for example),\n\t done : a callback function that will be called on treated entry (the context of the done) when treatment succeed\n\t fail : a callback function that will be called on treated entry (the context of the fail) when treatment failed\n}\n\nif entry contain a 'treat' function : will be called and provided treatment will be passed as argument\n\nKeep previous entries (maybe modified by treatment)\n\nChain Success Injection : the treatments results\nChain Error Injection : the treatments errors",
            "itemtype": "method",
            "name": "treat",
            "params": [
                {
                    "name": "treatment",
                    "description": "",
                    "type": "Object"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1765,
            "description": "valuesEqual : test strict equality between the array of entries values and a provided array of value\n\n- loop on entries : false\n- chainable : true\n- transparent : false\n- promised management : true (on callBack)\n- success injected : the result of the callBack or the report if callback returned nothing\n- error injected : the report or any error returned (or produced) from callBack\n\n\n\tChain Success injection : the valid report\n\tChain Error injection : the unvalid report",
            "itemtype": "method",
            "name": "valuesEqual",
            "params": [
                {
                    "name": "obj",
                    "description": "the object to test equality",
                    "type": "Object"
                },
                {
                    "name": "callBack",
                    "description": "optional : any callBack to manage the report. Could return a promise.",
                    "type": "Function"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1818,
            "description": "equal test strict equality on each entry value against provided object\n\n\tChain Success injection : the valid report\n\tChain Error injection : the unvalid report",
            "itemtype": "method",
            "name": "equal",
            "params": [
                {
                    "name": "obj",
                    "description": "the object to test",
                    "type": "*"
                },
                {
                    "name": "optional.",
                    "description": "callBack a callBack to manage report",
                    "type": "Function"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1879,
            "description": "validate apply validation\n\n\tChain Success injection : the valid report\n\tChain Error injection : the unvalid report",
            "itemtype": "method",
            "name": "validate",
            "params": [
                {
                    "name": "options",
                    "description": "[description]",
                    "type": "Object"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "[description]",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1937,
            "description": "log any provided arguments.\n If no arguments provided : will log current success or error state.\n\n asynch\n transparent true",
            "itemtype": "method",
            "name": "log",
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "chainable": 1,
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 1979,
            "description": "log current chain entries  with optional title\n\n full option means print full entry in place of just entry.value\n pretty option means print pretty json (indented)\nasynch\n transparent true",
            "itemtype": "method",
            "name": "logValues",
            "chainable": 1,
            "params": [
                {
                    "name": "title",
                    "description": "(optional) the title you want"
                },
                {
                    "name": "options",
                    "description": "(optional) : an object",
                    "type": "Full:true|false, pretty:true|false"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2028,
            "description": "if no callBack is present : just return the FIRST value of entries. It's a chain end handle.\n If callback is provided : the FIRST entry  value will be passed as argument to callback.\n \t\tand so th chain could continue : the return of this handle is the deep handler.\ntransparent true",
            "itemtype": "method",
            "name": "val",
            "params": [
                {
                    "name": "callBack",
                    "description": ""
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this or val",
                "type": "Deephandler|entry.value"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2066,
            "description": "will passe as argument each entries to callback.\n callback could return promise. the chain will wait any promise before continuing.\n\n\n\tChain Success injection : the results of callback calls (resolved if promises)\n\tChain Error injection : the errors of callback calls (rejected if promises)",
            "itemtype": "method",
            "name": "each",
            "chainable": 1,
            "params": [
                {
                    "name": "callBack",
                    "description": ""
                }
            ],
            "return": {
                "description": "this",
                "type": "Deephandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2101,
            "description": "if no callBack is present : just return the array of values of entries. It's a chain end handle.\n If callback is provided : the entries values will be passed as argument to callback.\n \t\tand so th chain could continue : the return of this handle is the deep handler.\ntransparent true",
            "itemtype": "method",
            "name": "values",
            "chainable": 1,
            "params": [
                {
                    "name": "callBack",
                    "description": ""
                }
            ],
            "return": {
                "description": "this or values",
                "type": "Deephandler|Array"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2140,
            "description": "if no callBack is present : just return the array of entries. It's a chain end handle.\n If callback is provided : the entries will be passed as argument to callback.\n \t\tand so th chain could continue : the return of this handle is the deep handler.\n \n transparent true",
            "itemtype": "method",
            "name": "nodes",
            "chainable": 1,
            "params": [
                {
                    "name": "callBack",
                    "description": ""
                }
            ],
            "return": {
                "description": "this or entries",
                "type": "Deephandler|Array"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2176,
            "description": "if no callBack is present : just return the array of paths of entries. It's a chain end handle.\n If callback is provided : the entries paths will be passed as argument to callback.\n \t\tand so th chain could continue : the return of this handle is the deep handler.\ntransparent true",
            "chainable": 1,
            "itemtype": "method",
            "name": "paths",
            "params": [
                {
                    "name": "callBack",
                    "description": ""
                }
            ],
            "return": {
                "description": "this or paths",
                "type": "Deephandler|Array"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2214,
            "description": "if no callBack is present : just return the array of schemas of entries. It's a chain end handle.\n If callback is provided : the entries schemas will be passed as argument to callback.\n \t\tand so th chain could continue : the return of this handle is the deep handler.\n \n transparent true",
            "chainable": 1,
            "itemtype": "method",
            "name": "schemas",
            "params": [
                {
                    "name": "callBack",
                    "description": ""
                }
            ],
            "return": {
                "description": "this or schemas",
                "type": "Deephandler|Array"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2254,
            "description": "will wait xxxx ms before contiuing chain\n\ntransparent true",
            "chainable": 1,
            "itemtype": "method",
            "name": "delay",
            "params": [
                {
                    "name": "ms",
                    "description": "",
                    "type": "Number"
                }
            ],
            "return": {
                "description": "this",
                "type": "Deephandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2284,
            "description": "will seek in entries after any retrievable string OR executable functions : and will replace references by loaded/returned content.\n\nif context is provided : will try to 'interpret' (see .interpret) strings before retrieving them.\n\nChain Success injection : array of loaded results",
            "itemtype": "method",
            "name": "deepLoad",
            "params": [
                {
                    "name": "context",
                    "description": "(optional) a context to interpret strings before retrieving",
                    "type": "Object"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2344,
            "description": "if request is provided : \n \t\ttry to retrieve 'request' and replace entries values by loaded result\n \telse\n \t\twill try to retrieve any entry.value strings (will not seek deeply) and replace associated entries values by loaded result.\n \t\tOR if entry.value is an object : look if there is any .load() function in it. If so : fire it.\n \n if context is provided : will try to 'interpret' (see .interpret) strings before retrieving them.\n \t(on request or entries values)\nChain success injection : array of loaded content.",
            "itemtype": "method",
            "name": "load",
            "params": [
                {
                    "name": "(optional)",
                    "description": "request",
                    "type": "String"
                },
                {
                    "name": "(optional)",
                    "description": "context the context to interpret strings",
                    "type": "Object"
                }
            ],
            "chainable": 1,
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2447,
            "description": "seek after any strings and try to interpret it with current context.\nsee interpretation for simple case",
            "example": [
                "\n \n \t\tdeep({ msg:\"hello { name }\" }).deepInterpret({ name:\"john\" }).logValues().equal({ msg:\"hello john\" });"
            ],
            "itemtype": "method",
            "name": "deepInterpret",
            "chainable": 1,
            "params": [
                {
                    "name": "context",
                    "description": "the oebjct to inject in strings",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2496,
            "description": "will interpret entries values with context",
            "example": [
                "  \n\t \tdeep(\"hello { name }\").interpret({ name:\"john\" }).val();\n  \t//will provide \"hello john\".\n\t\tdeep({\n    \t\tmsg:\"hello { name }\"\n\t\t})\n\t\t.query(\"./msg\")\n\t\t.interpret({ name:\"john\" })\n\t\t.logValues()\n\t\t.equal(\"hello john\");"
            ],
            "itemtype": "method",
            "name": "interpret",
            "chainable": 1,
            "params": [
                {
                    "name": "context",
                    "description": "the context to inject in strings",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2695,
            "description": "It's the way of performing a SQL JOIN like between two objects.\nObjects could be retrievables.\n\ntake current entries, seek after localKeys, use it to get 'what' with foreignKey=localKey, and finnaly store result at 'whereToStore' path in current entries values.",
            "example": [
                "\n\n\tdeep([{ title:\"my title\", id:1}, { title:\"my title 2\", id:2}])\n\t.mapOn([\n\t    {itemId:1, value:true}, \n\t    {itemId:2, value:\"133\"}, \n\t    {itemId:2, value:\"hello\"}\n\t    ], \n\t    \"id\",\"itemId\",\"linkeds\")\n\t.valuesEqual([\n\t    {\n\t        title:\"my title\", \n\t        id:1, \n\t        linkeds:{itemId:1, value:true}\n\t    },\n\t    { \n\t        title:\"my title 2\", \n\t        id:2,\n\t        linkeds:[\n\t            {itemId:2, value:\"133\"},\n\t            { itemId:2, value:\"hello\"}\n\t        ]\n\t    }\n\t]);"
            ],
            "itemtype": "method",
            "name": "mapOn",
            "chainable": 1,
            "params": [
                {
                    "name": "what",
                    "description": "",
                    "type": "Collection|retrievable_string"
                },
                {
                    "name": "localKey",
                    "description": "the name of the localKey to match with Collection items",
                    "type": "String"
                },
                {
                    "name": "foreignKey",
                    "description": "the name of the foreignKey to match with current entries",
                    "type": "String"
                },
                {
                    "name": "whereToStore",
                    "description": "the path where save map result in each entries",
                    "type": "String"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepHandler"
            },
            "class": "DeepHandler",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2880,
            "description": "resolve the Deferred and so the associated promise",
            "itemtype": "method",
            "name": "resolve",
            "params": [
                {
                    "name": "argument",
                    "description": "the resolved object injected in promise",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepDeferred",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2902,
            "description": "reject the Deferred and so the associated promise",
            "itemtype": "method",
            "name": "reject",
            "params": [
                {
                    "name": "argument",
                    "description": "the rejected object injected in promise",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepDeferred",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2918,
            "description": "cancel the Deferred and so the associated promise",
            "itemtype": "method",
            "name": "cancel",
            "params": [
                {
                    "name": "reason",
                    "description": "the cancel reason object injected in promise",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepDeferred",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2932,
            "description": "add .done and .fail in promise chain.",
            "itemtype": "method",
            "name": "then",
            "params": [
                {
                    "name": "sc",
                    "description": "successHandler",
                    "type": "Function"
                },
                {
                    "name": "ec",
                    "description": "errorhandler",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepDeferred",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2942,
            "description": "add .done callback handler in promise chain",
            "itemtype": "method",
            "name": "done",
            "params": [
                {
                    "name": "argument",
                    "description": "successHandler",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepDeferred",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2951,
            "description": "add .fail callback handler in promise chain",
            "itemtype": "method",
            "name": "fail",
            "params": [
                {
                    "name": "argument",
                    "description": "successHandler",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepDeferred",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 2989,
            "description": "add .done callback handler in promise chain",
            "itemtype": "method",
            "name": "done",
            "params": [
                {
                    "name": "argument",
                    "description": "successHandler",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepPromise",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 3045,
            "description": "add .fail callback handler in promise chain",
            "itemtype": "method",
            "name": "fail",
            "params": [
                {
                    "name": "argument",
                    "description": "successHandler",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepPromise",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 3103,
            "description": "add .done and .fail in promise chain.",
            "itemtype": "method",
            "name": "then",
            "params": [
                {
                    "name": "sc",
                    "description": "successHandler",
                    "type": "Function"
                },
                {
                    "name": "ec",
                    "description": "errorhandler",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "this",
                "type": "DeepDeferred"
            },
            "class": "DeepPromise",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 3209,
            "static": 1,
            "itemtype": "method",
            "name": "promise",
            "params": [
                {
                    "name": "arg",
                    "description": "an object on when create a promise",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a promise",
                "type": "DeepPromise"
            },
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 3262,
            "description": "return a promise that will be fullfilled when arg are ready (resolve or immediat)",
            "static": 1,
            "itemtype": "method",
            "name": "when",
            "params": [
                {
                    "name": "arg",
                    "description": "an object to waiting for",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a promise",
                "type": "DeepPromise"
            },
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 3279,
            "description": "return a promise that will be fullfilled when all args are ready (resolve or immediat)",
            "static": 1,
            "itemtype": "method",
            "name": "all",
            "params": [
                {
                    "name": "arg",
                    "description": "an array of objects to waiting for",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a promise",
                "type": "DeepPromise"
            },
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 3346,
            "description": "execute array of funcs sequencially",
            "static": 1,
            "itemtype": "method",
            "name": "sequence",
            "params": [
                {
                    "name": "funcs",
                    "description": "an array of functions to execute sequentially",
                    "type": "String"
                },
                {
                    "name": "args",
                    "description": "(optional) some args to pass to first functions",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a handler that hold result",
                "type": "DeepHandler"
            },
            "class": "deep",
            "module": "deep"
        },
        {
            "file": "deep.js",
            "line": 3742,
            "description": "retrieve request (if string in retrievable format) (e.g. \"json::test.json\")\nperform an http get\nif request is not a string : will just return request",
            "static": 1,
            "itemtype": "method",
            "name": "get",
            "params": [
                {
                    "name": "request",
                    "description": "a string to retrieve",
                    "type": "String"
                },
                {
                    "name": "options",
                    "description": "(optional)",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a handler that hold result",
                "type": "DeepHandler"
            },
            "class": "deep",
            "module": "deep",
            "submodule": "deep.stores"
        },
        {
            "file": "deep.js",
            "line": 3782,
            "description": "retrieve an array of retrievable strings (e.g. \"json::test.json\")\nif request is not a string : will just return request",
            "static": 1,
            "itemtype": "method",
            "name": "getAll",
            "params": [
                {
                    "name": "requests",
                    "description": "a array of strings to retrieve",
                    "type": "String"
                },
                {
                    "name": "options",
                    "description": "(optional)",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a handler that hold result",
                "type": "DeepHandler"
            },
            "class": "deep",
            "module": "deep",
            "submodule": "deep.stores"
        },
        {
            "file": "promise.js",
            "line": 1,
            "author": "Gilles Coomans <gilles.coomans@gmail.com>",
            "class": "utils",
            "module": "deep"
        },
        {
            "file": "promise.js",
            "line": 4,
            "description": "Wrapper of promises : jquery promise for browser side,  and promised-io on ssjs (tested on nodejs).",
            "class": "utils",
            "module": "deep"
        },
        {
            "file": "utils.js",
            "line": 22,
            "description": "swig related : produce swig-macro-import string",
            "deprecated": true,
            "category": [
                "swig"
            ],
            "itemtype": "method",
            "name": "getMacroImport",
            "static": 1,
            "params": [
                {
                    "name": "controller",
                    "description": "",
                    "type": "ViewController"
                },
                {
                    "name": "macrosSet",
                    "description": "",
                    "type": "Array"
                }
            ],
            "return": {
                "description": "the macro import string",
                "type": "String"
            },
            "class": "utils",
            "module": "deep",
            "submodule": "utils"
        },
        {
            "file": "utils.js",
            "line": 59,
            "description": "interpret a string with a context : means fetch in context and replace in string any variable-string-format (e.g. { my.property.in.my.context }) \nfounded in string",
            "example": [
                "\n\t\tvar interpreted = deep.utils.interpret(\"hello { name }\", { name:\"john\" });",
                "\n\t\t// equivalent of first example\n\t\tvar interpreted = deep(\"hello { name }\").interpret({ name:\"john\" }).val();"
            ],
            "itemtype": "method",
            "name": "interpret",
            "category": [
                "stringUtils"
            ],
            "static": 1,
            "params": [
                {
                    "name": "string",
                    "description": "the string to interpret",
                    "type": "String"
                },
                {
                    "name": "context",
                    "description": "the context to inject",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "the interpreted string",
                "type": "String"
            },
            "class": "utils",
            "module": "deep",
            "submodule": "utils"
        },
        {
            "file": "utils.js",
            "line": 163,
            "description": "make a copy of provided array, but do not copy items. just reproduce an array with same items.",
            "itemtype": "method",
            "name": "copyArray",
            "static": 1,
            "params": [
                {
                    "name": "arr",
                    "description": "",
                    "type": "Array"
                }
            ],
            "return": {
                "description": "the array copy",
                "type": "Array"
            },
            "class": "utils",
            "module": "deep",
            "submodule": "utils"
        },
        {
            "file": "utils.js",
            "line": 176,
            "description": "clone a function and copy it's proto or vars.",
            "itemtype": "method",
            "name": "cloneFunction",
            "static": 1,
            "params": [
                {
                    "name": "fct",
                    "description": "the function to copy",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "the cloned function",
                "type": "Function"
            },
            "class": "utils",
            "module": "deep",
            "submodule": "utils"
        },
        {
            "file": "utils.js",
            "line": 196,
            "description": "copy any object/value/array deeply. (e.g. any array will be copied AND also its items).\nAny function encountered will not be cloned (simply use same ref). (just deep decorators will be)",
            "itemtype": "method",
            "name": "copy",
            "static": 1,
            "params": [
                {
                    "name": "obj",
                    "description": "",
                    "type": "Object|Primitive"
                }
            ],
            "return": {
                "description": "the copied value/object/array",
                "type": "Object|Primitive"
            },
            "class": "utils",
            "module": "deep",
            "submodule": "utils"
        }
    ],
    "warnings": [
        {
            "message": "Missing item type",
            "line": " testcases/app.js:1"
        },
        {
            "message": "Missing item type",
            "line": " deep-collider.js:139"
        },
        {
            "message": "Missing item type\ntest equality (deep-equal) with collided value",
            "line": " deep-collider.js:165"
        },
        {
            "message": "Missing item type",
            "line": " deep-collider.js:192"
        },
        {
            "message": "Missing item type\nanalyse path and return parsed paths objects",
            "line": " deep-query.js:222"
        },
        {
            "message": "Missing item type",
            "line": " deep-request.js:1"
        },
        {
            "message": "Missing item type\nTODO : DeepRequest.late.post(...) : return function which will do post later\n\ncrossDomainXML : add options with proxy or YQL\n\nmaintain cache for each reload seqquence : if in the same load bunch there is sam paths : use cache in place of retreieve multiple time the same file\n\nprotocole to add : \n\ndata-model::\nfs::\n\n\n\n\nprotocoles :\n\nextensions : \n\nparsers : \n\nresponseParser\n\tread reponse.headers.contentType : \n\t\nvar jqueryRequest = function(info, options){\n\toptions = options || {};\n\tvar headers = options.headers || {};\n\tutils.up(this.requestHeaders, headers);\n\tvar self = this;\n\treturn promise.when($.ajax({\n\t\tbeforeSend :function(req) {\n\t\t\twriteJQueryHeaders(req, headers);\n\t\t},\n\t\turl:info.uri, \n\t\tmethod:\"GET\", \n\t\tdata:null,\n\t\tdatatype:self.options.datatype || \"json\"\n\t})\n\t.done(function (  data, msg, jqXHR ) {\n\t\treturn self.parse(data, info, options);\n\t})\n\t.fail(function ( jqXHR ) {\n\t\treturn new Error(\"DeepRequest.load failed : \"+JSON.stringify(info));\n\t}))\n}\nvar setHeaders = function (req) {\n\t\n}\n\nvar deepAction = {\n\t\"dom.appendTo\" : { // dom.appendTo::#id\n\t\taction:function (info, datas) {\n\t\t\t// body...\n\t\t}\n\t}\n}\n\nvar vc = {\n\tplaceInDOM:deep.action(\"dom.appendTo::#id\")\n}\nvar dr = {\n\tlexic:{\n\t\tjson:{\n\t\t\toptions:{\n\t\t\t\tqueriable:true,\n\t\t\t\tdatatype:\"json\"\n\t\t\t},\n\t\t\trequestHeaders:{\n\t\t\t\t\"accept\":\"application/json;charset=utf-8\"\n\t\t\t},\n\t\t\tresponseHeaders:{\n\t\t\t\t\"content-type\":\"application/json;charset=utf-8\"\n\t\t\t},\n\t\t\taction:baseRequest,\n\t\t\tparse:function(response, infos, options) {\n\t\t\t\t// body...\n\t\t\t}\n\t\t},\n\t\thtml:{\n\t\t\toptions:{\n\t\t\t\tqueriable:false,\n\t\t\t\tdatatype:\"html\"\n\t\t\t},\n\t\t\trequestHeaders:{\n\t\t\t\t\"accept\":\"text/html;charset=utf-8\"\n\t\t\t},\n\t\t\tresponseHeaders:{\n\t\t\t\t\"content-type\":\"text/html;charset=utf-8\"\n\t\t\t},\n\t\t\taction:baseRequest,\n\t\t\tparse:function(response, infos, options) {\n\t\t\t\t// body...\n\t\t\t}\n\t\t}\n\t},\n\tget:function (info, options) {\n\t\tif(typeof info === 'string')\n\t\t\tinfo = this.parse(info);\n\t\tvar handler = this.lexic[info.protocole];\n\t\tif(!handler)\n\t\t\tthrow new Error(\"DeepRequest : no handler found with : \",info); \n\t\treturn handler.action(info, options);\n\t}\n\tall\n\t_______\n\n\tjson\n\txml\n\trss\n\ttext\n\thtml\n\n}",
            "line": " deep-request.js:5"
        },
        {
            "message": "Missing item type\nselect login controller : give controller chain",
            "line": " deep-restart.js:352"
        },
        {
            "message": "Missing item type\nPermit to manipulate server store through restful IO...",
            "line": " deep-restart.js:388"
        },
        {
            "message": "Missing item type\nDo post on login services.\n\t\tIf arg is provided : post arg as login object.\n\t\tIf no args : use from ui if possible",
            "line": " deep-restart.js:395"
        },
        {
            "message": "Missing item type\nget object from store",
            "line": " deep-restart.js:406"
        },
        {
            "message": "Missing item type\nTODO : \nadd distinct(testPropertyPath)\nadd merge()\nadd backgrounds()  :  do object extension with deep-extender + schema\n\n\n\nadd _ancestor (any ancestor)\nadd _brothers  (any brothers)\n\n! TEST ALL operations !",
            "line": " deep-rql.js:14"
        },
        {
            "message": "Missing item type\nTODO : \njson-pointer dereferencement\t\t\t\t\t\t\tOK\nadd relative reference to json-pointer\t\t\t\t\tOK\ndependencies : clarify, and/or implement if(constraint.match(root)) constraint(value)\nlinks dereferencer  : template-engine + instance injection + DeepRequest.retrieve\nréférencement interne : backgrounds ou $ref with json-pointer\t\t\t\t\tOK\n\n\n\nPatterns :\n\t- name patterns + data : regExp, enum, direct       (could be external)\n\t- query pattern : if query then pattern match\n\n\tproperties:{\n\t\tchristophil:{\n\t\t\tdependenciesQueries:\n\t\t\t{\n\t\t\t\tmatchEurope:{     // it's the relation/dependency name\n\t\t\t\t\tquery:\"\",\n\t\t\t\t\trequired:true,   // mean that the query MUST give something : so the dependency MUST be valid\n\t\t\t\t\tpatternProperties:{\n\t\t\t\t\t\t\"$ref\":[ \"json::/Pathologies/?type=perenial&zone=europe&$result=hash\" ]  // exemple of external patterns definitions\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tmatchUK:{\n\t\t\t\t\tquery:\"\";\n\t\t\t\t\trequired:false,  // optional dependency\n\t\t\t\t\tproperties:{\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\nproperty name + data pattern : could be an external link to a service that provides a list of acceptable values.\nImagine you would define a pathologie list for plants. Each plant could be sensible to a subset of those pathologies, and could have different kinds of sensibility...\nThe service could provids the list of known pathologies, and the subset have to match",
            "line": " deep-schema.js:208"
        },
        {
            "message": "Missing item type\nconsole.flags : {\n\tvalidationError,\n\tvalidator\n}",
            "line": " deep-schema.js:253"
        },
        {
            "message": "Missing item type",
            "line": " deep.js:2"
        },
        {
            "message": "Missing item type",
            "line": " promise.js:1"
        },
        {
            "message": "Missing item type\nWrapper of promises : jquery promise for browser side,  and promised-io on ssjs (tested on nodejs).",
            "line": " promise.js:4"
        }
    ]
}