deep fait exactement ce qu'il fat quandil faut
14:12
et les problème rencontrés ne viennet pas de deep
14:12
mais de la modélisationd e l'app ente autre
Eric Van Damme 14:12 
ahwé ça aussi
Gilles Coomans 14:12 
parce que deep n'est pas là pour remplacer une belle pattern MVC
14:13
c'est pas son role
14:13
et pour une app pleinement workable et facile à utiliser
14:13
faut un beau model MVC tout propre
Eric Van Damme 14:13 
méwé
14:14
si on a un bon marteau on n'est pas bon menuisier pour autant Clin d'œil
Gilles Coomans 14:14 
Sourire
14:14
non mais c'est comme jquery
14:14
jquery c'est génial
14:14
mais avec jquery seul
14:14
ca fait pas une belle page Sourire
Eric Van Damme 14:14 
clair Sourire
Gilles Coomans 14:14 
faut savoir quoi faire et avoir le bon code html derrière
14:14
ben deep c'est pareil
Eric Van Damme 14:15 
yep
Gilles Coomans 14:15 
c'est totalement non obstrusif
14:15
ce qui est super
14:15
comme jquery
Eric Van Damme 14:15 
atta phone
Gilles Coomans 14:15 
et donc parce que c'est non obstrusif
14:15
ben ca demande un beau js derrière
14:15
puisque deep est au js ce que jquery est au dom
14:15
Sourire
14:16
et donc deep aide à manipuler n'importe quelle app fait en js
14:16
comme jquery aide à manipuler n'importe quelle page web
14:17
mais donc deep n'est ps responsable de l'app elle mêe
14:17
Sourire
14:17
deep-ui oui puisqu'elle dicteune strucure, un framework Sourire
14:17
tu voisla dif ?
14:18
en fixant deep-ui et ses controller
14:18
ca devient osbstrusif
14:18
et donc ca fixe la gueule de l'app (oud'une partie)
14:18
et donc la ca peux poser des incohérence du au modèle
14:18
mais bon ce n'est pas le cas
14:19
deep-ui est suffisament light pour pas faire chier
14:19
mais c'est ca le truc
14:19
deep n'est que des outils
14:19
et les outils ne force rien
14:20
c'est pas deep qui force le fait d'utiliser smart en global par exemple
14:20
ca c'est la manière dont on a construit le model d'une app chz nous
14:20
doncdeep-ui
14:21
tu vois la dif ?
14:21
Sourire
14:21
et donc aussi
14:21
comme jquery
14:21
deep peut toujours ere remplacer par du js standard à tout moment
14:21
sans poser de problème
14:21
puisqu'iol ne force rien
14:22
donc faut pas utiliser deep absolument pour tout
14:22
c'est la qu'on utilise pas les outils de la bonne manière
14:22
quand en js standard c'est plus court Sourire
14:23
maisbon deep raccourcit déjà énormemen les choses
14:23
et gère beaucoup des erreurs etc
14:24
donc c'esttjrs bon d'utilser deep
14:24
ca assainit les méthode
14:24
comme jquery de nouveau
14:24
Sourire
Eric Van Damme 14:31 
oué Sourire
Gilles Coomans 14:32 
et donc pour terminer Sourire
14:32
ben deep c'est trois choses au final
14:33
un API complet des outils derières (deep-request, deep-query, deep-rql, deep-compose, etc)
14:33
+ une chaine asynch
14:33
+ une chain synch
14:33
donc les deux chaines sont la pour masquer la complexité de l'API complet
14:33
mais donc à tout moment on peut quand même l'utiliser
14:34
c'est pas si complexe dans plein de cas
14:34
et souvent c'est plus direct qu'une chain asynch




pourquoi jquery+dom like : c'est le coeur de la philo de deep

Cadre
Puisque web et qu'on est moderne :) : 
	on veut MVC/Thin serveur

	succès d'un beau MVC : réduire le couplage du controller vers Model et View
	
	Coté vue : 
	Thin Server : couplage Controller-Model minimum grace au Restful : Keep things simple.
	jquery/css : permet de réduire le couplage Controller-View.

	D'où :
	(mVC) ----- MC 
	Avec le controlleur serveur qui manipule le modele (ressources + relations + droits d'accès) au travers d'un interface Restful/OCM



jquery/css : qu'est ce que ca change : 

	Queries : 

	plus on peut programmer à l'aveugle : plus on peut faire générique...

	si jquery fonctionne si bien : c'est qu'on peut faire du super MVC où le controller ne conait que le minimum structurel (les jqueries) de la vue.

	ici : en passant par une query nous ne sommes plus obligé de connaitre la gueule de l'objet réel.

	Deux aspects dans la jquery : 
		query structurelle : path
		query meta-données : classes + ids
			Le coté pratique et optimisé de la query tient surtout la dedans.

	Layers :

		Double effet kiss cool : 
			jquery + css :  réduit le couplage d'une deuxième manière : 
				l'empilement
					exemple : click : anim en couche
					réouverture css

Application à la modélisation JS : 

	l'OO c'est super : encapsulation/responsabilité, héritage.

	OO classique : rigide parce que pas de localité à posteriori : tout est forgé à priori.
	OO classique : rigide parce que pas de couche.
		ornitorinque

	

up, bottom : DEEP
deep-queries :
	meta données : équivalent 
aspects

Formule : 
layered and queried object oriented programmation 

couches view-controller + server-controller = MDD oriented : 
	puisque chaque aspect est un model appliqué


Implémentation : 
et donc asynch puisque thin-server

	donc la chaine : linéarisation au lieu de récursion




______________________________


identité et position : groupe associatif non commutatif dont le neutre est la couche vide

pour conserver l'identité dans la position sans devoir cloner : 
	: conserver dans classes:[] les selecteurs d'identité

	: écrire couche inverse de chaque identité
	: donc pour défaire une composition de fonctions : conserver la référence de la fonction wrappé dans la couche inverse

	couche inverse up : 
	{
		classes:deep.collider.remove("identity-class"),
		functionRef:oldRef or deep.collider.remove(),
		data: copy of old or deep.collider.remove()
	}

	couche inverse bottom : 
	{
		classes:deep.collider.remove("identity-class"),
		functionRef:oldRef or nothing,
		data: copy of old or nothing
	}


	donc lors changement identité : 
		dans position : stocker :
			couche inverse ?
			puisque api de base est gros et que changement identitaire sont limités :
				oui : conserver couche inverse : = plus légé

			==> puisque le changement identitaire est initié depuis l'identité elle même : (il n'est pas encore possible de cumuler les identité dynamiquement)
			
			==> le changement doit etre fait avec connaissance complete de l'API d'arrivé
			==> c'est au programmeur de l'identité du handler qui revient de maitriser API de départ et celui d'arrivé

		pour un changement dynamique des identités : 
			stocker toutes les couches inverses + identité de départ
			stocker juste les classes et recompiler la total
		le problème c'est qu'il faut connaitre l'api complet pour la définition du comportement

	avec couche inverse : 
		les couches + deep.up + couche inverse : = groupe associatif non commutatif  dont le neutre est la couche vide


	

deep
	.store("json::/Discipline/")
	.query("/brol")
	.render(...)
	.bind(...)
	
	ViewController.prototype.preload

binding type : 
	data-path
	html_to_json
	data-item
*/

deep.store = function (name, definer, options) 
{
	options = options || {};
	if(!definer)
	{
		if(!deep.stores[name])
			throw new Error("deep.store(name) : no store found with : ", name);
		return deep.stores[name];
	}
	if(definer instanceof Array)
		return new deep.store.ArrayStore(definer, options);
	if(definer instanceof DeepStore)
	{

	}
	if(typeof definer.get === 'function')
	{

	}
	// body...
}

deep.store.DeepStore = function () {
	// body...
}
deep.store.DeepStore.prototype = {}

deep.store.ArrayStore = function (arr, options) {
	var store = new deep.store.DeepStore();
	options = options || {};

	deep.utils.up({
		get:function (id) {
			if(id[0] == "." || id[0] == "/")
				deep(arr).query(id).values();
			return deep(arr).query("./*?id="+id).val();
		},
		put:function (id, object) {
			id = id || object.id;
			if(options.schema)
				deep(object)
				.validate(options.schema)
				.fail(function (error) {
					object = error;
				})
				.root(arr)
				.replace("./*?id="+id, object);
			else
				deep(arr)
				.replace("./*?id="+id, object);
			return object;
		},
		post:function (id, object) {
			id = id || object.id;
			if(!id)
				object.id = id = BSON.ObjectID.createPk().toJSON(); // mongo styled id
			if(options.schema)
				deep(object)
				.validate(options.schema)
				.done(function (report) {
					arr.push(object);
				})
				.fail(function (error) {
					object = error;
				});
			return object;
		},
		del:function (id) {
			deep(arr).remove("./*?id="+id);
			return true;
		},
		patch:function (id, object) {
			return deep(arr).query("./*?id="+id).up(object).val();
		}
	}, store);
	return store;
};

deep.store.ObjectStore = function (obj, options) {
	var store = new deep.store.DeepStore();
	options = options || {};
	deep.utils.up({
		get:function (id) {
			if(id[0] == "." || id[0] == "/")
				deep(obj).query(id).values();
			return deep(obj).query("./"+id).val();
		},
		put:function (query, object) {
			deep(obj)
			.replace(query, object)
			.done(function (replaced) {
				if(replaced.length === 0)
					object = replaced.shift();
				else
					object = replaced;
			});
			return object;
		},
		post:function (path, object) {
			if(options.schema)
				deep(object)
				.validate(options.schema)
				.fail(function (error) {
					object = error;
				})
				.root(obj)
				.setByPath(path, object);
			else
				deep(obj)
				.setByPath(path, object);
			return object;
		},
		del:function (id) {
			var res = [];
			if(id[0] == "." || id[0] == "/")
				deep(obj).remove(id)
				.done(function (removed) {
					res = removed;
				});
			else
				deep(obj).remove("./"+id)
				.done(function (removed) {
					res = removed;
				});
			return res.length !== 0;
		},
		patch:function (id, object) {
			if(id[0] == "." || id[0] == "/")
				return deep(arr).query(id).up(object).values();
			return deep(arr).query("./"+id).up(object).val();
		}
	}, store);
	return store;
};

deep.store.CookieStore = function (options) {
	var store = deep.store.ObjectStore({}, options);
	deep.utils.up({
		get:function (id) {
			/*
				faut analyser l'id/query : choper la premiere partie : doit etre l'entrée dans les cookies : toute variable chopée est assumée json like.
				executer la query résiduelle sur objet chopée (if any)

				idem pour chaque accessor
			*/
			$.cookie(id)
		}
	},store);
};



deep.stores.json = function (options) {
	var store = deep.store.ObjectStore({}, options);
	return deep.utils.up({
		get:function (id) {
			/*
				faut analyser l'id/query : choper la premiere partie : doit etre l'entrée dans les cookies : toute variable chopée est assumée json like.
				executer la query résiduelle sur objet chopée (if any)

				idem pour chaque accessor
			*/
			$.cookie(id);
		}
	},store);
};
deep.protocoles.json = {
	store:deep.stores.json,
	extensions:["json"]	
}

deep.stores.swig = function (options) {
	var store = deep.store.ObjectStore({}, options);

	return deep.utils.up({
		get:function (id) {
			/*
				faut analyser l'id/query : choper la premiere partie : doit etre l'entrée dans les cookies : toute variable chopée est assumée json like.
				executer la query résiduelle sur objet chopée (if any)

				idem pour chaque accessor
			*/
			$.cookie(id);
		}
	},store);
};


/*
	créer meta store de base : json, storage...
	créer store de base : swig, cookie, 

	créer un store = 
		instancier un DeepStore
		en closure gerer cache éventuelle
		gerer range dans collections

		ajouter dans le dico des protocoles de base: 
			swig::
			cookie::
			json::
			storage::
			...

		pour store custom :
			ajouter store::name
			et base_protocole::uri/query/id

*/

/*
	Node : store could be local (json, sql, files,...) 
	and remote : ws, jsonp, etc.

	Browser : remote : ws, ajax (json, xml, ...), 
	local : cookies, localStorage

	store could be collections or object

	deep("cookie::/autobahn-session")		// browser : jquery-cookie, node : node-cookie 
	deep("json::uri")			// browser :  ajax, node : autobahn-statics
	deep("html::uri")			//    same
	deep("swig::uri")			//    same
	deep("xml::uri")			//    same
	
	deep("storage::/brol/*")		// browser : jstorage, node : memory-store?

	deep("json::/campaign/") 	// browser : json/ajax+uri,   node : autobahn-facets

	deep("campaign::12344")		// browser : json : node : mongo
	deep("campaign::/12344")
	deep("campaign::/*?userId=134")
	deep("campaign::?userId=134")

	deep.store("campaign").get("gdgeh54").then().is().a().chain().back().get();
	deep.store("campaign").post({...}).then().is().a().chain()
	deep.store("campaign").put({...}, 12).then().is().a().chain()
	deep.store("campaign").del("gdgeh54").then().is().a().chain()
	deep.store("campaign").patch(...).then().is().a().chain()
	deep.store("campaign").rpc(...).then().is().a().chain()
	deep.store("campaign").range(...).then().is().a().chain().post().back();

	deep.requestAll(["protocole::","..."]);

	on node :  it's uri analyse that gives the difference between :  deep("json::uri") on statics or on facets
		
	on autobahn :

	deep("fs::/templates/file.html").done("")
	autobahn().store("fs").get("")
	autobahn(sessionObject).statics("/campaign/")
	autobahn("public").route("/campaign/1234543/informations")
	autobahn("admin","user").store("hello")
	autobahn("admin","user").request("/campaign/", "post", body, header)
	autobahn(nodeRequest)
	
	deep("mongo::/push/campaign").put({...})
	deep.store("campaign").put({...})

*/



/*

deep.store("json", {
	environement:"browser",
	header:{},
	get:function (request) {
		if(typeof request === 'string')
			request = deep.request.parse(request);
		return deep.when($.ajax({
			...
		}))
	},
	put:function (uri, object) {
		// body...
	},
	post: function (uri, object) {
		// body...
	},
	del:function  (uri) {
		if(!uri)
		{
			
		}
	},

	rpc:function (uri, id, method, args) {
		// body...
	},
	create:function (name, uri) {
		return deep.store(name, deep({
			get:deep.compose.before(function (request) {
				return [uri, request]
			}),
			del:deep.compose.before(function (id) {
				if(id)
				{
					id = this.val();
				}
				return [uri]
			}),
			put:deep.compose.before(function (object) {
				return [uri, object]
			}),
			post:deep.compose.before(function (object) {
				return [uri, object]
			}),
			rpc:deep.compose.before(function (id, method, args) {
				return [uri, id, method, args];
			})
		})
		.bottom(this));
	}
})



deep.store("local-storage", {
	get:function (request) {
		// body...
	},
	put:function (request) {
		// body...
	},
	post: function (request) {
		// body...
	},
	del:function  (request) {
		// body...
	}
})

deep.store("cookies", {
	get:function (request) {
		// body...
	},
	put:function (request) {
		// body...
	},
	post: function (request) {
		// body...
	},
	del:function  (request) {
		// body...
	}
})

var myVar = deep("cookies::/!")

deep
.store("cookies") // marque la position
.get("myVar") // try get it through store handler
.put() // without argument : try post what chain hold : maybe nothing : if nothing : inject error, else inject putted result and hold it
.post({ ... }) // inject posted result and hold it (if any and no error)
.render(...)
.back("cookies")
...

deep.store("json").create( "discipline", [] || {} || "/discipline/", {
	schema:null,
	reloadable:true,
	errors:{
		405:function function_name (argument) {
			// body...
		}
	}
});
==> create store : simple REST API + rpc  
==> dico protocole : json::/discipline/ AND store::discipline

deep("store::discipline")
.get(12)

deep("json::/discipline/")


deep(...)
...
.store("discipline") // keep current entries but save position as discipline. chain become store chain
.post(...)


deep(...)
.replace("...",1)
.post("json::/discipline/" || deep.store("discipline")) // not previously defined as store chain : post need argument
// post on uri or on store, inject and hold success, inject any error
// will create store if necessary : chain become store chain

deep(...)
.query("...")
.range(1,4) // s'applique tjrs à la dernier position connue : si pas : crée la position
...
.store("campaign") // keep current entries but save position as discipline. chain become store chain. if no disicpline store exist : create it with current entries.
.range(12,23) // s'applique tjrs à la dernier position connue : si pas : crée la position
.position("camp_range")
.query("/comments") 
.range(1,5) // as the last position is different from current path
.done(function (comments, clone) {

	var total = clone.count();
	var range = clone.range(); // no arguments will give current range object containing total/start/end/step/width
	//...
})
.back("camp_range")
.query("/competences")
.range(1,6)
.back("campaign")
.range(24,36)
...
.range({
	step:1,
	width:5 // default
}) // do the setup of the range and go to that point if possible or give last possible range
...
.nextRange(function (items, clone) {
	// body...
})
...
.previousRange(function (items, clone) {
	// body...
})

.position(....)
.range(12,34)
.done(function (items, clone) {
	var total = clone.count();
	var range = clone.range();
	//...
})
...
.back()
.range(35,46)
.done(function (items, clone) {
	var total = clone.count();
	var range = clone.range();
	//...
})
.back()
.range(..,..)
.done(function (items, clone) {
	var total = clone.count();
	var range = clone.range();
	//...
})


// most usual case
deep("store::campaign")
.range({
	step:3, // step could be float
	width:5
}) // inject campaigns in chain and hold them
.done(function (rangeObject, handler) {

})

et .back() sans arguments devrait revenir à la derniere position (pop) 


//_______________

each time clone need to be done in "_then_ familly"
: in place of clone : hold current queue in temp array
and give handler reference with empty queue
add a done when return (if return value is the handler ref or any promise)
that rinject previous queue in handler (this.queue) to continue
: results is that queue could grow from the interior

.done(function (success, handler) {
	if(success.myVar)
		return handler.branches(function (creator) {
			// ...
		});
	else
		return handler.query("...").val();
})
.fail(function (error, handler) {
	if(error.status == 404)
		return handler.branches(function (branch) {
			branch().query("...").load().run("refresh");
			branch().query("...").load().run("refresh");
			return branch;
		})
		.delay(5000)
		.logout()
		.query("...").run("refresh");
	else
		return handler.query("...").run("refresh");
})

//__________________________________________________________

deep.request.setProtocole("stock", {} || []);

deep("stock::/your/query?a=1")
....

deep("stock::/!")
.replace("/your/query?a=1", value)
....


// case  :you have a bunch of item, identicaly renderable and bindable

	deep(...)
	.query("...")
	.render({
		what:"...",
		how:"",
		where:"",
		bind:{
			type:"data-path",		// default
			schema:"json::....",
			fail:function ($node, injected, binder) {
				// manage entry error
			},
			done:function  ($node, injected, binder) {
				// add custom behaviour on $node
			}
		},
		done:function ($node, injected, binder) {
			// 'this' here mean the context from where the rendering is done (by default the same as injected in how)
			// add overall custom behaviour on $node
		}
	})
	.done:function ($nodes) {
		// $nodes is all the rendered/placed dom nodes, and injected in chain by .render()
		// add submit behaviour : return promise of submition : so the post (next chaining) will be fired on submition
	}
	.post("...") // will post all the queries results that was binded with .render(). .post() is a _done_ familly and will only be fired if submition success 
	.fail(function (postError) { // error could be from .render()
		// body...
	})
	.canceled(function (reason) { // cancelation could be fired before or after .post() and will be managed here
		// body...
	})
	.done(function (postSuccess) { 
		// body...
	});

//_______________________________________________________

case : you have an already constructed form (or bunch of inputs) somewhere in DOM, and you want to bind it without rendering (it's already done)

	deep({ name:"ced" })
	.bind("#form-contact", {
		type:"data-path",		// default
		errorHandler:function ($nodes, binder) {
			// manage errors
		},
		done:function ($nodes, ) {
			// add behaviour
		}
	})
	.done(function (binder) {
		var def = deep.Deferred();
		var self = this;
		nodes.find("...").click(function (argument) {
			var report = binder.validate();
			if(report.valid)
				def.resolve(report.value);
		});
		return deep.promise(def);
	})
	.post(...)


	dans _deep_entry : stocker le binder
	

//_______________________________________


protocole : app::

si on a plusieurs app : on peut seter un truc genre :

deep.request.protocole("app2", {
	parse:function (request) {
		// body...
	},
	get:function (argument) {
		// body...
	}
})

ou

deep.request.protocole.app("app2", monApp)

//________________________________________________


d'ailleurs : 
deep(deep.request).up({
	protocoles:{
		json:{
			parse:function (protocoleInfos, request) {
				return deep.request.parser(request).uri(false).deeprql(false)
			},
			get:function (parsed) {
				return $.ajax(...)
			}
		},
		"json.range":{
			parse:function (protocoleInfos, request) {
				return deep.request.parser(request).uri(false).deeprql(false)
			},
			get:function (parsed) {
				return $.ajax(...)
			}
		}
	}
})

deep.request.protocole(["app2"], {
	parse:function (protocoleInfos, request) {
		return deep.request.parser.rql(request)
	},
	get:function (parsed) {
		
	}
});

deep.request.protocole(["app","rss"], {
	parse:function (protocoleInfos, request) {
		return deep.request.parser.rql(request)
	},
	get:function (parsed) {
		
	}

});

//____________________

pas de deep.request(...)
puisque :
deep(...).chain

et deep.request.all().chain
deep.request.json()
deep.request.range() ...





//____________________________________



deep.store("json::/campaign/").query("...").up(...).put()

deep
.store("json::/campaign/")
.query("...", { range:... })
.ui()
.render(...)
.bind(...)
...


// set dummies or custom store : 
deep.store("json::/campaign/", [...])


deep.store("json::/campaign/")
.range(...)
.done(function (range) {
	 // e.g. set pager
}) 
.render(...)
.bind(...)
.done(function (nodes) {
	
})

...

deep.ui("...").render().bind()


//______________



/*
	add on : 

	deep.firstReturn(fn, fn, fn, fn,....);

	and deep.compose.stopIfReturn()


	pour la chaine : 


	deep(obj, schema, opt)

	ou deep([obj, obj, obj], schema, opt)

	+

	split chain : 

	no more  promise : 

	just deep(...) donne full api deep

	+


	.ui() = donne chaine ui (full + restriction + refresh + deeplink + bind ...)
	.bootstrap() = donne chain ui + modal + pager + 

	.autobahn() = roles + facets + ressources + routes + statics
	
	.smartui() = ui + specific
	.smartbahn() = autobahn + specific
	
*/


	Stable : 
		deep-query/rql
		deep
		utils


Cadre : 

Layered/Aspect/OO
	relations, inheritance and relative path
MVC
	up-bottom
	
Asynch
Thin Server / Rest
JSON

	CCS
	class composition

	colliders 


TODO : 
	deep
		.query just execute query (on each current entries) and inject the concatenation of results in the chain
		.move change current entries

	deep-compose : manage classes
	deep-collider : write more
	deep-schema and CCS :
		CCS model and algorithm

	deep-request : complete refactoring
	
	deep-plugin : 
		Handler pattern
		handler base objects

	promise pattern : 
		the first and only argument must give light weight (and secured - in a small dedicated object) API to access the chain handler itself SYNCHRONOUSLY 
		And : for asynch management : it must give access for branches creator and will act as promise when returned (only for branches therefor all other function of the handler are synchro)

		example : 
			deep(...).done(function(success, handler){
				var values = handler.values();
				...
				if(true)
					return handler.cancel();
				...
				if(true)
					return handler.query("./tata");
				...
				if(error)
					return handler.error("what you want")

				handler.branch().mybranch();
				handler.branch().mybranch();
				handler.branch().mybranch();

				return handler;
			})


	test cases pattern : 
		assertEqual
		assertValuesEqual
		assertTrue
		assertFalse
		validate

		maybe pattern to keep (clone) whole trunc to be execute in general test caser on demand (later)
			example :

			to store and execute multiple time the cloned chain (or any chain) for tests purposes : we need something like :

			var d = deep(...).pushTo(tests).keepQueue().mychain()

			and

			d.restart()

			==> implies to modify the nextQueueItem
				and to keep first reference of the chain.


		put condition on tests and validation family : 
			good pattern : keep a global with flags that will be used as condition
				example : 
					deep(...).mychain().assertEqual({}, { condition:console.flags.bazar, callBack:Reporter.report })
				so you could debug live by playing with flags
	autobahn : 
		secured chain
		jsgi stack
		clean headers
 */



ce qui reste : 
	- test cases pattern and classes
	- refactoriser chain : remove self._queried ?

	- gestion classes dans compositions

	- deepLoad : qu'il sauve la structure dans un _deep_entry dans l'objet deepLoadé
		- check si _deep_entry existe pour reload

Videos : 

	MODELISATION
	- up/bottom/composition/colliders
	- queries, selectors and OOP related
	- stores and protocoles
	- ocm


	- facet


	RUN TIME
	- start chain + simple protocole : load something
	- chain base handlers and concept : log, logValues, done, fail + errors management, always
	- full chain api :  val, each, values, query, load, deepLoad,...
	- synch usage of chain
	- branches
	- custom protocoles
	- stores usage


	NODE
	- simple server
	- routes usages


